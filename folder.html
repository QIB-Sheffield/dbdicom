<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>dbdicom.folder API documentation</title>
<meta name="description" content="Defines the central `Folder` class for reading and writing to DICOM folders â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dbdicom.folder</code></h1>
</header>
<section id="section-intro">
<p>Defines the central <code><a title="dbdicom.folder.Folder" href="#dbdicom.folder.Folder">Folder</a></code> class for reading and writing to DICOM folders.</p>
<p><code><a title="dbdicom.folder.Folder" href="#dbdicom.folder.Folder">Folder</a></code> is the central class of <code><a title="dbdicom" href="index.html">dbdicom</a></code> and the first point of call
for opening, closing and manipulating a folder with DICOM files. </p>
<pre><code># Example: Get a 3D numpy array from the first series in a folder.

from dbdicom import Folder

folder = Folder('C:\Users\MyName\MyData\DICOMtestData')
array = folder.open().series(0).array()
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Defines the central `Folder` class for reading and writing to DICOM folders.

`Folder()` is the central class of `dbdicom` and the first point of call 
for opening, closing and manipulating a folder with DICOM files. 

    # Example: Get a 3D numpy array from the first series in a folder.

    from dbdicom import Folder

    folder = Folder(&#39;C:\\Users\\MyName\\MyData\\DICOMtestData&#39;)
    array = folder.open().series(0).array()
&#34;&#34;&#34;

__all__ = [&#39;Folder&#39;]

import os
import pydicom
import pandas as pd

#from dbdicom import dicm, utilities
from . import dicm, utilities
from .message import StatusBar, Dialog
from .classes.database import Database


class Folder(Database):
    &#34;&#34;&#34;Programming interface for reading and writing a DICOM folder.&#34;&#34;&#34;

    
    _columns = [    # The column labels of the dataframe
        &#39;PatientID&#39;, &#39;StudyInstanceUID&#39;, &#39;SeriesInstanceUID&#39;, &#39;SOPInstanceUID&#39;, 
        &#39;SOPClassUID&#39;,&#39;NumberOfFrames&#39;, 
        &#39;PatientName&#39;, 
        &#39;StudyDescription&#39;, &#39;StudyDate&#39;, 
        &#39;SeriesDescription&#39;, &#39;SeriesNumber&#39;,
        &#39;InstanceNumber&#39;
    ]

    def __init__(self, path=None, status=StatusBar(), dialog=Dialog()):
        &#34;&#34;&#34;Initialise the folder with a path and objects to message to the user.
        
        When used inside a GUI, status and dialog should be instances of the status bar and 
        dialog class defined in `weasel`.
        &#34;&#34;&#34;
        self.__dict__[&#39;dataframe&#39;] = pd.DataFrame([]*len(self._columns), columns=self._columns)            
        self.__dict__[&#39;path&#39;] = path
        self.__dict__[&#39;status&#39;] = status
        self.__dict__[&#39;dialog&#39;] = dialog
        self.__dict__[&#39;dicm&#39;] = dicm

        super().__init__(self)

    def open(self, path=None):
        &#34;&#34;&#34;Opens a DICOM folder for read and write.
        
        Reads the contents of the folder and summarises all DICOM files
        in a dataframe for faster access next time. The dataframe is saved 
        as a csv file when the folder is closed with `folder.close()`. 
        All non-DICOM files in the folder are ignored.
        
        Args:
            path: The full path to the directory that is to be opened.

        Returns:
            The folder instance. This allows using the open() method in a 
            piping notation as in `inst = folder.open().instances()`.
        &#34;&#34;&#34;
        if path is not None: 
            self.__dict__[&#39;path&#39;] = path
        if self.path is None:
            message = &#34;please set a path before opening.&#34;
            message += &#34;\n Use folder.open(path_to_dicom_folder).&#34;
            self.dialog.information(message)
            return self
        if os.path.exists(self._csv):
            self.status.message(&#34;Reading..&#34;)
            self._read_csv()
            self.status.hide()
        else:
            self.scan()
        return self

    def scan(self):
        &#34;&#34;&#34;Reads the folder again.

        Use this function after opening the folder if the files on the folder 
        may have been corrputed or modified by another application.
        &#34;&#34;&#34;
        files = [item.path for item in utilities.scan_tree(self.path) if item.is_file()] 
        self.__dict__[&#39;dataframe&#39;] = utilities.dataframe(files, self._columns, self.status)
        self.dataframe[&#39;checked&#39;] = [False] * self.dataframe.shape[0]
        self.dataframe[&#39;removed&#39;] = [False] * self.dataframe.shape[0]
        self.dataframe[&#39;created&#39;] = [False] * self.dataframe.shape[0]
        self._multiframe_to_singleframe()
        return self

    def close(self):
        &#34;&#34;&#34;Close an open folder.
        
        This method checks if the changes have been saved and prompts the 
        user to save or restore them if not. The user also has the option 
        to cancel closing, in which case the function does nothing. 
        
        `close()` also resets the dataframe and path to default values.

        Returns: 
            True if the user has agreed to close the folder 
            (possible after save or restore) and False if the user 
            has cancelled the closing of the folder.
        &#34;&#34;&#34;
        if not self.is_open(): 
            return True
        if not self.is_saved():
            reply = self.dialog.question( 
                title = &#39;Closing DICOM folder&#39;, 
                message = &#39;Save changes before closing?&#39;,
                cancel = True, 
            )
            if reply == &#34;Cancel&#34;: 
                return False
            if reply == &#34;Yes&#34;:
                self.save()
            elif reply == &#34;No&#34;:
                self.restore()

        self._write_csv()
        self.__dict__[&#39;dataframe&#39;] = pd.DataFrame([]*len(self._columns), columns=self._columns)            
        self.__dict__[&#39;path&#39;] = None

        return True

    def is_saved(self):
        &#34;&#34;&#34;Check if the folder is saved.
        
        Returns: 
            True if the folder is saved and False otherwise.
        &#34;&#34;&#34;
        if self.dataframe.removed.any(): return False
        if self.dataframe.created.any(): return False
        return True

    def is_open(self):
        &#34;&#34;&#34;Check if the folder is currently open.
        
        Returns: 
            True if the folder is open and False otherwise.
        &#34;&#34;&#34;
        return self.path is not None

    def object(self, row, generation=4):
        &#34;&#34;&#34;Create a new dicom object from a row in the dataframe.
        
        Args:
            row: a row in the dataframe as a series
            generation: determines whether the object returned is 
                at level database (generation=0), patient (generation=1),
                study (generation=2), series (generation=3) 
                or instance (generation=4, default).
        Returns:
            An instance of one of the dicom classes defined in wedicom.classes.
        &#34;&#34;&#34;
        return dicm.object(self, row, generation)

    def instance(self, file):
        &#34;&#34;&#34;Create an instance from a filepath&#34;&#34;&#34;

        row = self.dataframe.loc[file]
        return self.object(row) 

    def print(self):
        &#34;&#34;&#34;Prints a summary of the project folder to the terminal.&#34;&#34;&#34;
        
        print(&#39; &#39;)
        print(&#39;---------- DICOM FOLDER --------------&#39;)
        print(&#39;FOLDER: &#39; + self.path)
        for i, patient in enumerate(self.children()):
            print(&#39; &#39;)
            print(&#39;    PATIENT [&#39; + str(i) + &#39;]: &#39; + patient.label())
            print(&#39; &#39;)
            for j, study in enumerate(patient.children()):
                print(&#39;        STUDY [&#39; + str(j) + &#39;]: &#39; + study.label())
                print(&#39; &#39;)
                for k, series in enumerate(study.children()):
                    print(&#39;            SERIES [&#39; + str(k) + &#39;]: &#39; + series.label())
                    print(&#39;                Nr of instances: &#39; + str(len(series.children()))) 

    def _write_csv(self):
        &#34;&#34;&#34; Writes the dataFrame as a .csv file&#34;&#34;&#34;
        file = self._csv
        self.dataframe.to_csv(file)

    def _read_csv(self):
        &#34;&#34;&#34;Reads the dataFrame from a .csv file &#34;&#34;&#34;  
        file = self._csv
        self.__dict__[&#39;dataframe&#39;] = pd.read_csv(file, index_col=0)

    @property
    def _csv(self):
        &#34;&#34;&#34; Returns the file path of the .csv file&#34;&#34;&#34;
        filename = os.path.basename(os.path.normpath(self.path)) + &#34;.csv&#34;
        return os.path.join(self.path, filename) 

    def _append(self, ds, checked=False):
        &#34;&#34;&#34;Append a new row to the dataframe from a pydicom dataset.
        
        Args:
            ds: and instance of pydicom dataset
        &#34;&#34;&#34;

        # Generate a new filename
        path = os.path.join(self.path, &#34;Weasel&#34;)
        if not os.path.isdir(path): os.mkdir(path)
        file = os.path.join(path, pydicom.uid.generate_uid() + &#39;.dcm&#39;) 

        # Add a new row in the dataframe
        labels = self._columns + [&#39;checked&#39;,&#39;removed&#39;,&#39;created&#39;]
        row = pd.Series(data=[&#39;&#39;]*len(labels), index=labels, name=file)
        row[&#39;checked&#39;] = checked
        row[&#39;removed&#39;] = False
        row[&#39;created&#39;] = True
        self.__dict__[&#39;dataframe&#39;] = self.dataframe.append(row) # REPLACE BY CONCAT
        self._update(file, ds)

    def _update(self, file, ds):
        &#34;&#34;&#34;Update the values of a dataframe row.
        
        Args:
            file: filepath (or index) of the row to be updated
            ds: instance of a pydicom dataset.
        &#34;&#34;&#34;
        for tag in self._columns:
            if tag in ds:
                self.dataframe.loc[file, tag] = utilities._read_tags(ds, tag)
                #self.dataframe.loc[file, tag] = ds[tag].value

    def _multiframe_to_singleframe(self):
        &#34;&#34;&#34;Converts all multiframe files in the folder into single-frame files.
        
        Reads all the multi-frame files in the folder,
        converts them to singleframe files, and delete the original multiframe file.
        &#34;&#34;&#34;

        singleframe = self.dataframe.NumberOfFrames.isnull() 
        multiframe = singleframe == False
        nr_multiframe = multiframe.sum()
        if nr_multiframe != 0: 
            cnt=0
            for filepath, instance in self.dataframe[multiframe].iterrows():
                cnt+=1
                self.status.message(&#34;Converting multiframe file &#34; + filepath)
                self.status.progress(cnt, nr_multiframe)
                #
                # Create these in the Weasel folder, not in the original folder.
                #
                singleframe_files = utilities.split_multiframe(filepath, str(instance.SeriesInstanceUID))
                if singleframe_files != []:                    
                    # add the single frame files to the dataframe
                    df = utilities.dataframe(singleframe_files, self._columns)
                    df[&#39;checked&#39;] = [False] * df.shape[0]
                    df[&#39;removed&#39;] = [False] * df.shape[0]
                    df[&#39;created&#39;] = [False] * df.shape[0]
                    self.__dict__[&#39;dataframe&#39;] = pd.concat([self.dataframe, df])
                    # delete the original multiframe 
                    # CHANGE THIS - mark for removal but don&#39;t delete
                    # show enhanced DICOM in Tree but set the class to block display etc.
                    os.remove(filepath)
                    self.dataframe.drop(index=filepath, inplace=True)
                self.status.hide()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dbdicom.folder.Folder"><code class="flex name class">
<span>class <span class="ident">Folder</span></span>
<span>(</span><span>path=None, status=&lt;dbdicom.message.StatusBar object&gt;, dialog=&lt;dbdicom.message.Dialog object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Programming interface for reading and writing a DICOM folder.</p>
<p>Initialise the folder with a path and objects to message to the user.</p>
<p>When used inside a GUI, status and dialog should be instances of the status bar and
dialog class defined in <code>weasel</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Folder(Database):
    &#34;&#34;&#34;Programming interface for reading and writing a DICOM folder.&#34;&#34;&#34;

    
    _columns = [    # The column labels of the dataframe
        &#39;PatientID&#39;, &#39;StudyInstanceUID&#39;, &#39;SeriesInstanceUID&#39;, &#39;SOPInstanceUID&#39;, 
        &#39;SOPClassUID&#39;,&#39;NumberOfFrames&#39;, 
        &#39;PatientName&#39;, 
        &#39;StudyDescription&#39;, &#39;StudyDate&#39;, 
        &#39;SeriesDescription&#39;, &#39;SeriesNumber&#39;,
        &#39;InstanceNumber&#39;
    ]

    def __init__(self, path=None, status=StatusBar(), dialog=Dialog()):
        &#34;&#34;&#34;Initialise the folder with a path and objects to message to the user.
        
        When used inside a GUI, status and dialog should be instances of the status bar and 
        dialog class defined in `weasel`.
        &#34;&#34;&#34;
        self.__dict__[&#39;dataframe&#39;] = pd.DataFrame([]*len(self._columns), columns=self._columns)            
        self.__dict__[&#39;path&#39;] = path
        self.__dict__[&#39;status&#39;] = status
        self.__dict__[&#39;dialog&#39;] = dialog
        self.__dict__[&#39;dicm&#39;] = dicm

        super().__init__(self)

    def open(self, path=None):
        &#34;&#34;&#34;Opens a DICOM folder for read and write.
        
        Reads the contents of the folder and summarises all DICOM files
        in a dataframe for faster access next time. The dataframe is saved 
        as a csv file when the folder is closed with `folder.close()`. 
        All non-DICOM files in the folder are ignored.
        
        Args:
            path: The full path to the directory that is to be opened.

        Returns:
            The folder instance. This allows using the open() method in a 
            piping notation as in `inst = folder.open().instances()`.
        &#34;&#34;&#34;
        if path is not None: 
            self.__dict__[&#39;path&#39;] = path
        if self.path is None:
            message = &#34;please set a path before opening.&#34;
            message += &#34;\n Use folder.open(path_to_dicom_folder).&#34;
            self.dialog.information(message)
            return self
        if os.path.exists(self._csv):
            self.status.message(&#34;Reading..&#34;)
            self._read_csv()
            self.status.hide()
        else:
            self.scan()
        return self

    def scan(self):
        &#34;&#34;&#34;Reads the folder again.

        Use this function after opening the folder if the files on the folder 
        may have been corrputed or modified by another application.
        &#34;&#34;&#34;
        files = [item.path for item in utilities.scan_tree(self.path) if item.is_file()] 
        self.__dict__[&#39;dataframe&#39;] = utilities.dataframe(files, self._columns, self.status)
        self.dataframe[&#39;checked&#39;] = [False] * self.dataframe.shape[0]
        self.dataframe[&#39;removed&#39;] = [False] * self.dataframe.shape[0]
        self.dataframe[&#39;created&#39;] = [False] * self.dataframe.shape[0]
        self._multiframe_to_singleframe()
        return self

    def close(self):
        &#34;&#34;&#34;Close an open folder.
        
        This method checks if the changes have been saved and prompts the 
        user to save or restore them if not. The user also has the option 
        to cancel closing, in which case the function does nothing. 
        
        `close()` also resets the dataframe and path to default values.

        Returns: 
            True if the user has agreed to close the folder 
            (possible after save or restore) and False if the user 
            has cancelled the closing of the folder.
        &#34;&#34;&#34;
        if not self.is_open(): 
            return True
        if not self.is_saved():
            reply = self.dialog.question( 
                title = &#39;Closing DICOM folder&#39;, 
                message = &#39;Save changes before closing?&#39;,
                cancel = True, 
            )
            if reply == &#34;Cancel&#34;: 
                return False
            if reply == &#34;Yes&#34;:
                self.save()
            elif reply == &#34;No&#34;:
                self.restore()

        self._write_csv()
        self.__dict__[&#39;dataframe&#39;] = pd.DataFrame([]*len(self._columns), columns=self._columns)            
        self.__dict__[&#39;path&#39;] = None

        return True

    def is_saved(self):
        &#34;&#34;&#34;Check if the folder is saved.
        
        Returns: 
            True if the folder is saved and False otherwise.
        &#34;&#34;&#34;
        if self.dataframe.removed.any(): return False
        if self.dataframe.created.any(): return False
        return True

    def is_open(self):
        &#34;&#34;&#34;Check if the folder is currently open.
        
        Returns: 
            True if the folder is open and False otherwise.
        &#34;&#34;&#34;
        return self.path is not None

    def object(self, row, generation=4):
        &#34;&#34;&#34;Create a new dicom object from a row in the dataframe.
        
        Args:
            row: a row in the dataframe as a series
            generation: determines whether the object returned is 
                at level database (generation=0), patient (generation=1),
                study (generation=2), series (generation=3) 
                or instance (generation=4, default).
        Returns:
            An instance of one of the dicom classes defined in wedicom.classes.
        &#34;&#34;&#34;
        return dicm.object(self, row, generation)

    def instance(self, file):
        &#34;&#34;&#34;Create an instance from a filepath&#34;&#34;&#34;

        row = self.dataframe.loc[file]
        return self.object(row) 

    def print(self):
        &#34;&#34;&#34;Prints a summary of the project folder to the terminal.&#34;&#34;&#34;
        
        print(&#39; &#39;)
        print(&#39;---------- DICOM FOLDER --------------&#39;)
        print(&#39;FOLDER: &#39; + self.path)
        for i, patient in enumerate(self.children()):
            print(&#39; &#39;)
            print(&#39;    PATIENT [&#39; + str(i) + &#39;]: &#39; + patient.label())
            print(&#39; &#39;)
            for j, study in enumerate(patient.children()):
                print(&#39;        STUDY [&#39; + str(j) + &#39;]: &#39; + study.label())
                print(&#39; &#39;)
                for k, series in enumerate(study.children()):
                    print(&#39;            SERIES [&#39; + str(k) + &#39;]: &#39; + series.label())
                    print(&#39;                Nr of instances: &#39; + str(len(series.children()))) 

    def _write_csv(self):
        &#34;&#34;&#34; Writes the dataFrame as a .csv file&#34;&#34;&#34;
        file = self._csv
        self.dataframe.to_csv(file)

    def _read_csv(self):
        &#34;&#34;&#34;Reads the dataFrame from a .csv file &#34;&#34;&#34;  
        file = self._csv
        self.__dict__[&#39;dataframe&#39;] = pd.read_csv(file, index_col=0)

    @property
    def _csv(self):
        &#34;&#34;&#34; Returns the file path of the .csv file&#34;&#34;&#34;
        filename = os.path.basename(os.path.normpath(self.path)) + &#34;.csv&#34;
        return os.path.join(self.path, filename) 

    def _append(self, ds, checked=False):
        &#34;&#34;&#34;Append a new row to the dataframe from a pydicom dataset.
        
        Args:
            ds: and instance of pydicom dataset
        &#34;&#34;&#34;

        # Generate a new filename
        path = os.path.join(self.path, &#34;Weasel&#34;)
        if not os.path.isdir(path): os.mkdir(path)
        file = os.path.join(path, pydicom.uid.generate_uid() + &#39;.dcm&#39;) 

        # Add a new row in the dataframe
        labels = self._columns + [&#39;checked&#39;,&#39;removed&#39;,&#39;created&#39;]
        row = pd.Series(data=[&#39;&#39;]*len(labels), index=labels, name=file)
        row[&#39;checked&#39;] = checked
        row[&#39;removed&#39;] = False
        row[&#39;created&#39;] = True
        self.__dict__[&#39;dataframe&#39;] = self.dataframe.append(row) # REPLACE BY CONCAT
        self._update(file, ds)

    def _update(self, file, ds):
        &#34;&#34;&#34;Update the values of a dataframe row.
        
        Args:
            file: filepath (or index) of the row to be updated
            ds: instance of a pydicom dataset.
        &#34;&#34;&#34;
        for tag in self._columns:
            if tag in ds:
                self.dataframe.loc[file, tag] = utilities._read_tags(ds, tag)
                #self.dataframe.loc[file, tag] = ds[tag].value

    def _multiframe_to_singleframe(self):
        &#34;&#34;&#34;Converts all multiframe files in the folder into single-frame files.
        
        Reads all the multi-frame files in the folder,
        converts them to singleframe files, and delete the original multiframe file.
        &#34;&#34;&#34;

        singleframe = self.dataframe.NumberOfFrames.isnull() 
        multiframe = singleframe == False
        nr_multiframe = multiframe.sum()
        if nr_multiframe != 0: 
            cnt=0
            for filepath, instance in self.dataframe[multiframe].iterrows():
                cnt+=1
                self.status.message(&#34;Converting multiframe file &#34; + filepath)
                self.status.progress(cnt, nr_multiframe)
                #
                # Create these in the Weasel folder, not in the original folder.
                #
                singleframe_files = utilities.split_multiframe(filepath, str(instance.SeriesInstanceUID))
                if singleframe_files != []:                    
                    # add the single frame files to the dataframe
                    df = utilities.dataframe(singleframe_files, self._columns)
                    df[&#39;checked&#39;] = [False] * df.shape[0]
                    df[&#39;removed&#39;] = [False] * df.shape[0]
                    df[&#39;created&#39;] = [False] * df.shape[0]
                    self.__dict__[&#39;dataframe&#39;] = pd.concat([self.dataframe, df])
                    # delete the original multiframe 
                    # CHANGE THIS - mark for removal but don&#39;t delete
                    # show enhanced DICOM in Tree but set the class to block display etc.
                    os.remove(filepath)
                    self.dataframe.drop(index=filepath, inplace=True)
                self.status.hide()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dbdicom.classes.database.Database" href="classes/database.html#dbdicom.classes.database.Database">Database</a></li>
<li><a title="dbdicom.classes.record.Record" href="classes/record.html#dbdicom.classes.record.Record">Record</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="dbdicom.folder.Folder.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>self, path=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Opens a DICOM folder for read and write.</p>
<p>Reads the contents of the folder and summarises all DICOM files
in a dataframe for faster access next time. The dataframe is saved
as a csv file when the folder is closed with <code>folder.close()</code>.
All non-DICOM files in the folder are ignored.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>The full path to the directory that is to be opened.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The folder instance. This allows using the open() method in a
piping notation as in <code>inst = folder.open().instances()</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open(self, path=None):
    &#34;&#34;&#34;Opens a DICOM folder for read and write.
    
    Reads the contents of the folder and summarises all DICOM files
    in a dataframe for faster access next time. The dataframe is saved 
    as a csv file when the folder is closed with `folder.close()`. 
    All non-DICOM files in the folder are ignored.
    
    Args:
        path: The full path to the directory that is to be opened.

    Returns:
        The folder instance. This allows using the open() method in a 
        piping notation as in `inst = folder.open().instances()`.
    &#34;&#34;&#34;
    if path is not None: 
        self.__dict__[&#39;path&#39;] = path
    if self.path is None:
        message = &#34;please set a path before opening.&#34;
        message += &#34;\n Use folder.open(path_to_dicom_folder).&#34;
        self.dialog.information(message)
        return self
    if os.path.exists(self._csv):
        self.status.message(&#34;Reading..&#34;)
        self._read_csv()
        self.status.hide()
    else:
        self.scan()
    return self</code></pre>
</details>
</dd>
<dt id="dbdicom.folder.Folder.scan"><code class="name flex">
<span>def <span class="ident">scan</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads the folder again.</p>
<p>Use this function after opening the folder if the files on the folder
may have been corrputed or modified by another application.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scan(self):
    &#34;&#34;&#34;Reads the folder again.

    Use this function after opening the folder if the files on the folder 
    may have been corrputed or modified by another application.
    &#34;&#34;&#34;
    files = [item.path for item in utilities.scan_tree(self.path) if item.is_file()] 
    self.__dict__[&#39;dataframe&#39;] = utilities.dataframe(files, self._columns, self.status)
    self.dataframe[&#39;checked&#39;] = [False] * self.dataframe.shape[0]
    self.dataframe[&#39;removed&#39;] = [False] * self.dataframe.shape[0]
    self.dataframe[&#39;created&#39;] = [False] * self.dataframe.shape[0]
    self._multiframe_to_singleframe()
    return self</code></pre>
</details>
</dd>
<dt id="dbdicom.folder.Folder.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Close an open folder.</p>
<p>This method checks if the changes have been saved and prompts the
user to save or restore them if not. The user also has the option
to cancel closing, in which case the function does nothing. </p>
<p><code>close()</code> also resets the dataframe and path to default values.</p>
<p>Returns:
True if the user has agreed to close the folder
(possible after save or restore) and False if the user
has cancelled the closing of the folder.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    &#34;&#34;&#34;Close an open folder.
    
    This method checks if the changes have been saved and prompts the 
    user to save or restore them if not. The user also has the option 
    to cancel closing, in which case the function does nothing. 
    
    `close()` also resets the dataframe and path to default values.

    Returns: 
        True if the user has agreed to close the folder 
        (possible after save or restore) and False if the user 
        has cancelled the closing of the folder.
    &#34;&#34;&#34;
    if not self.is_open(): 
        return True
    if not self.is_saved():
        reply = self.dialog.question( 
            title = &#39;Closing DICOM folder&#39;, 
            message = &#39;Save changes before closing?&#39;,
            cancel = True, 
        )
        if reply == &#34;Cancel&#34;: 
            return False
        if reply == &#34;Yes&#34;:
            self.save()
        elif reply == &#34;No&#34;:
            self.restore()

    self._write_csv()
    self.__dict__[&#39;dataframe&#39;] = pd.DataFrame([]*len(self._columns), columns=self._columns)            
    self.__dict__[&#39;path&#39;] = None

    return True</code></pre>
</details>
</dd>
<dt id="dbdicom.folder.Folder.is_saved"><code class="name flex">
<span>def <span class="ident">is_saved</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the folder is saved.</p>
<p>Returns:
True if the folder is saved and False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_saved(self):
    &#34;&#34;&#34;Check if the folder is saved.
    
    Returns: 
        True if the folder is saved and False otherwise.
    &#34;&#34;&#34;
    if self.dataframe.removed.any(): return False
    if self.dataframe.created.any(): return False
    return True</code></pre>
</details>
</dd>
<dt id="dbdicom.folder.Folder.is_open"><code class="name flex">
<span>def <span class="ident">is_open</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the folder is currently open.</p>
<p>Returns:
True if the folder is open and False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_open(self):
    &#34;&#34;&#34;Check if the folder is currently open.
    
    Returns: 
        True if the folder is open and False otherwise.
    &#34;&#34;&#34;
    return self.path is not None</code></pre>
</details>
</dd>
<dt id="dbdicom.folder.Folder.object"><code class="name flex">
<span>def <span class="ident">object</span></span>(<span>self, row, generation=4)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new dicom object from a row in the dataframe.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>row</code></strong></dt>
<dd>a row in the dataframe as a series</dd>
<dt><strong><code>generation</code></strong></dt>
<dd>determines whether the object returned is
at level database (generation=0), patient (generation=1),
study (generation=2), series (generation=3)
or instance (generation=4, default).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>An instance of one of the dicom classes defined in wedicom.classes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object(self, row, generation=4):
    &#34;&#34;&#34;Create a new dicom object from a row in the dataframe.
    
    Args:
        row: a row in the dataframe as a series
        generation: determines whether the object returned is 
            at level database (generation=0), patient (generation=1),
            study (generation=2), series (generation=3) 
            or instance (generation=4, default).
    Returns:
        An instance of one of the dicom classes defined in wedicom.classes.
    &#34;&#34;&#34;
    return dicm.object(self, row, generation)</code></pre>
</details>
</dd>
<dt id="dbdicom.folder.Folder.instance"><code class="name flex">
<span>def <span class="ident">instance</span></span>(<span>self, file)</span>
</code></dt>
<dd>
<div class="desc"><p>Create an instance from a filepath</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def instance(self, file):
    &#34;&#34;&#34;Create an instance from a filepath&#34;&#34;&#34;

    row = self.dataframe.loc[file]
    return self.object(row) </code></pre>
</details>
</dd>
<dt id="dbdicom.folder.Folder.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints a summary of the project folder to the terminal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print(self):
    &#34;&#34;&#34;Prints a summary of the project folder to the terminal.&#34;&#34;&#34;
    
    print(&#39; &#39;)
    print(&#39;---------- DICOM FOLDER --------------&#39;)
    print(&#39;FOLDER: &#39; + self.path)
    for i, patient in enumerate(self.children()):
        print(&#39; &#39;)
        print(&#39;    PATIENT [&#39; + str(i) + &#39;]: &#39; + patient.label())
        print(&#39; &#39;)
        for j, study in enumerate(patient.children()):
            print(&#39;        STUDY [&#39; + str(j) + &#39;]: &#39; + study.label())
            print(&#39; &#39;)
            for k, series in enumerate(study.children()):
                print(&#39;            SERIES [&#39; + str(k) + &#39;]: &#39; + series.label())
                print(&#39;                Nr of instances: &#39; + str(len(series.children()))) </code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="dbdicom.classes.database.Database" href="classes/database.html#dbdicom.classes.database.Database">Database</a></b></code>:
<ul class="hlist">
<li><code><a title="dbdicom.classes.database.Database.array" href="classes/record.html#dbdicom.classes.record.Record.array">array</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.check" href="classes/record.html#dbdicom.classes.record.Record.check">check</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.children" href="classes/record.html#dbdicom.classes.record.Record.children">children</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.copy" href="classes/record.html#dbdicom.classes.record.Record.copy">copy</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.copy_to" href="classes/record.html#dbdicom.classes.record.Record.copy_to">copy_to</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.data" href="classes/record.html#dbdicom.classes.record.Record.data">data</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.dataset" href="classes/record.html#dbdicom.classes.record.Record.dataset">dataset</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.export" href="classes/record.html#dbdicom.classes.record.Record.export">export</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.files" href="classes/record.html#dbdicom.classes.record.Record.files">files</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.in_memory" href="classes/record.html#dbdicom.classes.record.Record.in_memory">in_memory</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.instances" href="classes/record.html#dbdicom.classes.record.Record.instances">instances</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.is_checked" href="classes/record.html#dbdicom.classes.record.Record.is_checked">is_checked</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.key" href="classes/record.html#dbdicom.classes.record.Record.key">key</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.move" href="classes/record.html#dbdicom.classes.record.Record.move">move</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.move_to" href="classes/record.html#dbdicom.classes.record.Record.move_to">move_to</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.new_child" href="classes/record.html#dbdicom.classes.record.Record.new_child">new_child</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.new_pibling" href="classes/record.html#dbdicom.classes.record.Record.new_pibling">new_pibling</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.new_series" href="classes/record.html#dbdicom.classes.record.Record.new_series">new_series</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.new_sibling" href="classes/record.html#dbdicom.classes.record.Record.new_sibling">new_sibling</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.parent" href="classes/record.html#dbdicom.classes.record.Record.parent">parent</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.patients" href="classes/record.html#dbdicom.classes.record.Record.patients">patients</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.records" href="classes/record.html#dbdicom.classes.record.Record.records">records</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.remove" href="classes/record.html#dbdicom.classes.record.Record.remove">remove</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.restore" href="classes/record.html#dbdicom.classes.record.Record.restore">restore</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.save" href="classes/record.html#dbdicom.classes.record.Record.save">save</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.series" href="classes/record.html#dbdicom.classes.record.Record.series">series</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.set_array" href="classes/record.html#dbdicom.classes.record.Record.set_array">set_array</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.set_checked" href="classes/record.html#dbdicom.classes.record.Record.set_checked">set_checked</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.studies" href="classes/record.html#dbdicom.classes.record.Record.studies">studies</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.uncheck" href="classes/record.html#dbdicom.classes.record.Record.uncheck">uncheck</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dbdicom" href="index.html">dbdicom</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dbdicom.folder.Folder" href="#dbdicom.folder.Folder">Folder</a></code></h4>
<ul class="two-column">
<li><code><a title="dbdicom.folder.Folder.open" href="#dbdicom.folder.Folder.open">open</a></code></li>
<li><code><a title="dbdicom.folder.Folder.scan" href="#dbdicom.folder.Folder.scan">scan</a></code></li>
<li><code><a title="dbdicom.folder.Folder.close" href="#dbdicom.folder.Folder.close">close</a></code></li>
<li><code><a title="dbdicom.folder.Folder.is_saved" href="#dbdicom.folder.Folder.is_saved">is_saved</a></code></li>
<li><code><a title="dbdicom.folder.Folder.is_open" href="#dbdicom.folder.Folder.is_open">is_open</a></code></li>
<li><code><a title="dbdicom.folder.Folder.object" href="#dbdicom.folder.Folder.object">object</a></code></li>
<li><code><a title="dbdicom.folder.Folder.instance" href="#dbdicom.folder.Folder.instance">instance</a></code></li>
<li><code><a title="dbdicom.folder.Folder.print" href="#dbdicom.folder.Folder.print">print</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>