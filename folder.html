<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>dbdicom.folder API documentation</title>
<meta name="description" content="Defines the central `Folder` class for reading and writing to DICOM folders â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dbdicom.folder</code></h1>
</header>
<section id="section-intro">
<p>Defines the central <code><a title="dbdicom.folder.Folder" href="#dbdicom.folder.Folder">Folder</a></code> class for reading and writing to DICOM folders.</p>
<p><code><a title="dbdicom.folder.Folder" href="#dbdicom.folder.Folder">Folder</a></code> is the central class of <code><a title="dbdicom" href="index.html">dbdicom</a></code> and the first point of call
for opening, closing and manipulating a folder with DICOM files. </p>
<pre><code># Example: Get a 3D numpy array from the first series in a folder.

from dbdicom import Folder

folder = Folder('C:\Users\MyName\MyData\DICOMtestData')
array = folder.open().series(0).array()
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Defines the central `Folder` class for reading and writing to DICOM folders.

`Folder()` is the central class of `dbdicom` and the first point of call 
for opening, closing and manipulating a folder with DICOM files. 

    # Example: Get a 3D numpy array from the first series in a folder.

    from dbdicom import Folder

    folder = Folder(&#39;C:\\Users\\MyName\\MyData\\DICOMtestData&#39;)
    array = folder.open().series(0).array()
&#34;&#34;&#34;

__all__ = [&#39;Folder&#39;]

import os
import pydicom
import pandas as pd

#from dbdicom import dicm, utilities
from . import dicm, utilities
from .message import StatusBar, Dialog
from .classes.database import Database

class Folder(Database): 
    # This really needs to be Database() with Folder as an attribute. 
    &#34;&#34;&#34;Programming interface for reading and writing a DICOM folder.&#34;&#34;&#34;

    # The column labels of the dataframe as required by dbdicom
    required = [    
        &#39;PatientID&#39;, &#39;StudyInstanceUID&#39;, &#39;SeriesInstanceUID&#39;, &#39;SOPInstanceUID&#39;, 
        &#39;SOPClassUID&#39;,&#39;NumberOfFrames&#39;, 
        &#39;PatientName&#39;, 
        &#39;StudyDescription&#39;, &#39;StudyDate&#39;, 
        &#39;SeriesDescription&#39;, &#39;SeriesNumber&#39;,
        &#39;InstanceNumber&#39;, &#39;AcquisitionTime&#39;, 
    ]

    def __init__(self, path=None, attributes=None, message=&#39;Opening folder..&#39;, status=StatusBar(), dialog=Dialog()):
        &#34;&#34;&#34;Initialise the folder with a path and objects to message to the user.
        
        When used inside a GUI, status and dialog should be instances of the status bar and 
        dialog class defined in `weasel`.
        &#34;&#34;&#34;
        # A list of optional dicom attributes that are not used by dbdicom 
        # but can be included for faster access in other applications. 
        # The list can be changed or extended by applications.
        self.__dict__[&#39;attributes&#39;] = [&#39;SliceLocation&#39;]
        self.__dict__[&#39;dataframe&#39;] = pd.DataFrame([]*len(self._columns), columns=self._columns)            
        self.__dict__[&#39;path&#39;] = path
        self.__dict__[&#39;status&#39;] = status
        self.__dict__[&#39;dialog&#39;] = dialog
        self.__dict__[&#39;dicm&#39;] = dicm

        # These are anomalies - folder should not inherit DataBase
        self.__dict__[&#39;UID&#39;] = []       
        self.__dict__[&#39;folder&#39;] = self
        self.__dict__[&#39;ds&#39;] = None

        self.set_attributes(attributes, scan=False)
        self.open(message=message)


    @property
    def _columns(self):

        return self.required + self.__dict__[&#39;attributes&#39;]

    def set_attributes(self, attributes, scan=True):
        &#34;&#34;&#34;DICOM attributes that are NOT used by dbdicom.
        
        Can be set by applications for fast access to key DICOM attributes such
        as those used for sorting series data.

        Args:
            attributes: list of DICOM attributes.
        &#34;&#34;&#34;
        if attributes is None:
            return
        # Make sure all columns are unique
        attr = []
        for a in attributes:
            if a not in self.required:
                attr.append(a)
        self.__dict__[&#39;attributes&#39;] = attr
        if scan: self.scan()

    def open(self, path=None, message=&#39;Opening folder..&#39;, unzip=False):
        &#34;&#34;&#34;Opens a DICOM folder for read and write.
        
        Reads the contents of the folder and summarises all DICOM files
        in a dataframe for faster access next time. The dataframe is saved 
        as a csv file when the folder is closed with `folder.close()`. 
        All non-DICOM files in the folder are ignored.
        
        Args:
            path: The full path to the directory that is to be opened.

        Returns:
            The folder instance. This allows using the open() method in a 
            piping notation as in `inst = folder.open().instances()`.
        &#34;&#34;&#34;
        if path is not None: 
            self.__dict__[&#39;path&#39;] = path
        if self.path is None:
            message = &#34;please set a path before opening.&#34;
            message += &#34;\n Use folder.open(path_to_dicom_folder).&#34;
            self.dialog.information(message)
            return self
        if os.path.exists(self._csv):
            self.status.message(&#34;Reading register..&#34;)
            self._read_csv()
            # If the saved register does not have all required attributes
            # then scan the folder again and create a new register
            labels = self._columns + [&#39;removed&#39;,&#39;created&#39;]
            if labels != list(self.dataframe.columns):
#            for attribute in self.__dict__[&#39;attributes&#39;]:
#                if attribute not in self.dataframe:
                self.scan(message=message)
                self.status.hide()
                return self
            self.status.hide()
        else:
            self.scan(message=message, unzip=unzip)
        return self

    def scan(self, message=&#39;Scanning..&#39;, unzip=False):
        &#34;&#34;&#34;
        Reads all files in the folder and summarises key attributes in a table for faster access.
        &#34;&#34;&#34;
        if unzip:
            self.status.message(&#39;Extracting compressed folders..&#39;)
            utilities._unzip_files(self.path, self.status)
        self.status.message(&#39;Finding all files..&#39;)
        files = [item.path for item in utilities.scan_tree(self.path) if item.is_file()]
        self.__dict__[&#39;dataframe&#39;] = utilities.dataframe(self.path, files, self._columns, self.status, message=message)
        self.dataframe[&#39;removed&#39;] = [False] * self.dataframe.shape[0]
        self.dataframe[&#39;created&#39;] = [False] * self.dataframe.shape[0]
        self._multiframe_to_singleframe()
        self._write_csv()
        return self

    def close(self):
        &#34;&#34;&#34;Close an open folder.
        
        This method checks if the changes have been saved and prompts the 
        user to save or restore them if not. The user also has the option 
        to cancel closing, in which case the function does nothing. 
        
        `close()` also resets the dataframe and path to default values.

        Returns: 
            True if the user has agreed to close the folder 
            (possible after save or restore) and False if the user 
            has cancelled the closing of the folder.
        &#34;&#34;&#34;
        if not self.is_open(): 
            return True
        if not self.is_saved():
            reply = self.dialog.question( 
                title = &#39;Closing DICOM folder&#39;, 
                message = &#39;Save changes before closing?&#39;,
                cancel = True, 
            )
            if reply == &#34;Cancel&#34;: 
                return False
            if reply == &#34;Yes&#34;:
                self.save()
            elif reply == &#34;No&#34;:
                self.restore()

        self._write_csv()
        self.__dict__[&#39;dataframe&#39;] = pd.DataFrame([]*len(self._columns), columns=self._columns)            
        self.__dict__[&#39;path&#39;] = None

        return True

    def save(self):

        self.status.message(&#34;Saving..&#34;)
        if self.is_saved():
            self._write_csv()
        else:
            super().save()
        self.status.hide()

    def is_saved(self):
        &#34;&#34;&#34;Check if the folder is saved.
        
        Returns: 
            True if the folder is saved and False otherwise.
        &#34;&#34;&#34;
        if self.dataframe.removed.any(): return False
        if self.dataframe.created.any(): return False
        return True

    def is_open(self):
        &#34;&#34;&#34;Check if the folder is currently open.
        
        Returns: 
            True if the folder is open and False otherwise.
        &#34;&#34;&#34;
        return self.path is not None

    def sortby(self, sortby):
        
        self.dataframe.sort_values(sortby, inplace=True)
        return self

    def object(self, row, generation=4):
        &#34;&#34;&#34;Create a new dicom object from a row in the dataframe.
        
        Args:
            row: a row in the dataframe as a series
            generation: determines whether the object returned is 
                at level database (generation=0), patient (generation=1),
                study (generation=2), series (generation=3) 
                or instance (generation=4, default).
        Returns:
            An instance of one of the dicom classes defined in wedicom.classes.
        &#34;&#34;&#34;
        return dicm.object(self, row, generation)

    def instance(self, file):
        &#34;&#34;&#34;Create an instance from a filepath&#34;&#34;&#34;

        row = self.dataframe.loc[file]
        return self.object(row) 

    def print(self):
        &#34;&#34;&#34;Prints a summary of the project folder to the terminal.&#34;&#34;&#34;
        
        print(&#39; &#39;)
        print(&#39;---------- DICOM FOLDER --------------&#39;)
        print(&#39;FOLDER: &#39; + self.path)
        for i, patient in enumerate(self.children()):
            print(&#39; &#39;)
            print(&#39;    PATIENT [&#39; + str(i) + &#39;]: &#39; + patient.label())
            print(&#39; &#39;)
            for j, study in enumerate(patient.children()):
                print(&#39;        STUDY [&#39; + str(j) + &#39;]: &#39; + study.label())
                print(&#39; &#39;)
                for k, series in enumerate(study.children()):
                    print(&#39;            SERIES [&#39; + str(k) + &#39;]: &#39; + series.label())
                    print(&#39;                Nr of instances: &#39; + str(len(series.children()))) 

    def _write_csv(self):
        &#34;&#34;&#34; Writes the dataFrame as a .csv file&#34;&#34;&#34;
        file = self._csv
        self.dataframe.to_csv(file)

    def _read_csv(self):
        &#34;&#34;&#34;Reads the dataFrame from a .csv file &#34;&#34;&#34;  
        file = self._csv
        self.__dict__[&#39;dataframe&#39;] = pd.read_csv(file, index_col=0)

    @property
    def _csv(self):
        &#34;&#34;&#34; Returns the file path of the .csv file&#34;&#34;&#34;
        filename = os.path.basename(os.path.normpath(self.path)) + &#34;.csv&#34;
        return os.path.join(self.path, filename) 

    def label(self, row, type):

        if type == &#39;Patient&#39;:
            name = row.PatientName
            id = row.PatientID
            label = str(name)
            label += &#39; [&#39; + str(id) + &#39;]&#39;
            return type + &#34; - {}&#34;.format(label)
        if type == &#39;Study&#39;:
            descr = row.StudyDescription
            date = row.StudyDate
            label = str(descr)
            label += &#39; [&#39; + str(date) + &#39;]&#39;
            return type + &#34; - {}&#34;.format(label)
        if type == &#39;Series&#39;:
            descr = row.SeriesDescription
            nr = row.SeriesNumber
            label = &#39;[&#39; + str(nr).zfill(3) + &#39;] &#39; 
            label += str(descr)
            return type + &#34; - {}&#34;.format(label)
        if type == &#39;Instance&#39;:
            nr = row.InstanceNumber
            label = str(nr).zfill(6)
            return type + &#34; - {}&#34;.format(label)

    def new_uid(self, n=1):
        
        if n == 1:
            return pydicom.uid.generate_uid()
        uid = []
        for _ in range(n):
            uid.append(pydicom.uid.generate_uid())
        return uid

    def new_file(self):

        # Generate a new filename
        path = os.path.join(self.path, &#34;dbdicom&#34;)
        if not os.path.isdir(path): os.mkdir(path)
        #file = os.path.join(path, self.new_uid() + &#39;.dcm&#39;) 
        file = os.path.join(&#34;dbdicom&#34;, self.new_uid() + &#39;.dcm&#39;) 
        return file

    def _append(self, ds):
        &#34;&#34;&#34;Append a new row to the dataframe from a pydicom dataset.
        
        Args:
            ds: and instance of pydicom dataset
        &#34;&#34;&#34;

        # Generate a new filename
        file = self.new_file()
#        path = os.path.join(self.path, &#34;Weasel&#34;)
#        if not os.path.isdir(path): os.mkdir(path)
#        file = os.path.join(path, pydicom.uid.generate_uid() + &#39;.dcm&#39;) 

        row = pd.DataFrame([]*len(self._columns), index=[file], columns=self._columns)
        row[&#39;removed&#39;] = False
        row[&#39;created&#39;] = True
        self.__dict__[&#39;dataframe&#39;] = pd.concat([self.dataframe, row]) 
        
        # REPLACED BY CONCAT on 03 june 2022
        # labels = self._columns + [&#39;removed&#39;,&#39;created&#39;]
        #row = pd.Series(data=[&#39;&#39;]*len(labels), index=labels, name=file)
        #row[&#39;removed&#39;] = False
        #row[&#39;created&#39;] = True
        #self.__dict__[&#39;dataframe&#39;] = self.dataframe.append(row) # REPLACE BY CONCAT

        self._update(file, ds)

    def _update(self, file, ds):
        &#34;&#34;&#34;Update the values of a dataframe row.
        
        Args:
            file: filepath (or index) of the row to be updated
            ds: instance of a pydicom dataset.
        &#34;&#34;&#34;
        for tag in self._columns:
            if tag in ds:
                value = utilities._read_tags(ds, tag)
                self.dataframe.loc[file, tag] = value
                #self.dataframe.loc[file, tag] = ds[tag].value

    def _multiframe_to_singleframe(self):
        &#34;&#34;&#34;Converts all multiframe files in the folder into single-frame files.
        
        Reads all the multi-frame files in the folder,
        converts them to singleframe files, and delete the original multiframe file.
        &#34;&#34;&#34;

        singleframe = self.dataframe.NumberOfFrames.isnull() 
        multiframe = singleframe == False
        nr_multiframe = multiframe.sum()
        if nr_multiframe != 0: 
            cnt=0
            for filepath, instance in self.dataframe[multiframe].iterrows():
                cnt+=1
                self.status.message(&#34;Converting multiframe file &#34; + filepath)
                self.status.progress(cnt, nr_multiframe)
                #
                # Create these in the Weasel folder, not in the original folder.
                #
                singleframe_files = utilities.split_multiframe(filepath, str(instance.SeriesInstanceUID))
                if singleframe_files != []:                    
                    # add the single frame files to the dataframe
                    df = utilities.dataframe(self.path, singleframe_files, self._columns)
                    df[&#39;removed&#39;] = [False] * df.shape[0]
                    df[&#39;created&#39;] = [False] * df.shape[0]
                    self.__dict__[&#39;dataframe&#39;] = pd.concat([self.dataframe, df])
                    # delete the original multiframe 
                    # CHANGE THIS - mark for removal but don&#39;t delete
                    # show enhanced DICOM in Tree but set the class to block display etc.
                    os.remove(filepath)
                    self.dataframe.drop(index=filepath, inplace=True)
                self.status.hide()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dbdicom.folder.Folder"><code class="flex name class">
<span>class <span class="ident">Folder</span></span>
<span>(</span><span>path=None, attributes=None, message='Opening folder..', status=&lt;dbdicom.message.StatusBar object&gt;, dialog=&lt;dbdicom.message.Dialog object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Programming interface for reading and writing a DICOM folder.</p>
<p>Initialise the folder with a path and objects to message to the user.</p>
<p>When used inside a GUI, status and dialog should be instances of the status bar and
dialog class defined in <code>weasel</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Folder(Database): 
    # This really needs to be Database() with Folder as an attribute. 
    &#34;&#34;&#34;Programming interface for reading and writing a DICOM folder.&#34;&#34;&#34;

    # The column labels of the dataframe as required by dbdicom
    required = [    
        &#39;PatientID&#39;, &#39;StudyInstanceUID&#39;, &#39;SeriesInstanceUID&#39;, &#39;SOPInstanceUID&#39;, 
        &#39;SOPClassUID&#39;,&#39;NumberOfFrames&#39;, 
        &#39;PatientName&#39;, 
        &#39;StudyDescription&#39;, &#39;StudyDate&#39;, 
        &#39;SeriesDescription&#39;, &#39;SeriesNumber&#39;,
        &#39;InstanceNumber&#39;, &#39;AcquisitionTime&#39;, 
    ]

    def __init__(self, path=None, attributes=None, message=&#39;Opening folder..&#39;, status=StatusBar(), dialog=Dialog()):
        &#34;&#34;&#34;Initialise the folder with a path and objects to message to the user.
        
        When used inside a GUI, status and dialog should be instances of the status bar and 
        dialog class defined in `weasel`.
        &#34;&#34;&#34;
        # A list of optional dicom attributes that are not used by dbdicom 
        # but can be included for faster access in other applications. 
        # The list can be changed or extended by applications.
        self.__dict__[&#39;attributes&#39;] = [&#39;SliceLocation&#39;]
        self.__dict__[&#39;dataframe&#39;] = pd.DataFrame([]*len(self._columns), columns=self._columns)            
        self.__dict__[&#39;path&#39;] = path
        self.__dict__[&#39;status&#39;] = status
        self.__dict__[&#39;dialog&#39;] = dialog
        self.__dict__[&#39;dicm&#39;] = dicm

        # These are anomalies - folder should not inherit DataBase
        self.__dict__[&#39;UID&#39;] = []       
        self.__dict__[&#39;folder&#39;] = self
        self.__dict__[&#39;ds&#39;] = None

        self.set_attributes(attributes, scan=False)
        self.open(message=message)


    @property
    def _columns(self):

        return self.required + self.__dict__[&#39;attributes&#39;]

    def set_attributes(self, attributes, scan=True):
        &#34;&#34;&#34;DICOM attributes that are NOT used by dbdicom.
        
        Can be set by applications for fast access to key DICOM attributes such
        as those used for sorting series data.

        Args:
            attributes: list of DICOM attributes.
        &#34;&#34;&#34;
        if attributes is None:
            return
        # Make sure all columns are unique
        attr = []
        for a in attributes:
            if a not in self.required:
                attr.append(a)
        self.__dict__[&#39;attributes&#39;] = attr
        if scan: self.scan()

    def open(self, path=None, message=&#39;Opening folder..&#39;, unzip=False):
        &#34;&#34;&#34;Opens a DICOM folder for read and write.
        
        Reads the contents of the folder and summarises all DICOM files
        in a dataframe for faster access next time. The dataframe is saved 
        as a csv file when the folder is closed with `folder.close()`. 
        All non-DICOM files in the folder are ignored.
        
        Args:
            path: The full path to the directory that is to be opened.

        Returns:
            The folder instance. This allows using the open() method in a 
            piping notation as in `inst = folder.open().instances()`.
        &#34;&#34;&#34;
        if path is not None: 
            self.__dict__[&#39;path&#39;] = path
        if self.path is None:
            message = &#34;please set a path before opening.&#34;
            message += &#34;\n Use folder.open(path_to_dicom_folder).&#34;
            self.dialog.information(message)
            return self
        if os.path.exists(self._csv):
            self.status.message(&#34;Reading register..&#34;)
            self._read_csv()
            # If the saved register does not have all required attributes
            # then scan the folder again and create a new register
            labels = self._columns + [&#39;removed&#39;,&#39;created&#39;]
            if labels != list(self.dataframe.columns):
#            for attribute in self.__dict__[&#39;attributes&#39;]:
#                if attribute not in self.dataframe:
                self.scan(message=message)
                self.status.hide()
                return self
            self.status.hide()
        else:
            self.scan(message=message, unzip=unzip)
        return self

    def scan(self, message=&#39;Scanning..&#39;, unzip=False):
        &#34;&#34;&#34;
        Reads all files in the folder and summarises key attributes in a table for faster access.
        &#34;&#34;&#34;
        if unzip:
            self.status.message(&#39;Extracting compressed folders..&#39;)
            utilities._unzip_files(self.path, self.status)
        self.status.message(&#39;Finding all files..&#39;)
        files = [item.path for item in utilities.scan_tree(self.path) if item.is_file()]
        self.__dict__[&#39;dataframe&#39;] = utilities.dataframe(self.path, files, self._columns, self.status, message=message)
        self.dataframe[&#39;removed&#39;] = [False] * self.dataframe.shape[0]
        self.dataframe[&#39;created&#39;] = [False] * self.dataframe.shape[0]
        self._multiframe_to_singleframe()
        self._write_csv()
        return self

    def close(self):
        &#34;&#34;&#34;Close an open folder.
        
        This method checks if the changes have been saved and prompts the 
        user to save or restore them if not. The user also has the option 
        to cancel closing, in which case the function does nothing. 
        
        `close()` also resets the dataframe and path to default values.

        Returns: 
            True if the user has agreed to close the folder 
            (possible after save or restore) and False if the user 
            has cancelled the closing of the folder.
        &#34;&#34;&#34;
        if not self.is_open(): 
            return True
        if not self.is_saved():
            reply = self.dialog.question( 
                title = &#39;Closing DICOM folder&#39;, 
                message = &#39;Save changes before closing?&#39;,
                cancel = True, 
            )
            if reply == &#34;Cancel&#34;: 
                return False
            if reply == &#34;Yes&#34;:
                self.save()
            elif reply == &#34;No&#34;:
                self.restore()

        self._write_csv()
        self.__dict__[&#39;dataframe&#39;] = pd.DataFrame([]*len(self._columns), columns=self._columns)            
        self.__dict__[&#39;path&#39;] = None

        return True

    def save(self):

        self.status.message(&#34;Saving..&#34;)
        if self.is_saved():
            self._write_csv()
        else:
            super().save()
        self.status.hide()

    def is_saved(self):
        &#34;&#34;&#34;Check if the folder is saved.
        
        Returns: 
            True if the folder is saved and False otherwise.
        &#34;&#34;&#34;
        if self.dataframe.removed.any(): return False
        if self.dataframe.created.any(): return False
        return True

    def is_open(self):
        &#34;&#34;&#34;Check if the folder is currently open.
        
        Returns: 
            True if the folder is open and False otherwise.
        &#34;&#34;&#34;
        return self.path is not None

    def sortby(self, sortby):
        
        self.dataframe.sort_values(sortby, inplace=True)
        return self

    def object(self, row, generation=4):
        &#34;&#34;&#34;Create a new dicom object from a row in the dataframe.
        
        Args:
            row: a row in the dataframe as a series
            generation: determines whether the object returned is 
                at level database (generation=0), patient (generation=1),
                study (generation=2), series (generation=3) 
                or instance (generation=4, default).
        Returns:
            An instance of one of the dicom classes defined in wedicom.classes.
        &#34;&#34;&#34;
        return dicm.object(self, row, generation)

    def instance(self, file):
        &#34;&#34;&#34;Create an instance from a filepath&#34;&#34;&#34;

        row = self.dataframe.loc[file]
        return self.object(row) 

    def print(self):
        &#34;&#34;&#34;Prints a summary of the project folder to the terminal.&#34;&#34;&#34;
        
        print(&#39; &#39;)
        print(&#39;---------- DICOM FOLDER --------------&#39;)
        print(&#39;FOLDER: &#39; + self.path)
        for i, patient in enumerate(self.children()):
            print(&#39; &#39;)
            print(&#39;    PATIENT [&#39; + str(i) + &#39;]: &#39; + patient.label())
            print(&#39; &#39;)
            for j, study in enumerate(patient.children()):
                print(&#39;        STUDY [&#39; + str(j) + &#39;]: &#39; + study.label())
                print(&#39; &#39;)
                for k, series in enumerate(study.children()):
                    print(&#39;            SERIES [&#39; + str(k) + &#39;]: &#39; + series.label())
                    print(&#39;                Nr of instances: &#39; + str(len(series.children()))) 

    def _write_csv(self):
        &#34;&#34;&#34; Writes the dataFrame as a .csv file&#34;&#34;&#34;
        file = self._csv
        self.dataframe.to_csv(file)

    def _read_csv(self):
        &#34;&#34;&#34;Reads the dataFrame from a .csv file &#34;&#34;&#34;  
        file = self._csv
        self.__dict__[&#39;dataframe&#39;] = pd.read_csv(file, index_col=0)

    @property
    def _csv(self):
        &#34;&#34;&#34; Returns the file path of the .csv file&#34;&#34;&#34;
        filename = os.path.basename(os.path.normpath(self.path)) + &#34;.csv&#34;
        return os.path.join(self.path, filename) 

    def label(self, row, type):

        if type == &#39;Patient&#39;:
            name = row.PatientName
            id = row.PatientID
            label = str(name)
            label += &#39; [&#39; + str(id) + &#39;]&#39;
            return type + &#34; - {}&#34;.format(label)
        if type == &#39;Study&#39;:
            descr = row.StudyDescription
            date = row.StudyDate
            label = str(descr)
            label += &#39; [&#39; + str(date) + &#39;]&#39;
            return type + &#34; - {}&#34;.format(label)
        if type == &#39;Series&#39;:
            descr = row.SeriesDescription
            nr = row.SeriesNumber
            label = &#39;[&#39; + str(nr).zfill(3) + &#39;] &#39; 
            label += str(descr)
            return type + &#34; - {}&#34;.format(label)
        if type == &#39;Instance&#39;:
            nr = row.InstanceNumber
            label = str(nr).zfill(6)
            return type + &#34; - {}&#34;.format(label)

    def new_uid(self, n=1):
        
        if n == 1:
            return pydicom.uid.generate_uid()
        uid = []
        for _ in range(n):
            uid.append(pydicom.uid.generate_uid())
        return uid

    def new_file(self):

        # Generate a new filename
        path = os.path.join(self.path, &#34;dbdicom&#34;)
        if not os.path.isdir(path): os.mkdir(path)
        #file = os.path.join(path, self.new_uid() + &#39;.dcm&#39;) 
        file = os.path.join(&#34;dbdicom&#34;, self.new_uid() + &#39;.dcm&#39;) 
        return file

    def _append(self, ds):
        &#34;&#34;&#34;Append a new row to the dataframe from a pydicom dataset.
        
        Args:
            ds: and instance of pydicom dataset
        &#34;&#34;&#34;

        # Generate a new filename
        file = self.new_file()
#        path = os.path.join(self.path, &#34;Weasel&#34;)
#        if not os.path.isdir(path): os.mkdir(path)
#        file = os.path.join(path, pydicom.uid.generate_uid() + &#39;.dcm&#39;) 

        row = pd.DataFrame([]*len(self._columns), index=[file], columns=self._columns)
        row[&#39;removed&#39;] = False
        row[&#39;created&#39;] = True
        self.__dict__[&#39;dataframe&#39;] = pd.concat([self.dataframe, row]) 
        
        # REPLACED BY CONCAT on 03 june 2022
        # labels = self._columns + [&#39;removed&#39;,&#39;created&#39;]
        #row = pd.Series(data=[&#39;&#39;]*len(labels), index=labels, name=file)
        #row[&#39;removed&#39;] = False
        #row[&#39;created&#39;] = True
        #self.__dict__[&#39;dataframe&#39;] = self.dataframe.append(row) # REPLACE BY CONCAT

        self._update(file, ds)

    def _update(self, file, ds):
        &#34;&#34;&#34;Update the values of a dataframe row.
        
        Args:
            file: filepath (or index) of the row to be updated
            ds: instance of a pydicom dataset.
        &#34;&#34;&#34;
        for tag in self._columns:
            if tag in ds:
                value = utilities._read_tags(ds, tag)
                self.dataframe.loc[file, tag] = value
                #self.dataframe.loc[file, tag] = ds[tag].value

    def _multiframe_to_singleframe(self):
        &#34;&#34;&#34;Converts all multiframe files in the folder into single-frame files.
        
        Reads all the multi-frame files in the folder,
        converts them to singleframe files, and delete the original multiframe file.
        &#34;&#34;&#34;

        singleframe = self.dataframe.NumberOfFrames.isnull() 
        multiframe = singleframe == False
        nr_multiframe = multiframe.sum()
        if nr_multiframe != 0: 
            cnt=0
            for filepath, instance in self.dataframe[multiframe].iterrows():
                cnt+=1
                self.status.message(&#34;Converting multiframe file &#34; + filepath)
                self.status.progress(cnt, nr_multiframe)
                #
                # Create these in the Weasel folder, not in the original folder.
                #
                singleframe_files = utilities.split_multiframe(filepath, str(instance.SeriesInstanceUID))
                if singleframe_files != []:                    
                    # add the single frame files to the dataframe
                    df = utilities.dataframe(self.path, singleframe_files, self._columns)
                    df[&#39;removed&#39;] = [False] * df.shape[0]
                    df[&#39;created&#39;] = [False] * df.shape[0]
                    self.__dict__[&#39;dataframe&#39;] = pd.concat([self.dataframe, df])
                    # delete the original multiframe 
                    # CHANGE THIS - mark for removal but don&#39;t delete
                    # show enhanced DICOM in Tree but set the class to block display etc.
                    os.remove(filepath)
                    self.dataframe.drop(index=filepath, inplace=True)
                self.status.hide()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dbdicom.classes.database.Database" href="classes/database.html#dbdicom.classes.database.Database">Database</a></li>
<li><a title="dbdicom.classes.record.Record" href="classes/record.html#dbdicom.classes.record.Record">Record</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="dbdicom.folder.Folder.required"><code class="name">var <span class="ident">required</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dbdicom.folder.Folder.set_attributes"><code class="name flex">
<span>def <span class="ident">set_attributes</span></span>(<span>self, attributes, scan=True)</span>
</code></dt>
<dd>
<div class="desc"><p>DICOM attributes that are NOT used by dbdicom.</p>
<p>Can be set by applications for fast access to key DICOM attributes such
as those used for sorting series data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>attributes</code></strong></dt>
<dd>list of DICOM attributes.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_attributes(self, attributes, scan=True):
    &#34;&#34;&#34;DICOM attributes that are NOT used by dbdicom.
    
    Can be set by applications for fast access to key DICOM attributes such
    as those used for sorting series data.

    Args:
        attributes: list of DICOM attributes.
    &#34;&#34;&#34;
    if attributes is None:
        return
    # Make sure all columns are unique
    attr = []
    for a in attributes:
        if a not in self.required:
            attr.append(a)
    self.__dict__[&#39;attributes&#39;] = attr
    if scan: self.scan()</code></pre>
</details>
</dd>
<dt id="dbdicom.folder.Folder.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>self, path=None, message='Opening folder..', unzip=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Opens a DICOM folder for read and write.</p>
<p>Reads the contents of the folder and summarises all DICOM files
in a dataframe for faster access next time. The dataframe is saved
as a csv file when the folder is closed with <code>folder.close()</code>.
All non-DICOM files in the folder are ignored.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>The full path to the directory that is to be opened.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The folder instance. This allows using the open() method in a
piping notation as in <code>inst = folder.open().instances()</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def open(self, path=None, message=&#39;Opening folder..&#39;, unzip=False):
        &#34;&#34;&#34;Opens a DICOM folder for read and write.
        
        Reads the contents of the folder and summarises all DICOM files
        in a dataframe for faster access next time. The dataframe is saved 
        as a csv file when the folder is closed with `folder.close()`. 
        All non-DICOM files in the folder are ignored.
        
        Args:
            path: The full path to the directory that is to be opened.

        Returns:
            The folder instance. This allows using the open() method in a 
            piping notation as in `inst = folder.open().instances()`.
        &#34;&#34;&#34;
        if path is not None: 
            self.__dict__[&#39;path&#39;] = path
        if self.path is None:
            message = &#34;please set a path before opening.&#34;
            message += &#34;\n Use folder.open(path_to_dicom_folder).&#34;
            self.dialog.information(message)
            return self
        if os.path.exists(self._csv):
            self.status.message(&#34;Reading register..&#34;)
            self._read_csv()
            # If the saved register does not have all required attributes
            # then scan the folder again and create a new register
            labels = self._columns + [&#39;removed&#39;,&#39;created&#39;]
            if labels != list(self.dataframe.columns):
#            for attribute in self.__dict__[&#39;attributes&#39;]:
#                if attribute not in self.dataframe:
                self.scan(message=message)
                self.status.hide()
                return self
            self.status.hide()
        else:
            self.scan(message=message, unzip=unzip)
        return self</code></pre>
</details>
</dd>
<dt id="dbdicom.folder.Folder.scan"><code class="name flex">
<span>def <span class="ident">scan</span></span>(<span>self, message='Scanning..', unzip=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads all files in the folder and summarises key attributes in a table for faster access.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scan(self, message=&#39;Scanning..&#39;, unzip=False):
    &#34;&#34;&#34;
    Reads all files in the folder and summarises key attributes in a table for faster access.
    &#34;&#34;&#34;
    if unzip:
        self.status.message(&#39;Extracting compressed folders..&#39;)
        utilities._unzip_files(self.path, self.status)
    self.status.message(&#39;Finding all files..&#39;)
    files = [item.path for item in utilities.scan_tree(self.path) if item.is_file()]
    self.__dict__[&#39;dataframe&#39;] = utilities.dataframe(self.path, files, self._columns, self.status, message=message)
    self.dataframe[&#39;removed&#39;] = [False] * self.dataframe.shape[0]
    self.dataframe[&#39;created&#39;] = [False] * self.dataframe.shape[0]
    self._multiframe_to_singleframe()
    self._write_csv()
    return self</code></pre>
</details>
</dd>
<dt id="dbdicom.folder.Folder.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Close an open folder.</p>
<p>This method checks if the changes have been saved and prompts the
user to save or restore them if not. The user also has the option
to cancel closing, in which case the function does nothing. </p>
<p><code>close()</code> also resets the dataframe and path to default values.</p>
<p>Returns:
True if the user has agreed to close the folder
(possible after save or restore) and False if the user
has cancelled the closing of the folder.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    &#34;&#34;&#34;Close an open folder.
    
    This method checks if the changes have been saved and prompts the 
    user to save or restore them if not. The user also has the option 
    to cancel closing, in which case the function does nothing. 
    
    `close()` also resets the dataframe and path to default values.

    Returns: 
        True if the user has agreed to close the folder 
        (possible after save or restore) and False if the user 
        has cancelled the closing of the folder.
    &#34;&#34;&#34;
    if not self.is_open(): 
        return True
    if not self.is_saved():
        reply = self.dialog.question( 
            title = &#39;Closing DICOM folder&#39;, 
            message = &#39;Save changes before closing?&#39;,
            cancel = True, 
        )
        if reply == &#34;Cancel&#34;: 
            return False
        if reply == &#34;Yes&#34;:
            self.save()
        elif reply == &#34;No&#34;:
            self.restore()

    self._write_csv()
    self.__dict__[&#39;dataframe&#39;] = pd.DataFrame([]*len(self._columns), columns=self._columns)            
    self.__dict__[&#39;path&#39;] = None

    return True</code></pre>
</details>
</dd>
<dt id="dbdicom.folder.Folder.is_saved"><code class="name flex">
<span>def <span class="ident">is_saved</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the folder is saved.</p>
<p>Returns:
True if the folder is saved and False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_saved(self):
    &#34;&#34;&#34;Check if the folder is saved.
    
    Returns: 
        True if the folder is saved and False otherwise.
    &#34;&#34;&#34;
    if self.dataframe.removed.any(): return False
    if self.dataframe.created.any(): return False
    return True</code></pre>
</details>
</dd>
<dt id="dbdicom.folder.Folder.is_open"><code class="name flex">
<span>def <span class="ident">is_open</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the folder is currently open.</p>
<p>Returns:
True if the folder is open and False otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_open(self):
    &#34;&#34;&#34;Check if the folder is currently open.
    
    Returns: 
        True if the folder is open and False otherwise.
    &#34;&#34;&#34;
    return self.path is not None</code></pre>
</details>
</dd>
<dt id="dbdicom.folder.Folder.sortby"><code class="name flex">
<span>def <span class="ident">sortby</span></span>(<span>self, sortby)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sortby(self, sortby):
    
    self.dataframe.sort_values(sortby, inplace=True)
    return self</code></pre>
</details>
</dd>
<dt id="dbdicom.folder.Folder.object"><code class="name flex">
<span>def <span class="ident">object</span></span>(<span>self, row, generation=4)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new dicom object from a row in the dataframe.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>row</code></strong></dt>
<dd>a row in the dataframe as a series</dd>
<dt><strong><code>generation</code></strong></dt>
<dd>determines whether the object returned is
at level database (generation=0), patient (generation=1),
study (generation=2), series (generation=3)
or instance (generation=4, default).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>An instance of one of the dicom classes defined in wedicom.classes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def object(self, row, generation=4):
    &#34;&#34;&#34;Create a new dicom object from a row in the dataframe.
    
    Args:
        row: a row in the dataframe as a series
        generation: determines whether the object returned is 
            at level database (generation=0), patient (generation=1),
            study (generation=2), series (generation=3) 
            or instance (generation=4, default).
    Returns:
        An instance of one of the dicom classes defined in wedicom.classes.
    &#34;&#34;&#34;
    return dicm.object(self, row, generation)</code></pre>
</details>
</dd>
<dt id="dbdicom.folder.Folder.instance"><code class="name flex">
<span>def <span class="ident">instance</span></span>(<span>self, file)</span>
</code></dt>
<dd>
<div class="desc"><p>Create an instance from a filepath</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def instance(self, file):
    &#34;&#34;&#34;Create an instance from a filepath&#34;&#34;&#34;

    row = self.dataframe.loc[file]
    return self.object(row) </code></pre>
</details>
</dd>
<dt id="dbdicom.folder.Folder.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints a summary of the project folder to the terminal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print(self):
    &#34;&#34;&#34;Prints a summary of the project folder to the terminal.&#34;&#34;&#34;
    
    print(&#39; &#39;)
    print(&#39;---------- DICOM FOLDER --------------&#39;)
    print(&#39;FOLDER: &#39; + self.path)
    for i, patient in enumerate(self.children()):
        print(&#39; &#39;)
        print(&#39;    PATIENT [&#39; + str(i) + &#39;]: &#39; + patient.label())
        print(&#39; &#39;)
        for j, study in enumerate(patient.children()):
            print(&#39;        STUDY [&#39; + str(j) + &#39;]: &#39; + study.label())
            print(&#39; &#39;)
            for k, series in enumerate(study.children()):
                print(&#39;            SERIES [&#39; + str(k) + &#39;]: &#39; + series.label())
                print(&#39;                Nr of instances: &#39; + str(len(series.children()))) </code></pre>
</details>
</dd>
<dt id="dbdicom.folder.Folder.label"><code class="name flex">
<span>def <span class="ident">label</span></span>(<span>self, row, type)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def label(self, row, type):

    if type == &#39;Patient&#39;:
        name = row.PatientName
        id = row.PatientID
        label = str(name)
        label += &#39; [&#39; + str(id) + &#39;]&#39;
        return type + &#34; - {}&#34;.format(label)
    if type == &#39;Study&#39;:
        descr = row.StudyDescription
        date = row.StudyDate
        label = str(descr)
        label += &#39; [&#39; + str(date) + &#39;]&#39;
        return type + &#34; - {}&#34;.format(label)
    if type == &#39;Series&#39;:
        descr = row.SeriesDescription
        nr = row.SeriesNumber
        label = &#39;[&#39; + str(nr).zfill(3) + &#39;] &#39; 
        label += str(descr)
        return type + &#34; - {}&#34;.format(label)
    if type == &#39;Instance&#39;:
        nr = row.InstanceNumber
        label = str(nr).zfill(6)
        return type + &#34; - {}&#34;.format(label)</code></pre>
</details>
</dd>
<dt id="dbdicom.folder.Folder.new_uid"><code class="name flex">
<span>def <span class="ident">new_uid</span></span>(<span>self, n=1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_uid(self, n=1):
    
    if n == 1:
        return pydicom.uid.generate_uid()
    uid = []
    for _ in range(n):
        uid.append(pydicom.uid.generate_uid())
    return uid</code></pre>
</details>
</dd>
<dt id="dbdicom.folder.Folder.new_file"><code class="name flex">
<span>def <span class="ident">new_file</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_file(self):

    # Generate a new filename
    path = os.path.join(self.path, &#34;dbdicom&#34;)
    if not os.path.isdir(path): os.mkdir(path)
    #file = os.path.join(path, self.new_uid() + &#39;.dcm&#39;) 
    file = os.path.join(&#34;dbdicom&#34;, self.new_uid() + &#39;.dcm&#39;) 
    return file</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="dbdicom.classes.database.Database" href="classes/database.html#dbdicom.classes.database.Database">Database</a></b></code>:
<ul class="hlist">
<li><code><a title="dbdicom.classes.database.Database.array" href="classes/record.html#dbdicom.classes.record.Record.array">array</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.children" href="classes/record.html#dbdicom.classes.record.Record.children">children</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.copy" href="classes/record.html#dbdicom.classes.record.Record.copy">copy</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.data" href="classes/record.html#dbdicom.classes.record.Record.data">data</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.dataset" href="classes/record.html#dbdicom.classes.record.Record.dataset">dataset</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.export" href="classes/record.html#dbdicom.classes.record.Record.export">export</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.files" href="classes/record.html#dbdicom.classes.record.Record.files">files</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.in_memory" href="classes/record.html#dbdicom.classes.record.Record.in_memory">in_memory</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.instances" href="classes/record.html#dbdicom.classes.record.Record.instances">instances</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.key" href="classes/record.html#dbdicom.classes.record.Record.key">key</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.move_to" href="classes/record.html#dbdicom.classes.record.Record.move_to">move_to</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.new_child" href="classes/record.html#dbdicom.classes.record.Record.new_child">new_child</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.new_cousin" href="classes/record.html#dbdicom.classes.record.Record.new_cousin">new_cousin</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.new_pibling" href="classes/record.html#dbdicom.classes.record.Record.new_pibling">new_pibling</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.new_series" href="classes/record.html#dbdicom.classes.record.Record.new_series">new_series</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.new_sibling" href="classes/record.html#dbdicom.classes.record.Record.new_sibling">new_sibling</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.parent" href="classes/record.html#dbdicom.classes.record.Record.parent">parent</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.patients" href="classes/record.html#dbdicom.classes.record.Record.patients">patients</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.records" href="classes/record.html#dbdicom.classes.record.Record.records">records</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.remove" href="classes/record.html#dbdicom.classes.record.Record.remove">remove</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.restore" href="classes/record.html#dbdicom.classes.record.Record.restore">restore</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.restore_OBSOLETE" href="classes/record.html#dbdicom.classes.record.Record.restore_OBSOLETE">restore_OBSOLETE</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.save" href="classes/record.html#dbdicom.classes.record.Record.save">save</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.save_OBSOLETE" href="classes/record.html#dbdicom.classes.record.Record.save_OBSOLETE">save_OBSOLETE</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.series" href="classes/record.html#dbdicom.classes.record.Record.series">series</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.set_array" href="classes/record.html#dbdicom.classes.record.Record.set_array">set_array</a></code></li>
<li><code><a title="dbdicom.classes.database.Database.studies" href="classes/record.html#dbdicom.classes.record.Record.studies">studies</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dbdicom" href="index.html">dbdicom</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dbdicom.folder.Folder" href="#dbdicom.folder.Folder">Folder</a></code></h4>
<ul class="two-column">
<li><code><a title="dbdicom.folder.Folder.set_attributes" href="#dbdicom.folder.Folder.set_attributes">set_attributes</a></code></li>
<li><code><a title="dbdicom.folder.Folder.open" href="#dbdicom.folder.Folder.open">open</a></code></li>
<li><code><a title="dbdicom.folder.Folder.scan" href="#dbdicom.folder.Folder.scan">scan</a></code></li>
<li><code><a title="dbdicom.folder.Folder.close" href="#dbdicom.folder.Folder.close">close</a></code></li>
<li><code><a title="dbdicom.folder.Folder.is_saved" href="#dbdicom.folder.Folder.is_saved">is_saved</a></code></li>
<li><code><a title="dbdicom.folder.Folder.is_open" href="#dbdicom.folder.Folder.is_open">is_open</a></code></li>
<li><code><a title="dbdicom.folder.Folder.sortby" href="#dbdicom.folder.Folder.sortby">sortby</a></code></li>
<li><code><a title="dbdicom.folder.Folder.object" href="#dbdicom.folder.Folder.object">object</a></code></li>
<li><code><a title="dbdicom.folder.Folder.instance" href="#dbdicom.folder.Folder.instance">instance</a></code></li>
<li><code><a title="dbdicom.folder.Folder.print" href="#dbdicom.folder.Folder.print">print</a></code></li>
<li><code><a title="dbdicom.folder.Folder.label" href="#dbdicom.folder.Folder.label">label</a></code></li>
<li><code><a title="dbdicom.folder.Folder.new_uid" href="#dbdicom.folder.Folder.new_uid">new_uid</a></code></li>
<li><code><a title="dbdicom.folder.Folder.new_file" href="#dbdicom.folder.Folder.new_file">new_file</a></code></li>
<li><code><a title="dbdicom.folder.Folder.required" href="#dbdicom.folder.Folder.required">required</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>