
<!DOCTYPE html>


<html lang="en" data-content_root="../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>dbdicom.types.series &#8212; dbdicom 0.2.4 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css?v=d2d258e8" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-binder.css?v=f4aeca0c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- So that users can add custom icons -->
  <script src="../../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../../_static/documentation_options.js?v=6ffd866b"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../../_static/design-tabs.js?v=f930bc37"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/dbdicom/types/series';</script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../../_static/dbd.png" class="logo__image only-light" alt="dbdicom 0.2.4 documentation - Home"/>
    <img src="../../../_static/dbd.png" class="logo__image only-dark pst-js-only" alt="dbdicom 0.2.4 documentation - Home"/>
  
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../user_guide/index.html">
    User guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../reference/index.html">
    Reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../generated/examples/index.html">
    Examples
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../developers_guide/index.html">
    Developer guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../about/index.html">
    About
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/QIB-Sheffield/dbdicom" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../user_guide/index.html">
    User guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../reference/index.html">
    Reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../generated/examples/index.html">
    Examples
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../developers_guide/index.html">
    Developer guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../about/index.html">
    About
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/QIB-Sheffield/dbdicom" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">dbdicom.types.series</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for dbdicom.types.series</h1><div class="highlight"><pre>
<span></span><span class="c1"># Importing annotations to handle or sign in import type hints</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numbers</span><span class="w"> </span><span class="kn">import</span> <span class="n">Number</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">nibabel</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nib</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">vreg</span>


<span class="kn">from</span><span class="w"> </span><span class="nn">dbdicom.record</span><span class="w"> </span><span class="kn">import</span> <span class="n">Record</span><span class="p">,</span> <span class="n">read_dataframe_from_instance_array</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dbdicom.ds</span><span class="w"> </span><span class="kn">import</span> <span class="n">MRImage</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">dbdicom.utils.image</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">image_utils</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dbdicom.manager</span><span class="w"> </span><span class="kn">import</span> <span class="n">Manager</span>
<span class="c1"># import dbdicom.extensions.scipy as scipy_utils</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dbdicom.utils.files</span><span class="w"> </span><span class="kn">import</span> <span class="n">export_path</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Series</span><span class="p">(</span><span class="n">Record</span><span class="p">):</span>

    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;SeriesInstanceUID&#39;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_key</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">delete_series</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">uid</span><span class="p">])</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">parent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1">#uid = self.manager.register.at[self.key(), &#39;StudyInstanceUID&#39;]</span>
        <span class="n">uid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">_at</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">(),</span> <span class="s1">&#39;StudyInstanceUID&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="s1">&#39;Study&#39;</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">())</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">instances</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">new_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> 
        <span class="n">attr</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">kwargs</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_instance</span><span class="p">(</span><span class="n">dataset</span><span class="o">=</span><span class="n">dataset</span><span class="p">,</span> <span class="o">**</span><span class="n">attr</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">new_sibling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">suffix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">desc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">_at</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">(),</span> <span class="s1">&#39;SeriesDescription&#39;</span><span class="p">)</span> 
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;SeriesDescription&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">desc</span> <span class="o">+</span> <span class="s1">&#39; [&#39;</span> <span class="o">+</span> <span class="n">suffix</span> <span class="o">+</span> <span class="s1">&#39;]&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">()</span><span class="o">.</span><span class="n">new_child</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">new_instance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">attr</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">kwargs</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="p">}</span>
        <span class="n">uid</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">new_instance</span><span class="p">(</span><span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">uid</span><span class="p">,</span> <span class="n">dataset</span><span class="o">=</span><span class="n">dataset</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">(),</span> <span class="o">**</span><span class="n">attr</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="s1">&#39;Instance&#39;</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">**</span><span class="n">attr</span><span class="p">)</span>

    <span class="c1"># replace by clone(). Adopt implies move rather than copy</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">adopt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instances</span><span class="p">):</span> 
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">instances</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="n">uids</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">uid</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">instances</span><span class="p">]</span>
        <span class="n">uids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">copy_to_series</span><span class="p">(</span><span class="n">uids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">uid</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">uids</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="s1">&#39;Instance&#39;</span><span class="p">,</span> <span class="n">uid</span><span class="p">)</span> <span class="k">for</span> <span class="n">uid</span> <span class="ow">in</span> <span class="n">uids</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="s1">&#39;Instance&#39;</span><span class="p">,</span> <span class="n">uids</span><span class="p">)</span>        

    <span class="k">def</span><span class="w"> </span><span class="nf">_copy_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">attr</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">kwargs</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">attributes</span><span class="p">}</span>
        <span class="n">uids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">copy_to_series</span><span class="p">(</span><span class="n">record</span><span class="o">.</span><span class="n">uid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">uid</span><span class="p">,</span> <span class="o">**</span><span class="n">attr</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">uids</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="s1">&#39;Instance&#39;</span><span class="p">,</span> <span class="n">uid</span><span class="p">,</span> <span class="o">**</span><span class="n">attr</span><span class="p">)</span> <span class="k">for</span> <span class="n">uid</span> <span class="ow">in</span> <span class="n">uids</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="s1">&#39;Instance&#39;</span><span class="p">,</span> <span class="n">uids</span><span class="p">,</span> <span class="o">**</span><span class="n">attr</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">export_as_dicom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span> 
        <span class="n">folder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">()</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">export_path</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">folder</span><span class="p">)</span>
        <span class="c1"># Create a copy so that exported datasets have different UIDs.</span>
        <span class="n">copy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">mgr</span> <span class="o">=</span> <span class="n">Manager</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">status</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">status</span><span class="p">)</span>
        <span class="n">mgr</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">copy</span><span class="o">.</span><span class="n">instances</span><span class="p">():</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">get_dataset</span><span class="p">()</span>
            <span class="n">mgr</span><span class="o">.</span><span class="n">import_dataset</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>
        <span class="n">copy</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">export_as_png</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1">#Export all images as png files</span>
        <span class="n">folder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">()</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">export_path</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">folder</span><span class="p">)</span>
        <span class="n">images</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">images</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">img</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">images</span><span class="p">):</span>
            <span class="n">img</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">),</span> <span class="s1">&#39;Exporting png..&#39;</span><span class="p">)</span>
            <span class="n">img</span><span class="o">.</span><span class="n">export_as_png</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">export_as_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="c1">#Export all images as csv files</span>
        <span class="n">folder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">()</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">export_path</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">folder</span><span class="p">)</span>
        <span class="n">images</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">images</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">img</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">images</span><span class="p">):</span>
            <span class="n">img</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">),</span> <span class="s1">&#39;Exporting csv..&#39;</span><span class="p">)</span>
            <span class="n">img</span><span class="o">.</span><span class="n">export_as_csv</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">export_as_npy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">folder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">()</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">export_path</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">folder</span><span class="p">)</span>
            <span class="n">images</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">images</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">img</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">images</span><span class="p">):</span>
                <span class="n">img</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">),</span> <span class="s1">&#39;Exporting npy..&#39;</span><span class="p">)</span>
                <span class="n">img</span><span class="o">.</span><span class="n">export_as_npy</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel_values</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
            <span class="n">filepath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">()</span>
            <span class="n">filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">filepath</span> <span class="o">+</span> <span class="s1">&#39;.npy&#39;</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">array</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">export_as_nifti</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">folder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">()</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">export_path</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">folder</span><span class="p">)</span>
            <span class="n">affine</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">affine_matrix</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">affine</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">affine</span> <span class="o">=</span> <span class="p">[</span><span class="n">affine</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">affine</span><span class="p">:</span>
                <span class="n">matrix</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">images</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">img</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">images</span><span class="p">):</span>
                    <span class="n">img</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">),</span> <span class="s1">&#39;Exporting nifti..&#39;</span><span class="p">)</span>
                    <span class="n">img</span><span class="o">.</span><span class="n">export_as_nifti</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">matrix</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span><span class="o">.</span><span class="n">get_dataset</span><span class="p">()</span>
            <span class="n">sgroups</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slice_groups</span><span class="p">(</span><span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sgroups</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sgroups</span><span class="p">),</span> <span class="s1">&#39;Exporting nifti..&#39;</span><span class="p">)</span>
                <span class="n">dicom_header</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">nifti1</span><span class="o">.</span><span class="n">Nifti1DicomExtension</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">ds</span><span class="p">)</span>
                <span class="n">nifti1_image</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">Nifti1Image</span><span class="p">(</span><span class="n">sg</span><span class="p">[</span><span class="s1">&#39;ndarray&#39;</span><span class="p">],</span> <span class="n">image_utils</span><span class="o">.</span><span class="n">affine_to_RAH</span><span class="p">(</span><span class="n">sg</span><span class="p">[</span><span class="s1">&#39;affine&#39;</span><span class="p">]))</span>
                <span class="n">nifti1_image</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">extensions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dicom_header</span><span class="p">)</span>
                <span class="n">filepath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">()</span>
                <span class="n">filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">filepath</span> <span class="o">+</span> <span class="s1">&#39;[&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;].nii&#39;</span><span class="p">)</span>
                <span class="n">nib</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">nifti1_image</span><span class="p">,</span> <span class="n">filepath</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">import_dicom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">files</span><span class="p">):</span>
        <span class="n">uids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">import_datasets</span><span class="p">(</span><span class="n">files</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">move_to</span><span class="p">(</span><span class="n">uids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">uid</span><span class="p">)</span>



<div class="viewcode-block" id="Series.coords">
<a class="viewcode-back" href="../../../generated/api/dbdicom.Series.coords.html#dbdicom.Series.coords">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;InstanceNumber&#39;</span><span class="p">,</span> <span class="p">),</span> <span class="n">mesh</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="nb">slice</span><span class="o">=</span><span class="p">{},</span> <span class="n">coords</span><span class="o">=</span><span class="p">{},</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">filters</span><span class="p">)</span><span class="o">-&gt;</span><span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;return a dictionary of coordinates.</span>

<span class="sd">        Args:</span>
<span class="sd">            dims (tuple, optional): Dimensions along which the shape is to be determined. If dims is not provided, they default to InstanceNumber. </span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the dimensions do not produce suitable coordinates.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: dictionary of coordinates, one entry for each dimension. The values for each coordinate are returned as an darray with one dimension.</span>

<span class="sd">        See also:</span>
<span class="sd">            `set_coords`</span>

<span class="sd">        Example:</span>

<span class="sd">            Create an empty series with 3 slice dimensions:</span>

<span class="sd">            &gt;&gt;&gt; coords = {</span>
<span class="sd">            ...     &#39;SliceLocation&#39;: np.array([0,1,2,0,1,2]),</span>
<span class="sd">            ...     &#39;FlipAngle&#39;: np.array([2,2,2,10,10,10]),</span>
<span class="sd">            ...     &#39;RepetitionTime&#39;: np.array([1,5,15,1,5,15]),</span>
<span class="sd">            ... }</span>
<span class="sd">            &gt;&gt;&gt; series = db.empty_series(coords)</span>
<span class="sd">            </span>
<span class="sd">            Retrieve the coordinates:</span>

<span class="sd">            &gt;&gt;&gt; coords = series.coords(tuple(coords))</span>
<span class="sd">            &gt;&gt;&gt; coords[&#39;FlipAngle&#39;]</span>
<span class="sd">            [2,10,2,10,2,10]</span>
<span class="sd">            &gt;&gt;&gt; coords[&#39;RepetitionTime&#39;]</span>
<span class="sd">            [1,1,5,5,15,15]</span>

<span class="sd">            Check the result in default dimensions:</span>

<span class="sd">            &gt;&gt;&gt; coords = series.coords()</span>
<span class="sd">            &gt;&gt;&gt; coords[&#39;InstanceNumber&#39;]</span>
<span class="sd">            [1,2,3,4,5,6]</span>

<span class="sd">            In this case the slice location and flip angle along are sufficient to identify the frames, so these are valid coordinates:</span>

<span class="sd">            &gt;&gt;&gt; coords = series.coords((&#39;SliceLocation&#39;, &#39;FlipAngle&#39;))</span>
<span class="sd">            &gt;&gt;&gt; coords[&#39;SliceLocation&#39;]</span>
<span class="sd">            [0,0,1,1,2,2]</span>

<span class="sd">            # However slice location and acquisition time are not sufficient as coordinates because each combination appears twice. So this throws an error:</span>

<span class="sd">            &gt;&gt;&gt; series.coords((&#39;SliceLocation&#39;,&#39;RepetitionTime&#39;))</span>
<span class="sd">            ValueError: These are not proper coordinates. Coordinate values must be unique.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">(</span><span class="n">dims</span><span class="p">,)</span>

        <span class="c1"># Default empty coordinates</span>
        <span class="n">vcoords</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tag</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
            <span class="n">vcoords</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        
        <span class="c1"># Get all frames and return if empty</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">instances</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">frames</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="k">return</span> <span class="n">vcoords</span>
         
        <span class="c1"># Read values and sort</span>
        <span class="n">fltr</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="nb">slice</span><span class="p">,</span> <span class="o">**</span><span class="n">filters</span><span class="p">}</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">fltr</span><span class="p">)</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">coords</span><span class="p">))]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">frames</span><span class="p">]</span>
        <span class="n">values</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="c1"># Check dimensions</span>
        <span class="n">cvalues</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
        <span class="n">cvalues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cvalues</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">_check_if_ivals</span><span class="p">(</span><span class="n">cvalues</span><span class="p">)</span>

        <span class="c1"># Filter values</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">_filter_values</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">fltr</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="n">exclude</span><span class="p">)</span>

        <span class="c1"># If requested, mesh values</span>
        <span class="k">if</span> <span class="n">mesh</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">_meshvals</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="n">mshape</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="c1"># Build coordinates</span>
        <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tag</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
                <span class="n">vcoords</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">mesh</span><span class="p">:</span> <span class="c1"># Is this necessary? Is already in the right shape</span>
                    <span class="n">vcoords</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">vcoords</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">mshape</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">vcoords</span></div>

    

<div class="viewcode-block" id="Series.values">
<a class="viewcode-back" href="../../../generated/api/dbdicom.Series.values.html#dbdicom.Series.values">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">tags</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;InstanceNumber&#39;</span><span class="p">,</span> <span class="p">),</span> <span class="n">return_coords</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="nb">slice</span><span class="o">=</span><span class="p">{},</span> <span class="n">coords</span><span class="o">=</span><span class="p">{},</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">filters</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the values of one or more attributes for each frame in the series.</span>

<span class="sd">        Args:</span>
<span class="sd">            tag (str or tuple): either a keyword string or a (group, element) tag of a DICOM data element.</span>
<span class="sd">            dims (tuple, optional): Dimensions of the resulting array. If *dims* is not provided, values are ordered by InstanceNumber. Defaults to None.</span>
<span class="sd">            inds (dict, optional): Dictionary with indices to retrieve a slice of the entire array. Defaults to None.</span>
<span class="sd">            select (dict, optional): A dictionary of values for DICOM attributes to filter the result. By default the data are not filtered.</span>
<span class="sd">            filters (dict, optional): keyword arguments to filter the data by value of DICOM attributes.</span>

<span class="sd">        Returns:</span>
<span class="sd">            An `numpy.ndarray` of values with dimensions as specified by *dims*. If the value is not defined in *one or more* of the slices, an empty array is returned.</span>

<span class="sd">        See also:</span>
<span class="sd">            `unique`</span>
<span class="sd">            `coords`</span>
<span class="sd">            `gridcoords`</span>

<span class="sd">        Note:</span>
<span class="sd">            In order to list the values in the case one or more are absent in the headers, use `Series.unique()` instead.</span>

<span class="sd">        Example:</span>

<span class="sd">            Create a zero-filled series with 3 slice dimensions:</span>

<span class="sd">            &gt;&gt;&gt; coords = {</span>
<span class="sd">            ...     &#39;SliceLocation&#39;: 10*np.arange(4),</span>
<span class="sd">            ...     &#39;FlipAngle&#39;: np.array([2, 15, 30]),</span>
<span class="sd">            ...     &#39;RepetitionTime&#39;: np.array([2.5, 5.0]), }</span>
<span class="sd">            &gt;&gt;&gt; zeros = db.zeros((128,128,4,3,2), coords)</span>

<span class="sd">            # If values() is called without dimensions, a flat array is returned with one value per frame, ordered by instance number:</span>

<span class="sd">            &gt;&gt;&gt; zeros.values(&#39;InstanceNumber&#39;)</span>
<span class="sd">            [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,191,20,21,22,23,24]</span>
<span class="sd">            &gt;&gt;&gt; zros.values(&#39;FlipAngle&#39;)</span>
<span class="sd">            [2,2,15,15,30,30,2,2,15,15,30,30,2,2,15,15,30,30,2,2,15,15,30,30]</span>

<span class="sd">            if dimensions are provided, an array of the appropriate shape is returned:</span>

<span class="sd">            &gt;&gt;&gt; dims = tuple(coords)</span>
<span class="sd">            &gt;&gt;&gt; tacq = series.values(&#39;AcquisitionTime&#39;, dims)</span>
<span class="sd">            &gt;&gt;&gt; tacq.shape</span>
<span class="sd">            (4,3,2)</span>
<span class="sd">            &gt;&gt;&gt; tacq[0,0,0]</span>
<span class="sd">            28609.057496</span>

<span class="sd">            In this case all values are the same:</span>

<span class="sd">            &gt;&gt;&gt; np.unique(tacq)</span>
<span class="sd">            [28609.057496]</span>

<span class="sd">            If a value is not defined in the header, None is returned:</span>
<span class="sd">            &gt;&gt;&gt; series.values(&#39;Gobbledigook&#39;)[:2]</span>
<span class="sd">            [None None]</span>

<span class="sd">            Specify keywords to select a subset of values:</span>

<span class="sd">            &gt;&gt;&gt; tacq = zeros.values(&#39;AcquisitionTime&#39;, dims, FlipAngle=15)</span>
<span class="sd">            &gt;&gt;&gt; tacq.shape</span>
<span class="sd">            (4, 1, 2)</span>

<span class="sd">            If none exist, and emptry array is returned:</span>

<span class="sd">            &gt;&gt;&gt; tacq = zeros.values(&#39;AcquisitionTime&#39;, dims, FlipAngle=0)</span>
<span class="sd">            &gt;&gt;&gt; tacq.size</span>
<span class="sd">            0</span>

<span class="sd">            Multiple possible values can be selected with arrays:</span>

<span class="sd">            &gt;&gt;&gt; tacq = zeros.values(&#39;AcquisitionTime&#39;, dims, FlipAngle=np.array([15,30]))</span>
<span class="sd">            &gt;&gt;&gt; tacq.shape</span>
<span class="sd">            (4, 2, 2)</span>

<span class="sd">            Any number of keywords can be added as filters:</span>

<span class="sd">            &gt;&gt;&gt; tacq = zeros.values(&#39;AcquisitionTime&#39;, dims, FlipAngle=np.array([15,30]), SliceLocation=np.array([10,20]))</span>
<span class="sd">            &gt;&gt;&gt; tacq.shape</span>
<span class="sd">            (2, 2, 2)</span>

<span class="sd">            Filters can alos be set using the *select* argument: </span>

<span class="sd">            &gt;&gt;&gt; tacq = zeros.values(&#39;AcquisitionTime&#39;, dims, select={&#39;FlipAngle&#39;: 15})</span>
<span class="sd">            &gt;&gt;&gt; tacq.shape</span>
<span class="sd">            (4, 1, 2)</span>

<span class="sd">            This also allows (group, element) tags:</span>

<span class="sd">            &gt;&gt;&gt; tacq = zeros.values(&#39;AcquisitionTime&#39;, dims, select={(0x0018, 0x1314): 15})</span>
<span class="sd">            &gt;&gt;&gt; tacq.shape</span>
<span class="sd">            (4, 1, 2)</span>

<span class="sd">            Selections can also be made using indices rather than values:</span>

<span class="sd">            &gt;&gt;&gt; tacq = zeros.values(&#39;FlipAngle&#39;, dims, inds={&#39;FlipAngle&#39;: 1})</span>
<span class="sd">            &gt;&gt;&gt; tacq.shape</span>
<span class="sd">            (4, 1, 2) </span>

<span class="sd">            &gt;&gt;&gt; tacq = zeros.values(&#39;AcquisitionTime&#39;, dims, inds={&#39;FlipAngle&#39;:np.arange(2)})</span>
<span class="sd">            &gt;&gt;&gt; tacq.shape</span>
<span class="sd">            (4, 2, 2)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">(</span><span class="n">dims</span><span class="p">,)</span>

        <span class="c1"># Default return values</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">vcoords</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tag</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
            <span class="n">vcoords</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        
        <span class="c1"># Get all frames and return if empty</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">instances</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">frames</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="k">if</span> <span class="n">return_coords</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">values</span><span class="p">,</span> <span class="n">vcoords</span>
            <span class="k">return</span> <span class="n">values</span>
              
        <span class="c1"># Read values and sort</span>
        <span class="n">filters</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="nb">slice</span><span class="p">,</span> <span class="o">**</span><span class="n">filters</span><span class="p">}</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frames</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">frames</span><span class="p">),</span> <span class="s1">&#39;Reading values..&#39;</span><span class="p">)</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">filters</span><span class="p">))</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">coords</span><span class="p">))]</span>
            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">fsort</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">values</span><span class="p">[</span><span class="n">k</span><span class="p">][:</span><span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)])</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">fsort</span><span class="p">]</span>
        
        <span class="c1"># Check if dimensions are proper</span>
        <span class="c1"># Need object array here because the values can be different type including lists.</span>
        <span class="n">cvalues</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
        <span class="n">cvalues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cvalues</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">_check_if_ivals</span><span class="p">(</span><span class="n">cvalues</span><span class="p">)</span>

        <span class="c1"># Filter values</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">_filter_values</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="n">exclude</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">return_coords</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> 
                    <span class="k">return</span> <span class="n">values</span><span class="p">,</span> <span class="n">vcoords</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tags</span><span class="p">))]</span>
                    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">vcoords</span><span class="p">,)</span>
            <span class="k">return</span> <span class="n">values</span>
        <span class="n">cvalues</span> <span class="o">=</span> <span class="n">values</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">),:]</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">):,:]</span>

        <span class="c1"># If requested, mesh values</span>
        <span class="k">if</span> <span class="n">mesh</span><span class="p">:</span>
            <span class="n">cmesh</span> <span class="o">=</span> <span class="n">_meshvals</span><span class="p">(</span><span class="n">cvalues</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">_meshdata</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">cvalues</span><span class="p">,</span> <span class="n">cmesh</span><span class="p">)</span>
            <span class="n">cvalues</span> <span class="o">=</span> <span class="n">cmesh</span>
            
        <span class="c1"># Create return values</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
            <span class="n">values</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_coords</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tag</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
                <span class="n">vcoords</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">cvalues</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> 
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> 
                <span class="k">return</span> <span class="n">values</span><span class="p">,</span> <span class="n">vcoords</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">values</span> <span class="o">+</span> <span class="p">(</span><span class="n">vcoords</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">values</span></div>






<div class="viewcode-block" id="Series.frames">
<a class="viewcode-back" href="../../../generated/api/dbdicom.Series.frames.html#dbdicom.Series.frames">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">frames</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;InstanceNumber&#39;</span><span class="p">,</span> <span class="p">),</span> <span class="n">return_coords</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
            <span class="n">return_vals</span><span class="o">=</span><span class="p">(),</span> <span class="n">mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="nb">slice</span><span class="o">=</span><span class="p">{},</span> <span class="n">coords</span><span class="o">=</span><span class="p">{},</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
            <span class="o">**</span><span class="n">filters</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the frames of given coordinates in the correct order&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">(</span><span class="n">dims</span><span class="p">,)</span>

        <span class="c1"># Default return values</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">vcoords</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tag</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
            <span class="n">vcoords</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">if</span> <span class="n">mesh</span><span class="p">:</span>
            <span class="n">fshape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fshape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span>
            
        <span class="c1"># Get all frames and return if empty</span>
        <span class="n">frames_sel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">instances</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">frames_sel</span> <span class="o">==</span> <span class="p">[]:</span>

            <span class="c1"># Empty return values</span>
            <span class="n">frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">fshape</span><span class="p">)</span>
            <span class="n">rval</span> <span class="o">=</span> <span class="p">(</span><span class="n">frames</span><span class="p">,)</span>
            <span class="k">if</span> <span class="n">return_coords</span><span class="p">:</span>
                <span class="n">rval</span> <span class="o">+=</span> <span class="p">(</span><span class="n">vcoords</span><span class="p">,</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">return_vals</span> <span class="o">!=</span> <span class="p">():</span>
                <span class="n">rval</span> <span class="o">+=</span> <span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rval</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">rval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">rval</span>
              
        <span class="c1"># Read values and sort</span>
        <span class="n">filters</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="nb">slice</span><span class="p">,</span> <span class="o">**</span><span class="n">filters</span><span class="p">}</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">return_vals</span><span class="p">)</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">filters</span><span class="p">))</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">coords</span><span class="p">))]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">frames_sel</span><span class="p">]</span>
        <span class="n">fsort</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">values</span><span class="p">[</span><span class="n">k</span><span class="p">][:</span><span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)])</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">fsort</span><span class="p">]</span>

        <span class="c1"># Check dimensions</span>
        <span class="n">cvalues</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
        <span class="n">cvalues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cvalues</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">_check_if_ivals</span><span class="p">(</span><span class="n">cvalues</span><span class="p">)</span>

        <span class="c1"># Create array of frames.</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">frames_sel</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fsort</span><span class="p">)):</span>
            <span class="n">frames</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">frames_sel</span><span class="p">[</span><span class="n">fsort</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

        <span class="c1"># Filter values</span>
        <span class="n">finds</span> <span class="o">=</span> <span class="n">_filter_values_ind</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="n">exclude</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">finds</span><span class="o">.</span><span class="n">size</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Empty return values</span>
            <span class="n">frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">fshape</span><span class="p">)</span>
            <span class="n">rval</span> <span class="o">=</span> <span class="p">(</span><span class="n">frames</span><span class="p">,)</span>
            <span class="k">if</span> <span class="n">return_coords</span><span class="p">:</span>
                <span class="n">rval</span> <span class="o">+=</span> <span class="p">(</span><span class="n">vcoords</span><span class="p">,</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">return_vals</span> <span class="o">!=</span> <span class="p">():</span>
                <span class="n">rval</span> <span class="o">+=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([]),</span> <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rval</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">rval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">rval</span>           
        <span class="n">frames</span> <span class="o">=</span> <span class="n">frames</span><span class="p">[</span><span class="n">finds</span><span class="p">]</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">_filter_values</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="n">exclude</span><span class="p">)</span>
        <span class="n">cvalues</span> <span class="o">=</span> <span class="n">values</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">),:]</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">):,:]</span>

        <span class="c1"># If requested, mesh values</span>
        <span class="k">if</span> <span class="n">mesh</span><span class="p">:</span>
            <span class="n">cmesh</span> <span class="o">=</span> <span class="n">_meshvals</span><span class="p">(</span><span class="n">cvalues</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">_meshdata</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">cvalues</span><span class="p">,</span> <span class="n">cmesh</span><span class="p">)</span>
            <span class="n">frames</span> <span class="o">=</span> <span class="n">_meshdata</span><span class="p">(</span><span class="n">frames</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">frames</span><span class="o">.</span><span class="n">size</span><span class="p">)),</span> <span class="n">cvalues</span><span class="p">,</span> <span class="n">cmesh</span><span class="p">)</span>
            <span class="n">frames</span> <span class="o">=</span> <span class="n">frames</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>
            <span class="n">cvalues</span> <span class="o">=</span> <span class="n">cmesh</span>
            
        <span class="c1"># Create return values</span>
        <span class="n">rval</span> <span class="o">=</span> <span class="p">(</span><span class="n">frames</span><span class="p">,)</span>
        <span class="k">if</span> <span class="n">return_coords</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tag</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
                <span class="n">vcoords</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">cvalues</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> 
            <span class="n">rval</span> <span class="o">+=</span> <span class="p">(</span><span class="n">vcoords</span><span class="p">,</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">return_vals</span> <span class="o">!=</span> <span class="p">():</span>
            <span class="n">rval</span> <span class="o">+=</span> <span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rval</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">rval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">rval</span></div>

        

<div class="viewcode-block" id="Series.expand">
<a class="viewcode-back" href="../../../generated/api/dbdicom.Series.expand.html#dbdicom.Series.expand">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">expand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="p">{},</span> <span class="n">gridcoords</span><span class="o">=</span><span class="p">{}):</span> <span class="c1"># gridcoords -&gt; slice</span>

        <span class="k">if</span> <span class="n">coords</span> <span class="o">!=</span> <span class="p">{}:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">gridcoords</span> <span class="o">!=</span> <span class="p">{}:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">_grid_to_coords</span><span class="p">(</span><span class="n">gridcoords</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Cannot expand without new coordinates&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># If the series is not empty, first check that the new coordinates are valid.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">empty</span><span class="p">():</span>
            <span class="n">current_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">coords</span><span class="p">))</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">_concatenate_coords</span><span class="p">((</span><span class="n">current_coords</span><span class="p">,</span> <span class="n">coords</span><span class="p">))</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Cannot expand - the new coordinates overlap with existing coordinates.&#39;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        
        <span class="c1"># Expand the series to the new coordinates</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">_coords_size</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_dataset</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">:</span>
                <span class="n">ds</span><span class="o">.</span><span class="n">set_values</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">coords</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">i</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">new_instance</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span></div>



<div class="viewcode-block" id="Series.set_coords">
<a class="viewcode-back" href="../../../generated/api/dbdicom.Series.set_coords.html#dbdicom.Series.set_coords">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_coords</span><span class="p">:</span><span class="nb">dict</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(),</span> <span class="nb">slice</span><span class="o">=</span><span class="p">{},</span> <span class="n">coords</span><span class="o">=</span><span class="p">{},</span> <span class="o">**</span><span class="n">filters</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set a dictionary of coordinates.</span>

<span class="sd">        Args:</span>
<span class="sd">            coords (dict): Dictionary of coordinates.</span>
<span class="sd">            dims (tuple, optional): Dimensions of at which the new coordinates are to be best. If *dims* is not set, the dimensions are assumed to be the same as those of *coords* or *grid*. Defaults to None.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: if the coordinates provided are not properly formatted or have the wrong shape.</span>

<span class="sd">        See also:</span>
<span class="sd">            `coords`</span>
<span class="sd">            `set_gridcoords`</span>

<span class="sd">        Example:</span>

<span class="sd">            Create an empty series:</span>

<span class="sd">            &gt;&gt;&gt; coords = {</span>
<span class="sd">            ...     &#39;SliceLocation&#39;: np.array([0,1,2,0,1,2]),</span>
<span class="sd">            ...     &#39;FlipAngle&#39;: np.array([2,2,2,10,10,10]),</span>
<span class="sd">            ...     &#39;RepetitionTime&#39;: np.array([1,5,15,1,5,15]),</span>
<span class="sd">            ... }</span>
<span class="sd">            &gt;&gt;&gt; series = db.empty_series(coords)</span>
<span class="sd">            </span>
<span class="sd">            Change the flip angle of 15 to 12:</span>

<span class="sd">            &gt;&gt;&gt; coords = series.coords(tuple(coords))</span>
<span class="sd">            &gt;&gt;&gt; fa = coords[&#39;FlipAngle&#39;]</span>
<span class="sd">            &gt;&gt;&gt; fa[np.where(fa==2)] = 5</span>
<span class="sd">            &gt;&gt;&gt; series.set_coords(coords)</span>

<span class="sd">            Check the new coordinates:</span>

<span class="sd">            &gt;&gt;&gt; new_coords = series.coords(dims)</span>
<span class="sd">            &gt;&gt;&gt; new_coords[&#39;FlipAngle&#39;]</span>
<span class="sd">            [5,10,5,10,5,10]</span>

<span class="sd">            Create a new set of coordinates along slice location and acquisition time:</span>

<span class="sd">            &gt;&gt;&gt; new_coords = {</span>
<span class="sd">            ...     &#39;SliceLocation&#39;: np.array([0,0,1,1,2,2]),</span>
<span class="sd">            ...     &#39;AcquisitionTime&#39;: np.array([0,60,0,60,0,60]),</span>
<span class="sd">            ... }</span>
<span class="sd">            &gt;&gt;&gt; series.set_coords(new_coords, (&#39;SliceLocation&#39;, &#39;FlipAngle&#39;))</span>

<span class="sd">            # Inspect the new coordinates - each slice now has two acquisition times corresponding to the flip angles:</span>

<span class="sd">            &gt;&gt;&gt; coords[&#39;SliceLocation&#39;]</span>
<span class="sd">            [0,0,1,1,2,2]</span>
<span class="sd">            &gt;&gt;&gt; coords[&#39;AcquisitionTime&#39;]</span>
<span class="sd">            [0,60,0,60,0,60]</span>
<span class="sd">            &gt;&gt;&gt; coords[&#39;FlipAngle&#39;]</span>
<span class="sd">            [5,10,5,10,5,10]</span>

<span class="sd">            # Check that an error is raised if coordinate values have different sizes:</span>
<span class="sd">            &gt;&gt;&gt; new_coords = {</span>
<span class="sd">            ...     &#39;SliceLocation&#39;: np.zeros(24),</span>
<span class="sd">            ...     &#39;AcquisitionTime&#39;: np.ones(25),</span>
<span class="sd">            ... }</span>
<span class="sd">            &gt;&gt;&gt; series.set_coords(new_coords, dims)</span>
<span class="sd">            ValueError: Coordinate values must all have the same size</span>

<span class="sd">            # An error is also raised if they have all the same size but the values are not unique:</span>

<span class="sd">            &gt;&gt;&gt; new_coords = {</span>
<span class="sd">            ...     &#39;SliceLocation&#39;: np.zeros(24),</span>
<span class="sd">            ...     &#39;AcquisitionTime&#39;: np.ones(24),</span>
<span class="sd">            ... }</span>
<span class="sd">            &gt;&gt;&gt; series.set_coords(new_coords, dims)</span>
<span class="sd">            ValueError: Coordinate values must all have the same size</span>

<span class="sd">            # .. or when the number does not match up with the size of the series:</span>

<span class="sd">            &gt;&gt;&gt; new_coords = {</span>
<span class="sd">            ...     &#39;SliceLocation&#39;: np.arange(25),</span>
<span class="sd">            ...     &#39;AcquisitionTime&#39;: np.arange(25),</span>
<span class="sd">            ... }</span>
<span class="sd">            &gt;&gt;&gt; series.set_coords(new_coords, dims)</span>
<span class="sd">            ValueError: Shape of coordinates does not match up with the size of the series.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dims</span> <span class="o">==</span> <span class="p">():</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">new_coords</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">(</span><span class="n">dims</span><span class="p">,)</span>
        <span class="n">new_coords</span> <span class="o">=</span> <span class="n">_check_if_coords</span><span class="p">(</span><span class="n">new_coords</span><span class="p">)</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="nb">slice</span><span class="o">=</span><span class="nb">slice</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="o">**</span><span class="n">filters</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">frames</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># If the series is empty, assignment of coords is unambiguous</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">new_coords</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">_coords_size</span><span class="p">(</span><span class="n">new_coords</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">size</span> <span class="o">!=</span> <span class="n">frames</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Cannot set &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; coordinates in &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">frames</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; frames.&#39;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">The number of new coordinates must equal the number of frames.&#39;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="c1"># If setting a subset, check if the new set of coordinates is valid</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">({</span><span class="o">**</span><span class="nb">slice</span><span class="p">,</span> <span class="o">**</span><span class="n">coords</span><span class="p">,</span> <span class="o">**</span><span class="n">filters</span><span class="p">})</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">complement</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="nb">slice</span><span class="o">=</span><span class="nb">slice</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">filters</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">_coords_size</span><span class="p">(</span><span class="n">complement</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">_concatenate_coords</span><span class="p">((</span><span class="n">new_coords</span><span class="p">,</span> <span class="n">complement</span><span class="p">))</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Cannot set coordinates - this would produce invalid coordinates for the series&#39;</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">frames</span> <span class="o">=</span> <span class="n">frames</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">_coords_vals</span><span class="p">(</span><span class="n">new_coords</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">frame</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frames</span><span class="p">):</span>
                <span class="n">frame</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">new_coords</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">[:,</span><span class="n">f</span><span class="p">])</span></div>



<div class="viewcode-block" id="Series.set_values">
<a class="viewcode-back" href="../../../generated/api/dbdicom.Series.set_values.html#dbdicom.Series.set_values">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">tags</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;InstanceNumber&#39;</span><span class="p">,</span> <span class="p">),</span> <span class="nb">slice</span><span class="o">=</span><span class="p">{},</span> <span class="n">coords</span><span class="o">=</span><span class="p">{},</span> <span class="o">**</span><span class="n">filters</span><span class="p">):</span>
        <span class="c1"># Note tags, values is a more logical order considering we have self.values(tags)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the values of an attribute.</span>

<span class="sd">        Args:</span>
<span class="sd">            tag: either a keyword string or a (group, element) tag of a DICOM data element.</span>
<span class="sd">            value: a single value or a numpy array of values for the attribute. </span>
<span class="sd">            dims (tuple, optional): Dimensions of *value*. If *value* is a single value, *dims* is ignored. Otherwise, if *dim* is not provided, values are ordered by instance number. Defaults to None.</span>

<span class="sd">        Raises: </span>
<span class="sd">            ValueError: if the size of *value* does not match the size of the series.</span>

<span class="sd">        See also:</span>
<span class="sd">            `value`</span>

<span class="sd">        Example:</span>

<span class="sd">            Create a zero-filled series with 3 slice dimensions.</span>

<span class="sd">            &gt;&gt;&gt; loc = np.arange(4)</span>
<span class="sd">            &gt;&gt;&gt; fa = [2, 15, 30]</span>
<span class="sd">            &gt;&gt;&gt; tr = [2.5, 5.0]</span>
<span class="sd">            &gt;&gt;&gt; coords = {</span>
<span class="sd">            ...     &#39;SliceLocation&#39;: np.arange(4),</span>
<span class="sd">            ...     &#39;FlipAngle&#39;: [2, 15, 30],</span>
<span class="sd">            ...     &#39;RepetitionTime&#39;: [2.5, 5.0] }</span>
<span class="sd">            &gt;&gt;&gt; series = db.zeros((128,128,8,3,2), coords)</span>

<span class="sd">            Change the acquisition time of the series to midnight (0 sec):</span>

<span class="sd">            &gt;&gt;&gt; series.value(&#39;AcquisitionTime&#39;)</span>
<span class="sd">            28609.057496</span>
<span class="sd">            &gt;&gt;&gt; series.set_value(&#39;AcquisitionTime&#39;, 0)</span>
<span class="sd">            &gt;&gt;&gt; series.value(&#39;AcquisitionTime&#39;)</span>
<span class="sd">            0</span>

<span class="sd">            Set the acquisition time to a different value for each flip angle:</span>

<span class="sd">            &gt;&gt;&gt; tacq = np.repeat(60*np.arange(3), 8)</span>
<span class="sd">            &gt;&gt;&gt; series.set_value(&#39;AcquisitionTime&#39;, tacq, dims=(&#39;FlipAngle&#39;,&#39;InstanceNumber&#39;))</span>

<span class="sd">            Set the acquisition time to a different value for each flip angle and acquisition time:</span>

<span class="sd">            &gt;&gt;&gt; tacq = np.repeat(60*np.arange(6), 4)</span>
<span class="sd">            &gt;&gt;&gt; series.set_value(&#39;AcquisitionTime&#39;, tacq, dims=(&#39;FlipAngle&#39;,&#39;RepetitionTime&#39;,&#39;SliceLocation&#39;))</span>

<span class="sd">            Note: the size of the value and of the series need to match up. If not, an error is raised:</span>

<span class="sd">            &gt;&gt;&gt; series.set_value(&#39;AcquisitionTime&#39;, np.arange(25), dims=tuple(coords))</span>
<span class="sd">            ValueError: The size of the value array is different from the size of the series.</span>
<span class="sd">            The value array has shape (25,), but the series has shape (4, 3).</span>

<span class="sd">        &quot;&quot;&quot;</span>  

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">(</span><span class="n">dims</span><span class="p">,)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_values</span><span class="p">((</span><span class="n">values</span><span class="p">,),</span> <span class="p">(</span><span class="n">tags</span><span class="p">,),</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span> <span class="nb">slice</span><span class="o">=</span><span class="nb">slice</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="o">**</span><span class="n">filters</span><span class="p">)</span>
            <span class="k">return</span>
        
        <span class="c1"># Get frames to set:</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="nb">slice</span><span class="o">=</span><span class="nb">slice</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="o">**</span><span class="n">filters</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">frames</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Cannot set values to an empty series. Use Series.expand() to create empty frames first.&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        
        <span class="c1"># Check that values all have the proper format:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
            <span class="c1">#if not isinstance(v, np.ndarray):</span>
            <span class="c1">#    values[i] = np.full(frames.shape, v) </span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">frames</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Cannot set values: number of values does not match number of frames.&#39;</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    
        <span class="c1"># Set values</span>
        <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">frame</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frames</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">f</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">frames</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="s1">&#39;Writing values..&#39;</span><span class="p">)</span>
            <span class="n">frame</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">tags</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">else</span> <span class="n">v</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span></div>

            <span class="c1">#frame[list(tags)] = [v[f] for v in values]</span>


<div class="viewcode-block" id="Series.set_gridcoords">
<a class="viewcode-back" href="../../../generated/api/dbdicom.Series.set_gridcoords.html#dbdicom.Series.set_gridcoords">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_gridcoords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gridcoords</span><span class="p">:</span><span class="nb">dict</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(),</span> <span class="nb">slice</span><span class="o">=</span><span class="p">{},</span> <span class="n">coords</span><span class="o">=</span><span class="p">{},</span> <span class="o">**</span><span class="n">filters</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Set a dictionary of grid coordinates.</span>

<span class="sd">        Args:</span>
<span class="sd">            coords (dict): dictionary of grid coordinates</span>
<span class="sd">            dims (tuple, optional): Dimensions of at which the new coordinates are to be best. If *dims* is not set, the dimensions are assumed to be the same as those of *coords* or *grid*. Defaults to None.</span>

<span class="sd">        See also:</span>
<span class="sd">            `gridcoords`</span>
<span class="sd">            `set_coords`</span>

<span class="sd">        Examples:</span>

<span class="sd">            Create an empty series with 3 slice dimensions:</span>

<span class="sd">            &gt;&gt;&gt; gridcoords = {</span>
<span class="sd">            ...     &#39;SliceLocation&#39;: np.arange(4),</span>
<span class="sd">            ...     &#39;FlipAngle&#39;: np.array([2, 15, 30]),</span>
<span class="sd">            ...     &#39;RepetitionTime&#39;: np.array([2.5, 5.0]),</span>
<span class="sd">            ... }</span>
<span class="sd">            &gt;&gt;&gt; series = db.empty_series()</span>
<span class="sd">            &gt;&gt;&gt; series.set_gridcoords(gridcoords)</span>

<span class="sd">            Get the coordinates as a mesh</span>

<span class="sd">            &gt;&gt;&gt; dims = tuple(gridcoords)</span>
<span class="sd">            &gt;&gt;&gt; coords = series.meshcoords(dims)</span>
<span class="sd">            &gt;&gt;&gt; coords[&#39;SliceLocation&#39;].shape</span>
<span class="sd">            (4, 3, 2)</span>
<span class="sd">            &gt;&gt;&gt; coords[&#39;FlipAngle&#39;][1,1,1]</span>
<span class="sd">            15</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">setcoords</span> <span class="o">=</span> <span class="n">_grid_to_coords</span><span class="p">(</span><span class="n">gridcoords</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_coords</span><span class="p">(</span><span class="n">setcoords</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span> <span class="nb">slice</span><span class="o">=</span><span class="nb">slice</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="o">**</span><span class="n">filters</span><span class="p">)</span></div>



<div class="viewcode-block" id="Series.gridcoords">
<a class="viewcode-back" href="../../../generated/api/dbdicom.Series.gridcoords.html#dbdicom.Series.gridcoords">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">gridcoords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;InstanceNumber&#39;</span><span class="p">,</span> <span class="p">),</span> <span class="nb">slice</span><span class="o">=</span><span class="p">{},</span> <span class="n">coords</span><span class="o">=</span><span class="p">{},</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">filters</span><span class="p">)</span><span class="o">-&gt;</span><span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;return a dictionary of grid coordinates.</span>

<span class="sd">        Args:</span>
<span class="sd">            dims (tuple): Attributes to be used as coordinates.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: dictionary of coordinates, one entry for each dimension.</span>

<span class="sd">        See also:</span>
<span class="sd">            `coords`</span>
<span class="sd">            `set_gridcoords`</span>

<span class="sd">        Examples:</span>

<span class="sd">            Create an empty series with 3 slice dimensions:</span>

<span class="sd">            &gt;&gt;&gt; gridcoords = {</span>
<span class="sd">            ...     &#39;SliceLocation&#39;: np.arange(4),</span>
<span class="sd">            ...     &#39;FlipAngle&#39;: np.array([2, 15, 30]),</span>
<span class="sd">            ...     &#39;RepetitionTime&#39;: np.array([2.5, 5.0]),</span>
<span class="sd">            ... }</span>
<span class="sd">            &gt;&gt;&gt; series = db.empty_series(gridcoords=gridcoords)</span>

<span class="sd">            Recover the grid coordinates:</span>

<span class="sd">            &gt;&gt;&gt; gridcoords_rec = series.gridcoords(tuple(gridcoords))</span>
<span class="sd">            &gt;&gt;&gt; coords_rec[&#39;SliceLocation&#39;]</span>
<span class="sd">            [0. 1. 2. 3.]</span>
<span class="sd">            &gt;&gt;&gt; coords_rec[&#39;FlipAngle&#39;]</span>
<span class="sd">            [ 2. 15. 30.]</span>
<span class="sd">            &gt;&gt;&gt; coords_rec[&#39;RepetitionTime&#39;]</span>
<span class="sd">            [2.5 5. ]</span>

<span class="sd">            Note an error is raised if the coordinates are not grid coordinates:</span>

<span class="sd">            &gt;&gt;&gt; coords = {</span>
<span class="sd">            ...     &#39;SliceLocation&#39;: np.array([0,1,2,0,1,2]),</span>
<span class="sd">            ...     &#39;FlipAngle&#39;: np.array([10,10,10,2,2,2]),</span>
<span class="sd">            ...     &#39;RepetitionTime&#39;: np.array([1,5,15,1,5,15]),</span>
<span class="sd">            ... }</span>
<span class="sd">            &gt;&gt;&gt; series = db.empty_series(coords)</span>

<span class="sd">            The coordinates form a proper mesh, so this works fine:</span>

<span class="sd">            &gt;&gt;&gt; coords = series.meshcoords(tuple(coords))</span>

<span class="sd">            But this raises an error:</span>

<span class="sd">            &gt;&gt;&gt; series.gridcoords(tuple(coords))</span>
<span class="sd">            ValueError: These are not grid coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">meshcoords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">(</span><span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="nb">slice</span><span class="o">=</span><span class="nb">slice</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="n">exclude</span><span class="p">,</span> <span class="o">**</span><span class="n">filters</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_meshcoords_to_grid</span><span class="p">(</span><span class="n">meshcoords</span><span class="p">)</span></div>

    

<div class="viewcode-block" id="Series.shape">
<a class="viewcode-back" href="../../../generated/api/dbdicom.Series.shape.html#dbdicom.Series.shape">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;InstanceNumber&#39;</span><span class="p">,</span> <span class="p">),</span> <span class="n">mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="nb">slice</span><span class="o">=</span><span class="p">{},</span> <span class="n">coords</span><span class="o">=</span><span class="p">{},</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">filters</span><span class="p">)</span><span class="o">-&gt;</span><span class="nb">tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the shape of the series along given dimensions.</span>

<span class="sd">        Args:</span>
<span class="sd">            dims (tuple, optional): Dimensions along which the shape is to be determined. If dims is not provided, the shape of the flattened series is returned. Defaults to None.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            tuple: one value for each element of dims.</span>
<span class="sd">        </span>
<span class="sd">        Raises:</span>
<span class="sd">            ValueError: if the shape in the specified dimensions is ambiguous (because the number of slices is not unique at each location) </span>
<span class="sd">            ValueError: if the shape in the specified dimensions is not well defined (because there is no slice at one or more locations).</span>

<span class="sd">        See also:</span>
<span class="sd">            `coords`</span>
<span class="sd">            `gridcoords`</span>
<span class="sd">            `spacing`</span>

<span class="sd">        Example:</span>

<span class="sd">            Create a zero-filled series with 3 dimensions.</span>

<span class="sd">            &gt;&gt;&gt; coords = {</span>
<span class="sd">            &gt;&gt;&gt;     &#39;SliceLocation&#39;: np.arange(4),</span>
<span class="sd">            &gt;&gt;&gt;     &#39;FlipAngle&#39;: [2, 15, 30],</span>
<span class="sd">            &gt;&gt;&gt;     &#39;RepetitionTime&#39;: [2.5, 5.0] }</span>
<span class="sd">            &gt;&gt;&gt; series = db.zeros((128,128,4,3,2), coords)</span>

<span class="sd">            Check the shape of a flattened series:</span>
<span class="sd">            &gt;&gt;&gt; series.shape()</span>
<span class="sd">            (24,)</span>

<span class="sd">            Check the shape along all 3 dimensions:</span>

<span class="sd">            &gt;&gt;&gt; dims = tuple(coords)</span>
<span class="sd">            &gt;&gt;&gt; series.shape(dims)</span>
<span class="sd">            (4, 3, 2)</span>

<span class="sd">            Swap the first two dimensions:</span>

<span class="sd">            &gt;&gt;&gt; series.shape((dims[1], dims[0], dims[2]))</span>
<span class="sd">            (3, 4, 2)</span>

<span class="sd">            Determine the shape along another DICOM attribute:</span>

<span class="sd">            &gt;&gt;&gt; series.shape((&#39;FlipAngle&#39;, &#39;InstanceNumber&#39;))</span>
<span class="sd">            (3, 8)</span>

<span class="sd">            The shape of an empty series is zero along any dimension:</span>

<span class="sd">            &gt;&gt;&gt; series.new_sibling().shape(dims)</span>
<span class="sd">            (0, 0, 0)</span>

<span class="sd">            If one or more of the dimensions is not defined in the header, this raises an error:</span>

<span class="sd">            &gt;&gt;&gt; series.shape((&#39;FlipAngle&#39;, &#39;Gobbledigook&#39;))</span>
<span class="sd">            ValueError: series shape is not well defined in dimensions (FlipAngle, Gobbledigook, )</span>
<span class="sd">            --&gt; Some of the dimensions are not defined in the header.</span>
<span class="sd">            --&gt; Hint: use Series.value() to find the undefined values.</span>

<span class="sd">            An error is also raised if the values are defined, but are not unique. In this case, all acquisition times are the same so this raises an error:</span>

<span class="sd">            &gt;&gt;&gt; series.shape((&#39;FlipAngle&#39;, &#39;AcquisitionTime&#39;))</span>
<span class="sd">            ValueError: series shape is ambiguous in dimensions (FlipAngle, AcquisitionTime, )</span>
<span class="sd">            --&gt; Multiple slices exist at some or all locations.</span>
<span class="sd">            --&gt; Hint: use Series.unique() to list the values at all locations.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="p">(</span><span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="nb">slice</span><span class="o">=</span><span class="nb">slice</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="n">exclude</span><span class="p">,</span> <span class="o">**</span><span class="n">filters</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">frames</span><span class="o">.</span><span class="n">shape</span></div>



<div class="viewcode-block" id="Series.unique">
<a class="viewcode-back" href="../../../generated/api/dbdicom.Series.unique.html#dbdicom.Series.unique">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">unique</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">tags</span><span class="p">,</span> <span class="n">sortby</span><span class="o">=</span><span class="p">(),</span> <span class="nb">slice</span><span class="o">=</span><span class="p">{},</span> <span class="n">coords</span><span class="o">=</span><span class="p">{},</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_locs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">filters</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the unique values of an attribute, sorted by any number of variables.</span>

<span class="sd">        Args:</span>
<span class="sd">            tag: either a keyword string or a (group, element) tag of a DICOM data element.</span>
<span class="sd">            sortby (tuple, optional): Dimensions of the resulting array. If *sortby* is not provided, then an array of unique values is returned.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: a sorted array of unique values of the attribute, with dimensions as specified by *dims*. If *dims* is provided, the result has the dimensions of *dims* and each element of the array is an array unique values.</span>

<span class="sd">        See also:</span>
<span class="sd">            `value`</span>
<span class="sd">            `unique_affines`</span>
<span class="sd">            `coords`</span>
<span class="sd">            `gridcoords`</span>

<span class="sd">        Example:</span>
<span class="sd">            Create a zero-filled series with 3 slice dimensions:</span>

<span class="sd">            &gt;&gt;&gt; loc = np.arange(4)</span>
<span class="sd">            &gt;&gt;&gt; fa = [2, 15, 30]</span>
<span class="sd">            &gt;&gt;&gt; tr = [2.5, 5.0]</span>
<span class="sd">            &gt;&gt;&gt; coords = {</span>
<span class="sd">            ...     &#39;SliceLocation&#39;: np.arange(4),</span>
<span class="sd">            ...     &#39;FlipAngle&#39;: [2, 15, 30],</span>
<span class="sd">            ...     &#39;RepetitionTime&#39;: [2.5, 5.0] }</span>
<span class="sd">            &gt;&gt;&gt; series = db.zeros((128,128,8,3,2), coords)</span>

<span class="sd">            Recover the unique values of any coordinate, such as the flip angle:</span>

<span class="sd">            &gt;&gt;&gt; series.value(&#39;FlipAngle&#39;)</span>
<span class="sd">            [ 2. 15. 30.]</span>

<span class="sd">            List the flip angles for each slice location separately:</span>

<span class="sd">            &gt;&gt;&gt; fa = series.unique(&#39;FlipAngle&#39;, sortby=(&#39;SliceLocation&#39;, ))</span>
<span class="sd">            &gt;&gt;&gt; fa[0]</span>
<span class="sd">            [ 2. 15. 30.]</span>
<span class="sd">            &gt;&gt;&gt; fa[3]</span>
<span class="sd">            [ 2. 15. 30.]</span>

<span class="sd">            List the flip angles for each slice location and repetition time:</span>

<span class="sd">            &gt;&gt;&gt; fa = series.unique(&#39;FlipAngle&#39;, sortby=(&#39;SliceLocation&#39;, &#39;RepetitionTime&#39;))</span>
<span class="sd">            &gt;&gt;&gt; fa.shape</span>
<span class="sd">            (4, 2)</span>
<span class="sd">            &gt;&gt;&gt; fa[1,1]</span>
<span class="sd">            [ 2. 15. 30.]</span>

<span class="sd">            Getting the values for a non-existing attribute produces an empty array:</span>

<span class="sd">            &gt;&gt;&gt; gbbl = series.unique(&#39;Gobbledigook&#39;)</span>
<span class="sd">            &gt;&gt;&gt; gbbl.size</span>
<span class="sd">            0</span>
<span class="sd">            &gt;&gt;&gt; gbbl.shape</span>
<span class="sd">            (0,)</span>

<span class="sd">            Getting a non-existing attribute for each slice location produces an array of the expected shape, where each element is an empty array:</span>

<span class="sd">            &gt;&gt;&gt; gbbl = series.unique(&#39;Gobbledigook&#39;, sortby=(&#39;SliceLocation&#39;,))</span>
<span class="sd">            &gt;&gt;&gt; gbbl.shape</span>
<span class="sd">            (4,)</span>
<span class="sd">            &gt;&gt;&gt; gbbl.size</span>
<span class="sd">            4</span>
<span class="sd">            &gt;&gt;&gt; gbbl[-1].size</span>
<span class="sd">            0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If no sorting is required, return an array of unique values</span>

        <span class="n">vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">tags</span><span class="o">+</span><span class="n">sortby</span><span class="p">),</span> <span class="nb">slice</span><span class="o">=</span><span class="nb">slice</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="n">exclude</span><span class="p">,</span> <span class="o">**</span><span class="n">filters</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sortby</span> <span class="o">==</span> <span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">uv</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="n">vals</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">uv</span><span class="p">)</span>
            <span class="n">uvals</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">:</span>
                <span class="n">uv</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">v</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span>
                <span class="n">uvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">uv</span><span class="p">))</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">uvals</span><span class="p">)</span>
        
        <span class="c1"># Create a flat location array</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sortby</span><span class="p">)):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span><span class="o">+</span><span class="n">k</span><span class="p">]</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">v</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span>
            <span class="n">loc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="nb">tuple</span><span class="p">(</span><span class="n">loc</span><span class="p">),</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">loc</span><span class="p">]</span>

        <span class="c1"># Build an array of unique values at each location and each tag</span>
        <span class="n">uvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">tags</span><span class="p">),</span> <span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span><span class="o">+</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="n">loc</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sortby</span><span class="p">)):</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="n">ind</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span><span class="o">+</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="n">loc</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tags</span><span class="p">)):</span>
                <span class="n">vti</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">ind</span><span class="p">]</span>
                <span class="n">vti</span> <span class="o">=</span> <span class="n">vti</span><span class="p">[</span><span class="n">vti</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span>
                <span class="n">uvals</span><span class="p">[</span><span class="n">t</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">vti</span><span class="p">)</span>

        <span class="c1"># Refactor to return values</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">uvals</span> <span class="o">=</span> <span class="n">uvals</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">uvals</span> <span class="o">=</span> <span class="p">[</span><span class="n">uvals</span><span class="p">[</span><span class="n">t</span><span class="p">,:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tags</span><span class="p">))]</span>
            <span class="n">uvals</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">uvals</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_locs</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">loc</span><span class="p">]</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span>  
            <span class="k">return</span> <span class="n">uvals</span><span class="p">,</span> <span class="n">loc</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">uvals</span></div>

    

<div class="viewcode-block" id="Series.pixel_values">
<a class="viewcode-back" href="../../../generated/api/dbdicom.Series.pixel_values.html#dbdicom.Series.pixel_values">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">pixel_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;InstanceNumber&#39;</span><span class="p">,</span> <span class="p">),</span> <span class="n">return_coords</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="nb">slice</span><span class="o">=</span><span class="p">{},</span> <span class="n">coords</span><span class="o">=</span><span class="p">{},</span> <span class="o">**</span><span class="n">filters</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a numpy.ndarray with pixel data.</span>

<span class="sd">        Args:</span>
<span class="sd">            dims (tuple, optional): Dimensions of the result, as a tuple of valid DICOM tags of any length. If *dims* is not provided, pixel values are ordered by instance number. Defaults to None.</span>
<span class="sd">            inds (dict, optional): Dictionary with indices to retrieve a slice of the entire array. Defaults to None.</span>
<span class="sd">            select (dict, optional): A dictionary of values for DICOM attributes to filter the result. By default the data are not filtered.</span>
<span class="sd">            filters (dict, optional): keyword arguments to filter the data by value of DICOM attributes.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: pixel data. The number of dimensions will be 2 plus the number of elements in *dim*. The first two indices will enumerate (column, row) indices in the slice, the other dimensions are as specified by the *dims* argument. </span>
<span class="sd">            </span>
<span class="sd">            The function returns an empty array when no data are found at the specified locations.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Indices must be in the dimensions provided. If *ind* is set but keys are not part of *dims*.</span>
<span class="sd">            ValueError: if the images are different shapes.</span>

<span class="sd">        See also:</span>
<span class="sd">            `set_pixel_values`</span>

<span class="sd">        Example:</span>
<span class="sd">            Create a zero-filled array with 3 slice dimensions:</span>

<span class="sd">            &gt;&gt;&gt; coords = {</span>
<span class="sd">            ...    &#39;SliceLocation&#39;: 10*np.arange(4),</span>
<span class="sd">            ...    &#39;FlipAngle&#39;: np.array([2, 15, 30]),</span>
<span class="sd">            ...    &#39;RepetitionTime&#39;: np.array([2.5, 5.0]),</span>
<span class="sd">            ... }</span>
<span class="sd">            &gt;&gt;&gt; zeros = db.zeros((128,64,4,3,2), coords)</span>

<span class="sd">            Retrieve the pixel array of the series:</span>

<span class="sd">            &gt;&gt;&gt; dims = tuple(coords)</span>
<span class="sd">            &gt;&gt;&gt; array = zeros.pixel_values(dims)</span>
<span class="sd">            &gt;&gt;&gt; array.shape</span>
<span class="sd">            (128, 64, 4, 3, 2)</span>

<span class="sd">            To retrieve an array containing only the data with flip angle 15:</span>

<span class="sd">            &gt;&gt;&gt; array = zeros.pixel_values(dims, FlipAngle=15)</span>
<span class="sd">            &gt;&gt;&gt; array.shape</span>
<span class="sd">            (128, 64, 4, 1, 2)</span>

<span class="sd">            If no data fit the requirement, and empty array is returned:</span>

<span class="sd">            &gt;&gt;&gt; array = zeros.pixel_values(dims, FlipAngle=15)</span>
<span class="sd">            &gt;&gt;&gt; array.size</span>
<span class="sd">            0</span>

<span class="sd">            Multiple possible values can be specified as an array:</span>

<span class="sd">            &gt;&gt;&gt; array = zeros.pixel_values(dims, FlipAngle=np.array([15,30]))</span>
<span class="sd">            &gt;&gt;&gt; array.shape</span>
<span class="sd">            (128, 64, 4, 2, 2)</span>

<span class="sd">            And multiple filters can be specified by adding keyword arguments. The following returns an array of pixel values with flip angle of 15 or 30, and slice location of 10 or 20:</span>

<span class="sd">            &gt;&gt;&gt; array = zeros.pixel_values(dims, FlipAngle=np.array([15,30]), SliceLocation=np.array([10,20]))</span>
<span class="sd">            &gt;&gt;&gt; array.shape</span>
<span class="sd">            (128, 64, 2, 2, 2)</span>

<span class="sd">            The filters can be any DICOM attribute:</span>

<span class="sd">            &gt;&gt;&gt; array = zeros.pixel_values(dims, AcquisitionTime=0)</span>
<span class="sd">            &gt;&gt;&gt; array.size</span>
<span class="sd">            0</span>

<span class="sd">            The filters can also be specified as a dictionary of values:</span>

<span class="sd">            &gt;&gt;&gt; array = zeros.pixel_values(dims, select={&#39;FlipAngle&#39;: 15})</span>
<span class="sd">            &gt;&gt;&gt; array.shape</span>
<span class="sd">            (128, 64, 4, 1, 2)</span>

<span class="sd">            Since keywords need to be strings in python, this is the only way to specify filters with (group, element) tags:</span>

<span class="sd">            &gt;&gt;&gt; array = zeros.pixel_values(dims, select={(0x0018, 0x1314): 15})</span>
<span class="sd">            &gt;&gt;&gt; array.shape</span>
<span class="sd">            (128, 64, 4, 1, 2)</span>

<span class="sd">            Using the *inds* argument, the pixel array can be indexed to avoid reading a large array if only a subarray is required:</span>

<span class="sd">            &gt;&gt;&gt; array = zeros.pixel_values(dims, inds={&#39;FlipAngle&#39;: 1})</span>
<span class="sd">            &gt;&gt;&gt; array.shape</span>
<span class="sd">            (128, 64, 4, 1, 2)</span>

<span class="sd">            Note unlike filters defind by *value*, the indices must be provided in the dimensions of the array. If not, a `ValueError` is raised:</span>

<span class="sd">            &gt;&gt;&gt; zeros.pixel_values(dims, inds={&#39;AcquisitionTime&#39;:0})</span>
<span class="sd">            ValueError: Indices must be in the dimensions provided.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">(</span><span class="n">dims</span><span class="p">,)</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">return_coords</span><span class="o">=</span><span class="n">return_coords</span><span class="p">,</span> <span class="nb">slice</span><span class="o">=</span><span class="nb">slice</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="o">**</span><span class="n">filters</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_coords</span><span class="p">:</span>
            <span class="n">frames</span><span class="p">,</span> <span class="n">fcoords</span> <span class="o">=</span> <span class="n">frames</span>
        <span class="k">if</span> <span class="n">frames</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">frames</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">return_coords</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">values</span><span class="p">,</span> <span class="n">fcoords</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">values</span>
        
        <span class="c1"># Read values</span>
        <span class="n">fshape</span> <span class="o">=</span> <span class="n">frames</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="n">frames</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">frame</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frames</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">f</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">frames</span><span class="p">),</span> <span class="s1">&#39;Reading pixel values..&#39;</span><span class="p">)</span>
            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">get_pixel_array</span><span class="p">())</span>

        <span class="c1"># Check that all matrix sizes are the same</span>
        <span class="n">vshape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">])</span>
        <span class="n">vshape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">vshape</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vshape</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Cannot extract an array of pixel values - not all frames have the same matrix size.&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        
        <span class="c1"># Create the array</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">fshape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_coords</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">values</span><span class="p">,</span> <span class="n">fcoords</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">values</span></div>

    

<div class="viewcode-block" id="Series.set_pixel_values">
<a class="viewcode-back" href="../../../generated/api/dbdicom.Series.set_pixel_values.html#dbdicom.Series.set_pixel_values">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_pixel_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">dims</span><span class="p">:</span><span class="nb">tuple</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">slice</span><span class="o">=</span><span class="p">{},</span> <span class="n">coords</span><span class="o">=</span><span class="p">{},</span> <span class="o">**</span><span class="n">filters</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set a numpy.ndarray with pixel data.</span>

<span class="sd">        Args:</span>
<span class="sd">            dims (tuple, optional): Dimensions of the pixel values, as a tuple of valid DICOM tags of any length. If *dims* is not provided, pixel values are ordered by instance number. Defaults to None.</span>
<span class="sd">            inds (dict, optional): Dictionary with indices to set a slice of the entire array. Defaults to None.</span>
<span class="sd">            select (dict, optional): A dictionary of values for DICOM attributes to set specific frames. </span>
<span class="sd">            filters (dict, optional): keyword arguments to set specific frames.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: if the values are the incorrect shape for the dimensions.</span>

<span class="sd">        See also:</span>
<span class="sd">            `pixel_values`</span>

<span class="sd">        Example:</span>
<span class="sd">            Create a zero-filled array with 3 slice dimensions:</span>

<span class="sd">            &gt;&gt;&gt; coords = {</span>
<span class="sd">            ...    &#39;SliceLocation&#39;: 10*np.arange(4),</span>
<span class="sd">            ...    &#39;FlipAngle&#39;: np.array([2, 15, 30]),</span>
<span class="sd">            ...    &#39;RepetitionTime&#39;: np.array([2.5, 5.0]),</span>
<span class="sd">            ... }</span>
<span class="sd">            &gt;&gt;&gt; zeros = db.zeros((128,64,4,3,2), coords)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">slice</span> <span class="o">!=</span> <span class="p">{}:</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">coords</span> <span class="o">!=</span> <span class="p">{}:</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;InstanceNumber&#39;</span><span class="p">,</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">(</span><span class="n">dims</span><span class="p">,)</span>
        <span class="c1"># Get frames to set:</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="nb">slice</span><span class="o">=</span><span class="nb">slice</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="o">**</span><span class="n">filters</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">frames</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">slice</span> <span class="o">!=</span> <span class="p">{}:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">gridcoords</span><span class="o">=</span><span class="nb">slice</span><span class="p">)</span>
                <span class="n">frames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Cannot set values to an empty series. Use Series.expand() to create empty frames first, or set the loc keyword to define coordinates for the new frames.&#39;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span> <span class="o">!=</span> <span class="n">frames</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;The size of the pixel value array is different from the size of the series.&#39;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">The pixel array has shape &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;but the series has shape &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">frames</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="n">frames</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>
        <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">frame</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frames</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">f</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">frames</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="s1">&#39;Writing pixel values..&#39;</span><span class="p">)</span>
            <span class="n">frame</span><span class="o">.</span><span class="n">set_pixel_array</span><span class="p">(</span><span class="n">values</span><span class="p">[:,:,</span><span class="n">f</span><span class="p">])</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">volume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">volumes</span><span class="p">(</span><span class="n">stack</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">volumes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>  <span class="n">dims</span><span class="o">=</span><span class="s1">&#39;SliceLocation&#39;</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">stack</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return vreg volumes for each frame, or stacked&quot;&quot;&quot;</span>

        <span class="n">frames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">)</span>
        <span class="n">vols</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">volume</span><span class="p">()</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">frames</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
        <span class="n">vols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">vols</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">frames</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">stack</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">vols</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">vols</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">vols</span> <span class="o">=</span> <span class="n">vols</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">vols_stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">vols</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">vstack</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">vols</span><span class="p">[:,</span><span class="n">k</span><span class="p">],</span> <span class="n">prec</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">vols_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vstack</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">vols_stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">vols_stack</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">set_volumes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">volumes</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="s1">&#39;SliceLocation&#39;</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

        <span class="c1"># Convert affines to arrays if needed</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">volumes</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">volumes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">volumes</span><span class="p">)</span>
        
        <span class="c1"># Get frames</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">)</span>

        <span class="c1"># One affine for each frame</span>
        <span class="k">if</span> <span class="n">volumes</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">frames</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="n">volumes</span> <span class="o">=</span> <span class="n">volumes</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frames</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">frames</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="s1">&#39;Setting affines.. &#39;</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">set_volume</span><span class="p">(</span><span class="n">volumes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="c1"># Different number of affines and frames</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># A volumetric series</span>
            <span class="k">if</span> <span class="n">frames</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">volumes</span> <span class="o">=</span> <span class="n">volumes</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">volumes</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Cannot set volumes. A volume can only &quot;</span>
                        <span class="s2">&quot;have one element.&quot;</span><span class="p">)</span>
                <span class="n">volumes</span> <span class="o">=</span> <span class="n">volumes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">frames</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">z</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frames</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">z</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">frames</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="s1">&#39;Setting volumes.. &#39;</span><span class="p">)</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">set_volume</span><span class="p">(</span><span class="n">volumes</span><span class="p">[</span><span class="n">z</span><span class="p">])</span>

            <span class="c1"># Multislice affine replicated across all times</span>
            <span class="k">elif</span> <span class="n">volumes</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">frames</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">frames</span> <span class="o">=</span> <span class="n">frames</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">frames</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">volumes</span> <span class="o">=</span> <span class="n">volumes</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">nz</span><span class="p">,</span> <span class="n">nt</span> <span class="o">=</span> <span class="n">frames</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">cnt</span><span class="o">=</span><span class="mi">0</span>
                <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nz</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
                        <span class="n">cnt</span><span class="o">+=</span><span class="mi">1</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">nt</span><span class="o">*</span><span class="n">nz</span><span class="p">,</span> <span class="s1">&#39;Setting volumes.. &#39;</span><span class="p">)</span>
                        <span class="n">frames</span><span class="p">[</span><span class="n">z</span><span class="p">,</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">set_volume</span><span class="p">(</span><span class="n">volumes</span><span class="p">[</span><span class="n">z</span><span class="p">])</span>

            <span class="c1"># One volume replicated across all times</span>
            <span class="k">elif</span> <span class="n">volumes</span><span class="o">.</span><span class="n">size</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">frames</span> <span class="o">=</span> <span class="n">frames</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">frames</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">nz</span><span class="p">,</span> <span class="n">nt</span> <span class="o">=</span> <span class="n">frames</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">volumes</span> <span class="o">=</span> <span class="n">volumes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">nz</span><span class="p">)</span>
                <span class="n">cnt</span><span class="o">=</span><span class="mi">0</span>
                <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nz</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
                        <span class="n">cnt</span><span class="o">+=</span><span class="mi">1</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">nt</span><span class="o">*</span><span class="n">nz</span><span class="p">,</span> <span class="s1">&#39;Setting volumes.. &#39;</span><span class="p">)</span>
                        <span class="n">frames</span><span class="p">[</span><span class="n">z</span><span class="p">,</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">set_volume</span><span class="p">(</span><span class="n">volumes</span><span class="p">[</span><span class="n">z</span><span class="p">])</span>

            <span class="c1"># Volume for each time point</span>
            <span class="k">elif</span> <span class="n">volumes</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">frames</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">frames</span> <span class="o">=</span> <span class="n">frames</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">frames</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">volumes</span> <span class="o">=</span> <span class="n">volumes</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">nz</span><span class="p">,</span> <span class="n">nt</span> <span class="o">=</span> <span class="n">frames</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">cnt</span><span class="o">=</span><span class="mi">0</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
                    <span class="n">volumes_t</span> <span class="o">=</span> <span class="n">volumes</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">nz</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">z</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frames</span><span class="p">[:,</span><span class="n">t</span><span class="p">]):</span>
                        <span class="n">cnt</span><span class="o">+=</span><span class="mi">1</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">nt</span><span class="o">*</span><span class="n">nz</span><span class="p">,</span> <span class="s1">&#39;Setting volumes.. &#39;</span><span class="p">)</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">set_volume</span><span class="p">(</span><span class="n">volumes_t</span><span class="p">[</span><span class="n">z</span><span class="p">])</span>

            <span class="c1"># Incompatible shapes</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot set volumes. The volume array has an incompatible &quot;</span>
                    <span class="s2">&quot;shape or size.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>
    

    <span class="k">def</span><span class="w"> </span><span class="nf">affines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>  <span class="n">dims</span><span class="o">=</span><span class="s1">&#39;SliceLocation&#39;</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">stack</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return affines for each frame&quot;&quot;&quot;</span>

        <span class="n">frames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">)</span>
        <span class="n">affines</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">affine</span><span class="p">()</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">frames</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
        <span class="n">affines</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">affines</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">frames</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">stack</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">affines</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">affines</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">affines</span> <span class="o">=</span> <span class="n">affines</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">nt</span> <span class="o">=</span> <span class="n">affines</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">affines_stack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
            <span class="n">affines_stack</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">image_utils</span><span class="o">.</span><span class="n">stack_affines</span><span class="p">(</span><span class="n">affines</span><span class="p">[:,</span><span class="n">t</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">affines_stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">affines_stack</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">set_affines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">affines</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="s1">&#39;SliceLocation&#39;</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

        <span class="c1"># Convert affines to arrays if needed</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">affines</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">aff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
            <span class="n">aff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">affines</span>
            <span class="n">affines</span> <span class="o">=</span> <span class="n">aff</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">affines</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">aff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">affines</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">affines</span><span class="p">):</span>
                <span class="n">aff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
            <span class="n">affines</span> <span class="o">=</span> <span class="n">aff</span>
        
        <span class="c1"># Get frames</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">)</span>

        <span class="c1"># One affine for each frame</span>
        <span class="k">if</span> <span class="n">affines</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">frames</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="n">affines</span> <span class="o">=</span> <span class="n">affines</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frames</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">frames</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="s1">&#39;Setting affines.. &#39;</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">set_affine</span><span class="p">(</span><span class="n">affines</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="c1"># Different number of affines and frames</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># A volumetric series</span>
            <span class="k">if</span> <span class="n">frames</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">affines</span> <span class="o">=</span> <span class="n">affines</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">affines</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Cannot set affines. A volumetric affine can only &quot;</span>
                        <span class="s2">&quot;have one element.&quot;</span><span class="p">)</span>
                <span class="n">affines</span> <span class="o">=</span> <span class="n">image_utils</span><span class="o">.</span><span class="n">unstack_affine</span><span class="p">(</span><span class="n">affines</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">frames</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">z</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frames</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">z</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">frames</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="s1">&#39;Setting affines.. &#39;</span><span class="p">)</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">set_affine</span><span class="p">(</span><span class="n">affines</span><span class="p">[</span><span class="n">z</span><span class="p">])</span>

            <span class="c1"># Multislice affine replicated across all times</span>
            <span class="k">elif</span> <span class="n">affines</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">frames</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">frames</span> <span class="o">=</span> <span class="n">frames</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">frames</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">affines</span> <span class="o">=</span> <span class="n">affines</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">nz</span><span class="p">,</span> <span class="n">nt</span> <span class="o">=</span> <span class="n">frames</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">cnt</span><span class="o">=</span><span class="mi">0</span>
                <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nz</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
                        <span class="n">cnt</span><span class="o">+=</span><span class="mi">1</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">nt</span><span class="o">*</span><span class="n">nz</span><span class="p">,</span> <span class="s1">&#39;Setting affines.. &#39;</span><span class="p">)</span>
                        <span class="n">frames</span><span class="p">[</span><span class="n">z</span><span class="p">,</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">set_affine</span><span class="p">(</span><span class="n">affines</span><span class="p">[</span><span class="n">z</span><span class="p">])</span>

            <span class="c1"># One volume affine replicated across all times</span>
            <span class="k">elif</span> <span class="n">affines</span><span class="o">.</span><span class="n">size</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">frames</span> <span class="o">=</span> <span class="n">frames</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">frames</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">nz</span><span class="p">,</span> <span class="n">nt</span> <span class="o">=</span> <span class="n">frames</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">affines</span> <span class="o">=</span> <span class="n">image_utils</span><span class="o">.</span><span class="n">unstack_affine</span><span class="p">(</span><span class="n">affines</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nz</span><span class="p">)</span>
                <span class="n">cnt</span><span class="o">=</span><span class="mi">0</span>
                <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nz</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
                        <span class="n">cnt</span><span class="o">+=</span><span class="mi">1</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">nt</span><span class="o">*</span><span class="n">nz</span><span class="p">,</span> <span class="s1">&#39;Setting affines.. &#39;</span><span class="p">)</span>
                        <span class="n">frames</span><span class="p">[</span><span class="n">z</span><span class="p">,</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">set_affine</span><span class="p">(</span><span class="n">affines</span><span class="p">[</span><span class="n">z</span><span class="p">])</span>

            <span class="c1"># Volume affine for each time point</span>
            <span class="k">elif</span> <span class="n">affines</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">frames</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">frames</span> <span class="o">=</span> <span class="n">frames</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">frames</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">affines</span> <span class="o">=</span> <span class="n">affines</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">nz</span><span class="p">,</span> <span class="n">nt</span> <span class="o">=</span> <span class="n">frames</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">cnt</span><span class="o">=</span><span class="mi">0</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
                    <span class="n">affines_t</span> <span class="o">=</span> <span class="n">image_utils</span><span class="o">.</span><span class="n">unstack_affine</span><span class="p">(</span><span class="n">affines</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="n">nz</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">z</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frames</span><span class="p">[:,</span><span class="n">t</span><span class="p">]):</span>
                        <span class="n">cnt</span><span class="o">+=</span><span class="mi">1</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">nt</span><span class="o">*</span><span class="n">nz</span><span class="p">,</span> <span class="s1">&#39;Setting affines.. &#39;</span><span class="p">)</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">set_affine</span><span class="p">(</span><span class="n">affines_t</span><span class="p">[</span><span class="n">z</span><span class="p">])</span>

            <span class="c1"># Incompatible shapes</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot set affines. The affine array has an incompatible &quot;</span>
                    <span class="s2">&quot;shape or size.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>


    <span class="c1"># TODO: make obsolete (ignores dimensions or multi-volume series)</span>
<div class="viewcode-block" id="Series.affine">
<a class="viewcode-back" href="../../../generated/api/dbdicom.Series.affine.html#dbdicom.Series.affine">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">slice</span><span class="o">=</span><span class="p">{},</span> <span class="n">coords</span><span class="o">=</span><span class="p">{},</span> <span class="o">**</span><span class="n">filters</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the affine of the Series.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: if the DICOM file is corrupted</span>
<span class="sd">            ValueError: if the affine is not unique.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: affine matrix as a 4x4 numpy array.</span>

<span class="sd">        See also:</span>
<span class="sd">            `set_affine`</span>
<span class="sd">            `unique_affines`</span>

<span class="sd">        Example:</span>
<span class="sd">            Check that the default affine is the identity:</span>

<span class="sd">            &gt;&gt;&gt; zeros = db.zeros((128,128,10))</span>
<span class="sd">            &gt;&gt;&gt; zeros.affine()</span>
<span class="sd">            [[1., 0., 0., 0.],</span>
<span class="sd">             [0., 1., 0., 0.],</span>
<span class="sd">             [0., 0., 1., 0.],</span>
<span class="sd">             [0., 0., 0., 1.]]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Read values</span>
        <span class="n">tags</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;ImageOrientationPatient&#39;</span><span class="p">,</span> <span class="s1">&#39;ImagePositionPatient&#39;</span><span class="p">,</span> <span class="s1">&#39;PixelSpacing&#39;</span><span class="p">,</span> <span class="s1">&#39;SliceThickness&#39;</span><span class="p">,</span> <span class="p">)</span>
        <span class="n">orientation</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">spacing</span><span class="p">,</span> <span class="n">thick</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="o">*</span><span class="n">tags</span><span class="p">,</span> <span class="nb">slice</span><span class="o">=</span><span class="nb">slice</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="o">**</span><span class="n">filters</span><span class="p">)</span>

        <span class="c1"># Single slice</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">image_utils</span><span class="o">.</span><span class="n">affine_matrix</span><span class="p">(</span><span class="n">orientation</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">spacing</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">thick</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="c1"># Multiple orientations - raise error</span>
        <span class="n">orientation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">orientation</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">orientation</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;The series has multiple affines. &#39;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Use Series.unique_affines() to return an array of unique affines.&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">orientation</span> <span class="o">=</span> <span class="n">orientation</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Multiple pixel spacings - raise error</span>
        <span class="n">spacing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">spacing</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spacing</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;The series has multiple pixel spacings. &#39;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Affine array of the series is not well defined.&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>     
        <span class="n">spacing</span> <span class="o">=</span> <span class="n">spacing</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
        <span class="c1"># All the same slice locations</span>
        <span class="n">upos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">upos</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">image_utils</span><span class="o">.</span><span class="n">affine_matrix</span><span class="p">(</span><span class="n">orientation</span><span class="p">,</span> <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">spacing</span><span class="p">,</span> <span class="n">thick</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="c1"># Different slice locations but not all different - raise error</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">upos</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">):</span> 
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Some frames have the same ImagePositionPatient. &#39;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Affine matrix of the series is not well defined.&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>  
        
        <span class="k">return</span> <span class="n">image_utils</span><span class="o">.</span><span class="n">affine_matrix_multislice</span><span class="p">(</span><span class="n">orientation</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">spacing</span><span class="p">)</span>   </div>


    <span class="c1"># TODO: amke obsolete - does not handle dimensions or multislice vs volume</span>
<div class="viewcode-block" id="Series.set_affine">
<a class="viewcode-back" href="../../../generated/api/dbdicom.Series.set_affine.html#dbdicom.Series.set_affine">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">affine</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;InstanceNumber&#39;</span><span class="p">,),</span> <span class="nb">slice</span><span class="o">=</span><span class="p">{},</span> <span class="n">coords</span><span class="o">=</span><span class="p">{},</span> <span class="n">multislice</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">filters</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the affine matrix of a series.</span>

<span class="sd">        The affine is defined as a 4x4 numpy array with bottom row [0,0,0,1]. The final column represents the position of the top right hand corner of the first slice. The first three columns represent rotation and scaling with respect to the axes of the reference frame.</span>

<span class="sd">        Args:</span>
<span class="sd">            affine (numpy.ndarray): 4x4 numpy array </span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: if the series is empty. The information of the affine matrix is stored in the header and can not be stored in an empty series.</span>

<span class="sd">        See also:</span>
<span class="sd">            `affine`</span>
<span class="sd">            `unique_affines`</span>

<span class="sd">        Example:</span>
<span class="sd">            Create a series with unit affine array:</span>

<span class="sd">            &gt;&gt;&gt; zeros = db.zeros((128,128,10))</span>
<span class="sd">            &gt;&gt;&gt; zeros.affine()</span>
<span class="sd">            [[1., 0., 0., 0.],</span>
<span class="sd">             [0., 1., 0., 0.],</span>
<span class="sd">             [0., 0., 1., 0.],</span>
<span class="sd">             [0., 0., 0., 1.]]</span>

<span class="sd">            Rotate the volume over 90 degrees in the xy-plane:</span>

<span class="sd">            &gt;&gt;&gt; affine = np.array([</span>
<span class="sd">            ...     [1., 0., 0., 0.],</span>
<span class="sd">            ...     [0., 1., 0., 0.],</span>
<span class="sd">            ...     [0., 0., 1., 0.],</span>
<span class="sd">            ...     [0., 0., 0., 1.],</span>
<span class="sd">            ... ]) </span>
<span class="sd">            &gt;&gt;&gt; zeros.set_affine(affine)</span>

<span class="sd">            Apart from the rotation, also change the resolution to (3mm, 3mm, 1.5mm):</span>

<span class="sd">            &gt;&gt;&gt; affine = np.array([</span>
<span class="sd">            ...     [0., -3., 0., 0.],</span>
<span class="sd">            ...     [3., 0., 0., 0.],</span>
<span class="sd">            ...     [0., 0., 1.5, 0.],</span>
<span class="sd">            ...     [0., 0., 0., 1.],</span>
<span class="sd">            ... ])  </span>
<span class="sd">            &gt;&gt;&gt; zeros.set_affine(affine)</span>

<span class="sd">            Now rotate, change resolution, and shift the top right hand corner of the lowest slice to position (-30mm, 20mm, 120mm):</span>

<span class="sd">            &gt;&gt;&gt; affine = np.array([</span>
<span class="sd">            ...     [0., -3., 0., -30.],</span>
<span class="sd">            ...     [3., 0., 0., 20.],</span>
<span class="sd">            ...     [0., 0., 1.5, 120.],</span>
<span class="sd">            ...     [0., 0., 0., 1.],</span>
<span class="sd">            ... ])  </span>
<span class="sd">            &gt;&gt;&gt; zeros.set_affine(affine)</span>

<span class="sd">            Note: changing the affine will affect multiple DICOM tags, such as slice location and image positions:</span>

<span class="sd">            &gt;&gt;&gt; zeros.SliceLocation</span>
<span class="sd">            [120.0, 121.5, 123.0, 124.5, 126.0, 127.5, 129.0, 130.5, 132.0, 133.5]</span>

<span class="sd">            In this case, since the slices are stacked in parallel to the z-axis, the slice location starts at the lower z-coordinate of 120mm and then increments slice-by-slice with the slice thickness of 1.5mm.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">frames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="p">(</span><span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span> <span class="nb">slice</span><span class="o">=</span><span class="nb">slice</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="o">**</span><span class="n">filters</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">frames</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Cannot set affine matrix in an empty series. Use Series.expand() to create empty frames first.&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    
        <span class="c1"># For each slice location, the slice position needs to be updated too</span>
        <span class="c1"># Need the coordinates of the vector parallel to the z-axis of the volume.</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">image_utils</span><span class="o">.</span><span class="n">dismantle_affine_matrix</span><span class="p">(</span><span class="n">affine</span><span class="p">)</span>
        <span class="n">ez</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="s1">&#39;SpacingBetweenSlices&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="s1">&#39;slice_cosine&#39;</span><span class="p">])</span>

        <span class="c1"># if multislice:</span>
        <span class="c1">#     slice_thickness = self.unique(&#39;SliceThickness&#39;)[0]</span>

        <span class="c1"># Set the affine slice-by-slice</span>
        <span class="n">affine_z</span> <span class="o">=</span> <span class="n">affine</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">z</span><span class="p">,</span> <span class="n">frame</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frames</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">z</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">frames</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="s1">&#39;Writing affine..&#39;</span><span class="p">)</span>
            <span class="n">affine_z</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">affine</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">z</span><span class="o">*</span><span class="n">ez</span>
            <span class="k">if</span> <span class="n">multislice</span><span class="p">:</span>
                <span class="n">thickness</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">SliceThickness</span>
            <span class="n">frame</span><span class="o">.</span><span class="n">affine_matrix</span> <span class="o">=</span> <span class="n">affine_z</span>
            <span class="k">if</span> <span class="n">multislice</span><span class="p">:</span>
                <span class="n">frame</span><span class="o">.</span><span class="n">SliceThickness</span> <span class="o">=</span> <span class="n">thickness</span></div>


        <span class="c1"># if multislice:</span>
        <span class="c1">#     self.set_values(slice_thickness,&#39;SliceThickness&#39;)</span>


    <span class="c1"># consider renaming copy() - but breaks backward compatibility - this is not a slice really</span>
<div class="viewcode-block" id="Series.extract">
<a class="viewcode-back" href="../../../generated/api/dbdicom.Series.extract.html#dbdicom.Series.extract">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">extract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">slice</span><span class="o">=</span><span class="p">{},</span> <span class="n">coords</span><span class="o">=</span><span class="p">{},</span> <span class="o">**</span><span class="n">filters</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a slice of the series by dimension values</span>

<span class="sd">        Args:</span>
<span class="sd">            coordinates (dict, optional): dictionary of tag:value pairs where the value is either a single value or an array of values.</span>
<span class="sd">            coords (dict): Provide coordinates for the slice, either as dimension=value pairs, or as a dictionary where the keys list the dimensions, and the values are provided as scalars, 1D or meshgrid arrays of coordinates. </span>

<span class="sd">        See also:</span>
<span class="sd">            `islice`</span>
<span class="sd">            `split_by`</span>

<span class="sd">        Example:</span>
<span class="sd">            Create a zero-filled array, describing 8 MRI images each measured at 3 flip angles and 2 repetition times:</span>

<span class="sd">            &gt;&gt;&gt; coords = {</span>
<span class="sd">            ...    &#39;SliceLocation&#39;: np.arange(8),</span>
<span class="sd">            ...    &#39;FlipAngle&#39;: [2, 15, 30],</span>
<span class="sd">            ...    &#39;RepetitionTime&#39;: [2.5, 5.0],</span>
<span class="sd">            ... }</span>
<span class="sd">            &gt;&gt;&gt; series = db.zeros((128,128,8,3,2), coords)</span>

<span class="sd">            Slice the series at flip angle 15:</span>

<span class="sd">            &gt;&gt;&gt; fa15 = series.slice(FlipAngle=15)</span>

<span class="sd">            Retrieve the array and check the dimensions:</span>

<span class="sd">            &gt;&gt;&gt; array = fa15.pixel_values(dims=tuple(coords))</span>
<span class="sd">            &gt;&gt;&gt; print(array.shape)</span>
<span class="sd">            (128, 128, 8, 1, 2)</span>

<span class="sd">            Multiple possible values can be specified as a list or np.ndarray:</span>

<span class="sd">            &gt;&gt;&gt; fa15 = series.slice(SliceLocation=[0,5], FlipAngle=15)</span>
<span class="sd">            &gt;&gt;&gt; array = fa15.pixel_values(dims=tuple(coords))</span>
<span class="sd">            &gt;&gt;&gt; print(array.shape)</span>
<span class="sd">            (128, 128, 2, 1, 2)</span>

<span class="sd">            Values can also be provided as a dictionary, which is useful for instance for private tags that do not have a keyword string. So the following are equivalent:</span>

<span class="sd">            &gt;&gt;&gt; fa15 = series.slice(SliceLocation=[0,5], FlipAngle=15)</span>
<span class="sd">            &gt;&gt;&gt; fa15 = series.slice({SliceLocation:[0,5], FlipAngle:15})</span>
<span class="sd">            &gt;&gt;&gt; fa15 = series.slice({(0x0020, 0x1041):[0,5], (0x0018, 0x1314):15})</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">frames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="p">(</span><span class="nb">slice</span><span class="o">=</span><span class="nb">slice</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="o">**</span><span class="n">filters</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_sibling</span><span class="p">()</span>
        <span class="c1"># result.adopt(frames) # faster but no progress bar</span>
        <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">frame</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frames</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">f</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">frames</span><span class="p">),</span> <span class="s1">&#39;Creating slice..&#39;</span><span class="p">)</span>
            <span class="n">frame</span><span class="o">.</span><span class="n">copy_to</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

        
    
<div class="viewcode-block" id="Series.split_by">
<a class="viewcode-back" href="../../../generated/api/dbdicom.Series.split_by.html#dbdicom.Series.split_by">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">split_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Split the series into multiple subseries based on keyword value.</span>

<span class="sd">        Args:</span>
<span class="sd">            keyword (str | tuple): A valid DICOM keyword or hexadecimal (group, element) tag.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: if an invalid or missing keyword is provided.</span>
<span class="sd">            ValueError: if all images have the same value for the keyword, so no subseries can be derived. An exception is raised rather than a copy of the series to avoid unnecessary copies being made. If that is the intention, use series.copy() instead.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: A list of ``Series`` instances, where each element has the same value of the given keyword.</span>

<span class="sd">        See Also:</span>
<span class="sd">            `slice`</span>
<span class="sd">            `islice`</span>

<span class="sd">        Example: </span>

<span class="sd">            Create a single-slice series with multiple flip angles and repetition times:</span>

<span class="sd">            &gt;&gt;&gt; coords = {</span>
<span class="sd">            ...    &#39;FlipAngle&#39;: [2, 15, 30],</span>
<span class="sd">            ...    &#39;RepetitionTime&#39;: [2.5, 7.5],</span>
<span class="sd">            ... }</span>
<span class="sd">            &gt;&gt;&gt; zeros = db.zeros((128, 128, 3, 2), coords)</span>
<span class="sd">            &gt;&gt;&gt; zeros.print()</span>
<span class="sd">            ---------- SERIES --------------</span>
<span class="sd">            Series 001 [New Series]</span>
<span class="sd">                Nr of instances: 6</span>
<span class="sd">                    MRImage 000001</span>
<span class="sd">                    MRImage 000002</span>
<span class="sd">                    MRImage 000003</span>
<span class="sd">                    MRImage 000004</span>
<span class="sd">                    MRImage 000005</span>
<span class="sd">                    MRImage 000006</span>
<span class="sd">            --------------------------------</span>

<span class="sd">            Splitting this series by FlipAngle now creates 3 new series in the same study, with 2 images each. By default the fixed value of the splitting attribute is written in the series description:</span>

<span class="sd">            &gt;&gt;&gt; FA = zeros.split_by(&#39;FlipAngle&#39;)</span>
<span class="sd">            &gt;&gt;&gt; zeros.study().print()</span>
<span class="sd">            ---------- STUDY ---------------</span>
<span class="sd">            Study New Study [None]</span>
<span class="sd">                Series 001 [New Series]</span>
<span class="sd">                    Nr of instances: 6</span>
<span class="sd">                Series 002 [New Series[FlipAngle = 2.0]]</span>
<span class="sd">                    Nr of instances: 2</span>
<span class="sd">                Series 003 [New Series[FlipAngle = 15.0]]</span>
<span class="sd">                    Nr of instances: 2</span>
<span class="sd">                Series 004 [New Series[FlipAngle = 30.0]]</span>
<span class="sd">                    Nr of instances: 2</span>
<span class="sd">            --------------------------------</span>

<span class="sd">            Check the flip angle of the split series:</span>
<span class="sd">            &gt;&gt;&gt; for series in FA: </span>
<span class="sd">            ...     print(series.FlipAngle)</span>
<span class="sd">            2.0</span>
<span class="sd">            15.0</span>
<span class="sd">            30.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Cannot split by &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> 
            <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;All frames have the same value.&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        
        <span class="n">desc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span><span class="o">.</span><span class="n">SeriesDescription</span> <span class="o">+</span> <span class="s1">&#39;[&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; = &#39;</span>
        <span class="n">split_series</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">:</span>
            <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="nb">slice</span><span class="o">=</span><span class="p">{</span><span class="n">tag</span><span class="p">:</span> <span class="n">v</span><span class="p">})</span>
            <span class="n">new</span><span class="o">.</span><span class="n">SeriesDescription</span> <span class="o">=</span> <span class="n">desc</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;]&#39;</span>
            <span class="n">split_series</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">split_series</span></div>

        

<div class="viewcode-block" id="Series.spacing">
<a class="viewcode-back" href="../../../generated/api/dbdicom.Series.spacing.html#dbdicom.Series.spacing">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">spacing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">-&gt;</span><span class="nb">tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;3D pixel spacing in mm</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple: (x-spacing, y-spacing, z-spacing)</span>

<span class="sd">        See also:</span>
<span class="sd">            `shape`</span>

<span class="sd">        Examples:</span>
<span class="sd">            Check the spacing of a digital reference object:</span>

<span class="sd">            &gt;&gt;&gt; series = db.dro.T1_mapping_vFATR()</span>
<span class="sd">            &gt;&gt;&gt; series.spacing()</span>
<span class="sd">            (15, 15, 20)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">affine</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">affine</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">column_spacing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">affine</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">row_spacing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">affine</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">slice_spacing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">affine</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">column_spacing</span><span class="p">,</span> <span class="n">row_spacing</span><span class="p">,</span> <span class="n">slice_spacing</span></div>



   

    <span class="k">def</span><span class="w"> </span><span class="nf">unique_affines</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the array of unique affine matrices.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: if the DICOM file is corrupted.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: array of 4x4 ndarrays with the unique affine matrices of the series.</span>

<span class="sd">        See also:</span>
<span class="sd">            `set_affine`</span>
<span class="sd">            `affine`</span>

<span class="sd">        Example:</span>
<span class="sd">            Check that the default affine is the identity:</span>

<span class="sd">            &gt;&gt;&gt; zeros = db.zeros((128,128,10))</span>
<span class="sd">            &gt;&gt;&gt; zeros.affine()</span>
<span class="sd">            [array([</span>
<span class="sd">                [1., 0., 0., 0.],</span>
<span class="sd">                [0., 1., 0., 0.],</span>
<span class="sd">                [0., 0., 1., 0.],</span>
<span class="sd">                [0., 0., 0., 1.]], dtype=float32)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">image_orientation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ImageOrientationPatient</span>
        <span class="k">if</span> <span class="n">image_orientation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;ImageOrientationPatient not defined in the DICOM header </span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;This is a required DICOM field </span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;The data may be corrupted - please check&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="c1"># Multiple slice groups in series - return list of affine matrices</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_multislice</span><span class="p">():</span>
            <span class="n">affine_matrices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="nb">dir</span> <span class="ow">in</span> <span class="n">image_orientation</span><span class="p">:</span>
                <span class="n">slice_group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">instances</span><span class="p">(</span><span class="n">ImageOrientationPatient</span><span class="o">=</span><span class="nb">dir</span><span class="p">)</span>
                <span class="n">affine</span> <span class="o">=</span> <span class="n">_slice_group_affine_matrix</span><span class="p">(</span><span class="n">slice_group</span><span class="p">,</span> <span class="nb">dir</span><span class="p">)</span>
                <span class="n">affine_matrices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">affine</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">affine_matrices</span><span class="p">)</span>
        <span class="c1"># Single slice group in series - return a list with a single affine matrix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slice_group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">instances</span><span class="p">()</span>
            <span class="n">affine</span> <span class="o">=</span> <span class="n">_slice_group_affine_matrix</span><span class="p">(</span><span class="n">slice_group</span><span class="p">,</span> <span class="n">image_orientation</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">affine</span><span class="p">])</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">is_multislice</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">-&gt;</span><span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if the series is multislice</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if the series is multislice.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">is_multislice</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        

    <span class="k">def</span><span class="w"> </span><span class="nf">islice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="p">{},</span> <span class="o">**</span><span class="n">inds</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a slice of the series by dimension indics</span>

<span class="sd">        Args:</span>
<span class="sd">            indices (dict, optional): Dictionary with tag:value pairs, where the values are either a single index or an array of indices.</span>
<span class="sd">            inds (dict, optional): Provide indices for the slice, either as keyword=index pairs or as a dictionary. The indices must be provided either as a scalar, a list or a numpy array.</span>

<span class="sd">        Raises:</span>
<span class="sd">            IndexError: when the indices in inds are out of range of the existing coordinates. </span>

<span class="sd">        See also:</span>
<span class="sd">            `slice`</span>
<span class="sd">            `split_by`</span>

<span class="sd">        Example:</span>
<span class="sd">            Create a zero-filled array, describing 8 MRI images each measured at 3 flip angles and 2 repetition times:</span>

<span class="sd">            &gt;&gt;&gt; coords = {</span>
<span class="sd">            ...    &#39;SliceLocation&#39;: np.arange(8),</span>
<span class="sd">            ...    &#39;FlipAngle&#39;: [2, 15, 30],</span>
<span class="sd">            ...    &#39;RepetitionTime&#39;: [2.5, 5.0],</span>
<span class="sd">            ... }</span>
<span class="sd">            &gt;&gt;&gt; series = db.zeros((128,128,8,3,2), coords)</span>

<span class="sd">            Slice the series at flip angle 15 (i.e. index 1):</span>

<span class="sd">            &gt;&gt;&gt; fa15 = series.islice(FlipAngle=1)</span>

<span class="sd">            Retrieve the array and check the dimensions:</span>

<span class="sd">            &gt;&gt;&gt; array = fa15.pixel_values(dims=tuple(coords))</span>
<span class="sd">            &gt;&gt;&gt; print(array.shape)</span>
<span class="sd">            (128, 128, 8, 1, 2)</span>

<span class="sd">            Multiple possible indices can be specified as a list or np.ndarray:</span>

<span class="sd">            &gt;&gt;&gt; fa15 = series.slice(SliceLocation=[0,5], FlipAngle=1)</span>
<span class="sd">            &gt;&gt;&gt; array = fa15.pixel_values(dims=tuple(coords))</span>
<span class="sd">            &gt;&gt;&gt; print(array.shape)</span>
<span class="sd">            (128, 128, 2, 1, 2)</span>

<span class="sd">            Values can also be provided as a dictionary, which is useful for instance for private tags that do not have a keyword string. So the following are equivalent:</span>

<span class="sd">            &gt;&gt;&gt; fa15 = series.slice(SliceLocation=[0,5], FlipAngle=1)</span>
<span class="sd">            &gt;&gt;&gt; fa15 = series.slice({SliceLocation:[0,5], FlipAngle:1})</span>
<span class="sd">            &gt;&gt;&gt; fa15 = series.slice({(0x0020, 0x1041):[0,5], (0x0018, 0x1314):1})</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">indices</span><span class="p">,</span> <span class="o">**</span><span class="n">inds</span><span class="p">}</span>

        <span class="c1"># Check whether the arguments are valid, and initialize dims.</span>
        <span class="k">if</span> <span class="n">inds</span> <span class="o">==</span> <span class="p">{}:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_sibling</span><span class="p">()</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">inds</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">source</span> <span class="o">=</span> <span class="n">instance_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sortby</span><span class="o">=</span><span class="n">dims</span><span class="p">)</span>
        
        <span class="c1"># Retrieve the instances of the slice.</span>
        <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inds</span><span class="p">):</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">inds</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">source</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
                <span class="c1"># Insert dimensions of 1 back in</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">Number</span><span class="p">):</span>
                    <span class="n">source</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">IndexError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;The indices for &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; in the inds argument are out of bounds&#39;</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_sibling</span><span class="p">()</span>
        <span class="n">source</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="n">source</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy_to</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>


    <span class="c1">#</span>
    <span class="c1"># Following APIs are obsolete and will be removed in future versions</span>
    <span class="c1">#</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">_old_set_pixel_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">coords</span><span class="p">:</span><span class="nb">dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inds</span><span class="p">:</span><span class="nb">dict</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assign new pixel data with a new numpy.ndarray. </span>

<span class="sd">        Args:</span>
<span class="sd">            array (np.ndarray): array with new pixel data.</span>
<span class="sd">            coords (dict, optional): Provide coordinates for the array, using a dictionary where the keys list the dimensions, and the values are provided as 1D or meshgrid arrays of coordinates. If data already exist at the specified coordinates, these will be overwritten. If not, the new data will be added to the series.</span>
<span class="sd">            inds (dict, optional): Provide a slice of existing data that will be overwritten with the new array. The format is the same as the dictionary of coordinates, except that the slice is identified by indices rather than values. </span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: if neither coords or inds or provided, if both are provided, or if the dimensions in coords or inds does not match up with the dimensions of the array.</span>
<span class="sd">            IndexError: when attempting to set a slice in an empty array, or when the indices in inds are out of range of the existing coordinates. </span>

<span class="sd">        See also:</span>
<span class="sd">            `pixel_values`</span>

<span class="sd">        Example:</span>
<span class="sd">            Create a zero-filled array, describing 8 MRI images each measured at 3 flip angles and 2 repetition times:</span>

<span class="sd">            &gt;&gt;&gt; coords = {</span>
<span class="sd">            ...    &#39;SliceLocation&#39;: np.arange(8),</span>
<span class="sd">            ...    &#39;FlipAngle&#39;: [2, 15, 30],</span>
<span class="sd">            ...    &#39;RepetitionTime&#39;: [2.5, 5.0],</span>
<span class="sd">            ... }</span>
<span class="sd">            &gt;&gt;&gt; series = db.zeros((128,128,8,3,2), coords)</span>

<span class="sd">            Retrieve the array and check that it is populated with zeros:</span>

<span class="sd">            &gt;&gt;&gt; array = series.pixel_values(dims=tuple(coords)) </span>
<span class="sd">            &gt;&gt;&gt; print(np.mean(array))</span>
<span class="sd">            0.0</span>

<span class="sd">            Now overwrite the values with a new array of ones in a new shape:</span>

<span class="sd">            &gt;&gt;&gt; new_shape = (128,128,8)</span>
<span class="sd">            &gt;&gt;&gt; new_coords = {</span>
<span class="sd">            ...     &#39;SliceLocation&#39;: np.arange(8),</span>
<span class="sd">            ... }</span>
<span class="sd">            &gt;&gt;&gt; ones = np.ones(new_shape)</span>
<span class="sd">            &gt;&gt;&gt; series.set_pixel_values(ones, coords=new_coords)</span>

<span class="sd">            Retrieve the new array and check shape:</span>
<span class="sd">            </span>
<span class="sd">            &gt;&gt;&gt; array = series.pixel_values(dims=tuple(new_coords))</span>
<span class="sd">            &gt;&gt;&gt; print(array.shape)</span>
<span class="sd">            (128,128,8)</span>

<span class="sd">            Check that the value is overwritten:</span>

<span class="sd">            &gt;&gt;&gt; print(np.mean(array))</span>
<span class="sd">            1.0</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check whether the arguments are valid, and initialize dims.</span>
        <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cnt</span><span class="o">+=</span><span class="mi">1</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">!=</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;One coordinate must be specified for each dimensions in the array.&#39;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">dim</span><span class="p">])</span> <span class="o">!=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">d</span><span class="o">+</span><span class="mi">2</span><span class="p">]:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; in the coords must have the same number of elements as the corresponding dimension in the array&#39;</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cnt</span><span class="o">+=</span><span class="mi">1</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">!=</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;One coordinate must be specified for each dimensions in the array.&#39;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;At least one of the optional arguments coords or inds must be provided&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cnt</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Only one of the optional arguments coords or inds must be provided&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">source</span> <span class="o">=</span> <span class="n">instance_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sortby</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">dims</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Retrieve the instances corresponding to the coordinates.</span>
            <span class="k">if</span> <span class="n">source</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
                    <span class="n">ind</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">d</span><span class="p">]):</span>
                        <span class="n">si</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">si</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">dim</span><span class="p">]</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">[</span><span class="n">dim</span><span class="p">]:</span>
                            <span class="n">ind</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">source</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
                    <span class="c1"># Insert dimensions of 1 back in</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                        <span class="n">source</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">inds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Retrieve the instances of the slice, as well as their coordinates.</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inds</span><span class="p">):</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="n">inds</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="n">ind</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">source</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">IndexError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;The indices for &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; in the inds argument are out of bounds&#39;</span>
                    <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="n">coords</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">d</span><span class="p">]):</span>
                    <span class="n">si</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                    <span class="n">coords</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">si</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">dim</span><span class="p">])</span>  

        <span class="n">nr_of_slices</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:]))</span>
        <span class="k">if</span> <span class="n">source</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># If there are not yet any instances at the correct coordinates, they will be created from scratch</span>
            <span class="n">source</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">new_instance</span><span class="p">(</span><span class="n">MRImage</span><span class="p">())</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nr_of_slices</span><span class="p">)]</span>
            <span class="n">set_pixel_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">source</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">==</span> <span class="n">source</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="c1"># If the new array has the same shape, use the exact headers.</span>
            <span class="n">set_pixel_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">source</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If the new array has a different shape, use the first header for all and delete all the others</span>
            <span class="c1"># This happens when some of the new coordinates are present, but not all.</span>
            <span class="c1"># TODO: This is overkill - only fill in the gaps with copies.</span>
            <span class="n">source</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">series</span> <span class="ow">in</span> <span class="n">source</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">series</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
            <span class="n">source</span> <span class="o">=</span> <span class="p">[</span><span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span><span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy_to</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nr_of_slices</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
            <span class="n">set_pixel_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">source</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">)</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">subseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Series</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract a subseries based on values of header elements.</span>

<span class="sd">        Args:</span>
<span class="sd">            kwargs: Any number of valid DICOM (tag, value) keyword arguments.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Series: a new series as a sibling under the same parent.</span>

<span class="sd">        See Also:</span>
<span class="sd">            :func:`~split_by`</span>

<span class="sd">        Example:</span>

<span class="sd">            Create a multi-slice series with multiple flip angles and repetition times:</span>

<span class="sd">            &gt;&gt;&gt; coords = {</span>
<span class="sd">            ...    &#39;SliceLocation&#39;: np.arange(16),</span>
<span class="sd">            ...    &#39;FlipAngle&#39;: [2, 15, 30],</span>
<span class="sd">            ...    &#39;RepetitionTime&#39;: [2.5, 5.0, 7.5],</span>
<span class="sd">            ... }</span>
<span class="sd">            &gt;&gt;&gt; zeros = db.zeros((128, 128, 16, 3, 2), coords)</span>

<span class="sd">            Create a new series containing only the data with flip angle 2 and repetition time 7.5:</span>

<span class="sd">            &gt;&gt;&gt; volume = zeros.subseries(FlipAngle=2.0, RepetitionTime=7.5)</span>

<span class="sd">            Check that the volume series now has two dimensions of size 1:</span>

<span class="sd">            &gt;&gt;&gt; array = volume.pixel_values(dims=tuple(coords))</span>
<span class="sd">            &gt;&gt;&gt; print(array.shape)</span>
<span class="sd">            (128, 128, 16, 1, 1)</span>

<span class="sd">            and only one flip angle and repetition time:</span>

<span class="sd">            &gt;&gt;&gt; print(volume.FlipAngle, volume.RepetitionTime)</span>
<span class="sd">            2.0 7.5</span>

<span class="sd">            and that the parent study now has two series:</span>

<span class="sd">            &gt;&gt;&gt; volume.study().print()</span>
<span class="sd">            ---------- STUDY ---------------</span>
<span class="sd">            Study New Study [None]</span>
<span class="sd">            Series 001 [New Series]</span>
<span class="sd">                Nr of instances: 96</span>
<span class="sd">            Series 002 [New Series]</span>
<span class="sd">                Nr of instances: 16</span>
<span class="sd">            --------------------------------</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">subseries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">move</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">slice_groups</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;InstanceNumber&#39;</span><span class="p">,))</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a list of slice groups in the series.</span>

<span class="sd">        In dbdicom, a *slice group* is defined as a series of slices that have the same orientation. It is common for a single series to have images with multiple orientations, such as in localizer series in MRI. For such a series, returning all data in a single array may not be meaningful. </span>

<span class="sd">        Formally, a *slice group* is a dictionary with two entries: &#39;ndarray&#39; is the numpy.ndarray with the data along the dimensions provided by the dims argument, and &#39;affine&#39; is the 4x4 affine matrix of the slice group. The function returns a list of such dictionaries, one for each slice group in the series.</span>

<span class="sd">        Args:</span>
<span class="sd">            dims (tuple, optional): Dimensions for the returned arrays. Defaults to (&#39;InstanceNumber&#39;,).</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: A list of slice groups (dictionaries), one for each slice group in the series.</span>

<span class="sd">        Examples:</span>

<span class="sd">            &gt;&gt;&gt; series = db.ones((128,128,5,10))</span>
<span class="sd">            &gt;&gt;&gt; sgroups = series.slice_groups(dims=(&#39;SliceLocation&#39;, &#39;AcquisitionTime&#39;))</span>

<span class="sd">            Since there is only one slice group in the series, ``sgroups`` is a list with one element:</span>

<span class="sd">            &gt;&gt;&gt; print(len(sgroups))</span>
<span class="sd">            1</span>

<span class="sd">            The array of the slice group is the entire volume of the series:</span>

<span class="sd">            &gt;&gt;&gt; print(sgroups[0][&#39;ndarray&#39;].shape)</span>
<span class="sd">            (128, 128, 5, 10)</span>

<span class="sd">            And the affine of the series has not changed from the default (identity):</span>

<span class="sd">            &gt;&gt;&gt; print(sgroups[0][&#39;affine&#39;])</span>
<span class="sd">            [[1. 0. 0. 0.]</span>
<span class="sd">             [0. 1. 0. 0.]</span>
<span class="sd">             [0. 0. 1. 0.]</span>
<span class="sd">             [0. 0. 0. 1.]]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">slice_groups</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">image_orientation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ImageOrientationPatient</span>

        <span class="c1"># Multiple slice groups in series - return list of cuboids</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image_orientation</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="nb">dir</span> <span class="ow">in</span> <span class="n">image_orientation</span><span class="p">:</span>
                <span class="n">slice_group</span> <span class="o">=</span> <span class="n">instance_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ImageOrientationPatient</span><span class="o">=</span><span class="nb">dir</span><span class="p">)</span>
                <span class="n">affine</span> <span class="o">=</span> <span class="n">_slice_group_affine_matrix</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">slice_group</span><span class="p">),</span> <span class="nb">dir</span><span class="p">)</span>
                <span class="n">array</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_get_pixel_array_from_instance_array</span><span class="p">(</span><span class="n">slice_group</span><span class="p">,</span> <span class="n">sortby</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">dims</span><span class="p">),</span> <span class="n">pixels_first</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">slice_groups</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;ndarray&#39;</span><span class="p">:</span> <span class="n">array</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;affine&#39;</span><span class="p">:</span> <span class="n">affine</span><span class="p">})</span>
        
        <span class="c1"># Single slice group in series - return a list with a single affine matrix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slice_group</span> <span class="o">=</span> <span class="n">instance_array</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">affine</span> <span class="o">=</span> <span class="n">_slice_group_affine_matrix</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">slice_group</span><span class="p">),</span> <span class="n">image_orientation</span><span class="p">)</span>
            <span class="n">array</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_get_pixel_array_from_instance_array</span><span class="p">(</span><span class="n">slice_group</span><span class="p">,</span> <span class="n">sortby</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">dims</span><span class="p">),</span> <span class="n">pixels_first</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">slice_groups</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;ndarray&#39;</span><span class="p">:</span> <span class="n">array</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;affine&#39;</span><span class="p">:</span> <span class="n">affine</span><span class="p">})</span>

        <span class="k">return</span> <span class="n">slice_groups</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">affine_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">affine_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">array</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">get_pixel_array</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">set_array</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">set_pixel_array</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_pixel_array</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> 
        <span class="k">return</span> <span class="n">get_pixel_array</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">set_pixel_array</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">set_pixel_array</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">ndarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel_values</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">set_ndarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_pixel_values</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>



<span class="k">def</span><span class="w"> </span><span class="nf">_filter_values</span><span class="p">(</span><span class="n">vframes</span><span class="p">,</span> <span class="nb">slice</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="c1"># vframes: list with one item per frame, each item being a list of values.</span>
    <span class="c1"># filters: dictionary of tag: value pairs.</span>
    <span class="k">if</span> <span class="nb">slice</span><span class="o">==</span><span class="p">{}</span> <span class="ow">and</span> <span class="n">coords</span><span class="o">==</span><span class="p">{}:</span>
        <span class="n">fvalues</span> <span class="o">=</span> <span class="n">vframes</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fvalues</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nf</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">slice</span><span class="p">)</span>
        <span class="n">nl</span> <span class="o">=</span> <span class="n">_coords_size</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">nc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">vframe</span> <span class="ow">in</span> <span class="n">vframes</span><span class="p">:</span>
            <span class="n">in_slice</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">slice</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">slice</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="n">in_slice</span> <span class="o">=</span> <span class="n">vframe</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">nf</span><span class="o">-</span><span class="n">nc</span><span class="p">]</span> <span class="ow">in</span> <span class="nb">slice</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">in_slice</span> <span class="o">=</span> <span class="n">vframe</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">nf</span><span class="o">-</span><span class="n">nc</span><span class="p">]</span> <span class="o">==</span> <span class="nb">slice</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">exclude</span><span class="p">:</span>
                    <span class="n">in_slice</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">in_slice</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">in_slice</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">nl</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">in_coords</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">in_coords</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nl</span><span class="p">):</span>
                    <span class="n">at_l</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">loc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
                        <span class="n">at_l</span> <span class="o">=</span> <span class="n">at_l</span> <span class="ow">and</span> <span class="p">(</span><span class="n">vframe</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">nc</span><span class="p">]</span> <span class="o">==</span> <span class="n">coords</span><span class="p">[</span><span class="n">loc</span><span class="p">][</span><span class="n">l</span><span class="p">])</span>
                    <span class="n">in_coords</span> <span class="o">=</span> <span class="n">in_coords</span> <span class="ow">or</span> <span class="n">at_l</span>
                    <span class="k">if</span> <span class="n">at_l</span><span class="p">:</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="n">exclude</span><span class="p">:</span>
                    <span class="n">in_coords</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">in_coords</span>
            <span class="k">if</span> <span class="n">in_slice</span> <span class="ow">and</span> <span class="n">in_coords</span><span class="p">:</span>
                <span class="n">fvalues</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vframe</span><span class="p">[:</span><span class="o">-</span><span class="n">nf</span><span class="o">-</span><span class="n">nc</span><span class="p">])</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fvalues</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
    
    <span class="c1"># Create array of return values. Values can be of different types including lists so this must be an object array.</span>
    <span class="n">nd</span><span class="p">,</span> <span class="n">nf</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fvalues</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">len</span><span class="p">(</span><span class="n">fvalues</span><span class="p">)</span>
    <span class="n">rvalues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nd</span><span class="p">,</span><span class="n">nf</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nd</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nf</span><span class="p">):</span>
            <span class="n">rvalues</span><span class="p">[</span><span class="n">d</span><span class="p">,</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">fvalues</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="n">d</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">rvalues</span>
    


<span class="k">def</span><span class="w"> </span><span class="nf">_filter_values_ind</span><span class="p">(</span><span class="n">vframes</span><span class="p">,</span> <span class="nb">slice</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">slice</span><span class="o">==</span><span class="p">{}</span> <span class="ow">and</span> <span class="n">coords</span><span class="o">==</span><span class="p">{}:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vframes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">finds</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">nf</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">slice</span><span class="p">)</span>
    <span class="n">nl</span> <span class="o">=</span> <span class="n">_coords_size</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
    <span class="n">nc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">iv</span><span class="p">,</span> <span class="n">vframe</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vframes</span><span class="p">):</span>
        <span class="n">in_slice</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">slice</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">slice</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">in_slice</span> <span class="o">=</span> <span class="n">vframe</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">nf</span><span class="o">-</span><span class="n">nc</span><span class="p">]</span> <span class="ow">in</span> <span class="nb">slice</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">in_slice</span> <span class="o">=</span> <span class="n">vframe</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">nf</span><span class="o">-</span><span class="n">nc</span><span class="p">]</span> <span class="o">==</span> <span class="nb">slice</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">exclude</span><span class="p">:</span>
                <span class="n">in_slice</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">in_slice</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">in_slice</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">nl</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">in_coords</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">in_coords</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nl</span><span class="p">):</span>
                <span class="n">at_l</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">loc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
                    <span class="n">at_l</span> <span class="o">=</span> <span class="n">at_l</span> <span class="ow">and</span> <span class="p">(</span><span class="n">vframe</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">nc</span><span class="p">]</span> <span class="o">==</span> <span class="n">coords</span><span class="p">[</span><span class="n">loc</span><span class="p">][</span><span class="n">l</span><span class="p">])</span>
                <span class="n">in_coords</span> <span class="o">=</span> <span class="n">in_coords</span> <span class="ow">or</span> <span class="n">at_l</span>
                <span class="k">if</span> <span class="n">at_l</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">exclude</span><span class="p">:</span>
                <span class="n">in_coords</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">in_coords</span>
        <span class="k">if</span> <span class="n">in_slice</span> <span class="ow">and</span> <span class="n">in_coords</span><span class="p">:</span>
            <span class="n">finds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iv</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">finds</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_coords_shape</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">coords</span> <span class="o">==</span> <span class="p">{}:</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span>
    
    <span class="c1"># Check that all values are arrays.</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Coordinate values must be provided as numpy arrays.&#39;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">But the value of &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; is a &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        
    <span class="n">shapes</span> <span class="o">=</span> <span class="p">[</span><span class="n">coords</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">]</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">shapes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">shapes</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="n">shape</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Dimensions are ambiguous - not all coordinates have the same shape.&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">shapes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  


<span class="k">def</span><span class="w"> </span><span class="nf">_coords_size</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">coords</span> <span class="o">==</span> <span class="p">{}:</span>
        <span class="k">return</span> <span class="mi">0</span> 
    
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Coordinate values must be provided as numpy arrays.&#39;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">But the value of &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; is a &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    
    <span class="c1"># Coordinate values must a have the same size.</span>
    <span class="n">sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="n">coords</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sizes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;These are not proper dimensions. Each coordinate must have the same number of values.&#39;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  

<span class="k">def</span><span class="w"> </span><span class="nf">_coords_vals</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
    <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">coords</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">]</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">values</span>
 
<span class="k">def</span><span class="w"> </span><span class="nf">_check_if_ivals</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
    <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;These are not proper dimensions. Coordinate values must be defined everywhere.&#39;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    
    <span class="c1"># Check if the values are unique</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">f</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">equal</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">values</span><span class="p">[</span><span class="n">d</span><span class="p">,</span><span class="n">f</span><span class="p">]</span> <span class="o">!=</span> <span class="n">values</span><span class="p">[</span><span class="n">d</span><span class="p">,</span><span class="n">g</span><span class="p">]:</span>
                    <span class="n">equal</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">equal</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;These are not proper dimensions. Coordinate values must be unique.&#39;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="c1"># if values.shape[1] != np.unique(values, axis=1).shape[1]:</span>
    <span class="c1">#     msg = &#39;These are not proper dimensions. Coordinate values must be unique.&#39;</span>
    <span class="c1">#     raise ValueError(msg)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_check_if_coords</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>

    <span class="c1"># Check that all values are arrays.</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Coordinate values must be provided as numpy arrays.&#39;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">But the value of &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; is a &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">c</span><span class="p">]))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="c1"># Check if coordinates are unique</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">_coords_vals</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
    <span class="n">_check_if_ivals</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">coords</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_mesh_to_coords</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">:</span>
        <span class="n">coords</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">_check_if_coords</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
    

<span class="k">def</span><span class="w"> </span><span class="nf">_grid_to_meshcoords</span><span class="p">(</span><span class="n">gridcoords</span><span class="p">):</span>

    <span class="n">grid</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">gridcoords</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gridcoords</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Grid coordinates have to be numpy arrays.&#39;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gridcoords</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Grid coordinates have to be one-dimensionial.&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">gridcoords</span><span class="p">[</span><span class="n">c</span><span class="p">]))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gridcoords</span><span class="p">[</span><span class="n">c</span><span class="p">]):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Grid coordinates have to be unique.&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gridcoords</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>

    <span class="n">mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="nb">tuple</span><span class="p">(</span><span class="n">grid</span><span class="p">),</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
    <span class="n">meshcoords</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gridcoords</span><span class="p">):</span>
        <span class="n">meshcoords</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">_check_if_coords</span><span class="p">(</span><span class="n">meshcoords</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">meshcoords</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_meshcoords_to_grid</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
    <span class="n">gridcoords</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
        <span class="n">gridcoords</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">dvals</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dvals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">d</span><span class="p">]):</span>
            <span class="n">dvals_i</span> <span class="o">=</span> <span class="n">dvals</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
            <span class="n">dvals_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">dvals_i</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dvals_i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;These are not proper grid coordinates.&#39;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">gridcoords</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dvals_i</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">gridcoords</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">gridcoords</span><span class="p">[</span><span class="n">dim</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">gridcoords</span>  


<span class="k">def</span><span class="w"> </span><span class="nf">_grid_to_coords</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">grid</span> <span class="o">==</span> <span class="p">{}:</span>
        <span class="k">return</span> <span class="p">{}</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">_grid_to_meshcoords</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">:</span>
        <span class="n">coords</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">coords</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_as_meshcoords</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>

    <span class="c1"># First check that they are proper coordinates</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">_coords_vals</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
    <span class="n">_check_if_ivals</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">_meshvals</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="n">meshcoords</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
        <span class="n">meshcoords</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">meshcoords</span>
        
<span class="k">def</span><span class="w"> </span><span class="nf">_meshvals</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
    <span class="c1"># Input array shape: (d, f) with d = nr of dims and f = nr of frames</span>
    <span class="c1"># Output array shape: (d, f1,..., fd)</span>
    <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="c1"># List the unique values of the first coordinate</span>
    <span class="n">vals</span><span class="p">,</span> <span class="n">cnts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># Check that there is an equal number of each value</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cnts</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;These are not mesh coordinates.&#39;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> 
    <span class="c1"># If there is only one dimension, we are done</span>
    <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">values</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">:</span>
        <span class="n">vind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">==</span><span class="n">v</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">vmesh</span> <span class="o">=</span> <span class="n">_meshvals</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span><span class="n">vind</span><span class="p">])</span>
        <span class="n">mesh</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vmesh</span><span class="p">)</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">]</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">mesh</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">mesh</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_meshdata</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">crds</span><span class="p">,</span> <span class="n">cmesh</span><span class="p">):</span>
    <span class="n">mshape</span> <span class="o">=</span> <span class="p">(</span><span class="n">vals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span> <span class="o">+</span> <span class="n">cmesh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">if</span> <span class="n">mshape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">vals</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">mshape</span><span class="p">)</span>
    <span class="n">vmesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">mshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    <span class="n">cmesh</span> <span class="o">=</span> <span class="n">cmesh</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">cmesh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">vmesh</span> <span class="o">=</span> <span class="n">vmesh</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">vmesh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">vals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="c1"># find location of coordinate i in cmesh</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cmesh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">cmesh</span><span class="p">[:,</span><span class="n">j</span><span class="p">],</span> <span class="n">crds</span><span class="p">[:,</span><span class="n">i</span><span class="p">]):</span>
                <span class="k">break</span>
        <span class="c1"># Write value i at the same location in vmesh</span>
        <span class="n">vmesh</span><span class="p">[:,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">vmesh</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">mshape</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_concatenate_coords</span><span class="p">(</span><span class="n">coords</span><span class="p">:</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">concat</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">concat</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span> 
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coord</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">concat</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Cannot concatenate - all coordinates must have the same variables.&#39;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">concat</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">concat</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">coord</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()))</span>
    <span class="n">_check_if_coords</span><span class="p">(</span><span class="n">concat</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mesh</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_as_meshcoords</span><span class="p">(</span><span class="n">concat</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">concat</span>


<span class="c1">### OBSOLETE BELOW HERE</span>


<span class="k">def</span><span class="w"> </span><span class="nf">set_pixel_values</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> 

    <span class="c1"># If coordinates are given as 1D arrays, turn them into grids and flatten for iteration.</span>
    <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mesh_coords</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">v</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">v</span> <span class="o">!=</span> <span class="p">[]:</span>
            <span class="n">v0</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v0</span><span class="p">)</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># regular grid</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">coords</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">])</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
                    <span class="n">mesh_coords</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

    <span class="c1"># Flatten array for iterating</span>
    <span class="n">nr_of_slices</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:]))</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">nr_of_slices</span><span class="p">))</span> <span class="c1"># shape (x,y,i)</span>
    <span class="n">attr</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">series</span><span class="o">.</span><span class="n">attributes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">}</span>
    <span class="k">if</span> <span class="s1">&#39;SliceLocation&#39;</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">:</span>
        <span class="n">affine</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">affine</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">image</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">source</span><span class="p">):</span>
        <span class="n">series</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">source</span><span class="p">),</span> <span class="s1">&#39;Saving array..&#39;</span><span class="p">)</span>
        <span class="n">image</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

        <span class="c1"># Update any other header data provided</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">attr</span><span class="o">.</span><span class="n">items</span><span class="p">():</span> 
            <span class="nb">setattr</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="c1"># if isinstance(v, list):</span>
            <span class="c1">#     setattr(image, a, v[i])</span>
            <span class="c1"># else:</span>
            <span class="c1">#     setattr(image, a, v)</span>

        <span class="c1"># # If needed, use Defaults for geometry markers</span>
        <span class="c1"># if affine is not None:</span>
        <span class="c1">#     affine[2, 3] = i # not sufficiently general</span>
        <span class="c1">#     image.affine_matrix = affine</span>

        <span class="c1"># Set coordinates.</span>
        <span class="k">if</span> <span class="n">mesh_coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">mesh_coords</span><span class="p">:</span>
                <span class="n">image</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">mesh_coords</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> 
                <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="s1">&#39;SliceLocation&#39;</span><span class="p">:</span>
                    <span class="n">image</span><span class="p">[</span><span class="s1">&#39;ImagePositionPatient&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">image_utils</span><span class="o">.</span><span class="n">image_position_from_slice_location</span><span class="p">(</span><span class="n">mesh_coords</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">affine</span><span class="p">)</span> 

        <span class="n">image</span><span class="o">.</span><span class="n">set_pixel_array</span><span class="p">(</span><span class="n">array</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">])</span>
        <span class="n">image</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>


<span class="c1"># def slice_groups(series): # not yet in use</span>
<span class="c1">#     slice_groups = []</span>
<span class="c1">#     for orientation in series.ImageOrientationPatient:</span>
<span class="c1">#         sg = series.instances(ImageOrientationPatient=orientation)</span>
<span class="c1">#         slice_groups.append(sg)</span>
<span class="c1">#     return slice_groups</span>


<span class="k">def</span><span class="w"> </span><span class="nf">subseries</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">move</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">series</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">new_sibling</span><span class="p">()</span>
    <span class="n">instances</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">instances</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">instance</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">instances</span><span class="p">):</span>
        <span class="n">record</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">instances</span><span class="p">),</span> <span class="s1">&#39;Extracting subseries..&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">move</span><span class="p">:</span>
            <span class="n">instance</span><span class="o">.</span><span class="n">move_to</span><span class="p">(</span><span class="n">series</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">instance</span><span class="o">.</span><span class="n">copy_to</span><span class="p">(</span><span class="n">series</span><span class="p">)</span>
    <span class="c1"># This should be faster:</span>
    <span class="c1"># instances = record.instances(**kwargs)</span>
    <span class="c1"># series.adopt(instances)</span>
    <span class="k">return</span> <span class="n">series</span>


<span class="k">def</span><span class="w"> </span><span class="nf">read_npy</span><span class="p">(</span><span class="n">record</span><span class="p">):</span>
    <span class="c1"># Not in use - loading of temporary numpy files</span>
    <span class="n">file</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">npy</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">file</span><span class="p">):</span>
        <span class="k">return</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">array</span>



<span class="k">def</span><span class="w"> </span><span class="nf">array</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">sortby</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pixels_first</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">first_volume</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span> <span class="c1"># array of instances</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">record</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">rec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">record</span><span class="p">):</span>
            <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rec</span>
        <span class="k">return</span> <span class="n">_get_pixel_array_from_instance_array</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">sortby</span><span class="o">=</span><span class="n">sortby</span><span class="p">,</span> <span class="n">pixels_first</span><span class="o">=</span><span class="n">pixels_first</span><span class="p">,</span> <span class="n">first_volume</span><span class="o">=</span><span class="n">first_volume</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span> <span class="c1"># array of instances</span>
        <span class="k">return</span> <span class="n">_get_pixel_array_from_instance_array</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">sortby</span><span class="o">=</span><span class="n">sortby</span><span class="p">,</span> <span class="n">pixels_first</span><span class="o">=</span><span class="n">pixels_first</span><span class="p">,</span> <span class="n">first_volume</span><span class="o">=</span><span class="n">first_volume</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">get_pixel_array</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">sortby</span><span class="o">=</span><span class="n">sortby</span><span class="p">,</span> <span class="n">pixels_first</span><span class="o">=</span><span class="n">pixels_first</span><span class="p">,</span> <span class="n">first_volume</span><span class="o">=</span><span class="n">first_volume</span><span class="p">)</span>
    

<span class="k">def</span><span class="w"> </span><span class="nf">get_pixel_array</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">sortby</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">first_volume</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">pixels_first</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">source</span> <span class="o">=</span> <span class="n">instance_array</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">sortby</span><span class="p">)</span>
    <span class="n">array</span><span class="p">,</span> <span class="n">headers</span> <span class="o">=</span> <span class="n">_get_pixel_array_from_sorted_instance_array</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">pixels_first</span><span class="o">=</span><span class="n">pixels_first</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">first_volume</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">headers</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">,</span> <span class="n">headers</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_pixel_array_from_instance_array</span><span class="p">(</span><span class="n">instance_array</span><span class="p">,</span> <span class="n">sortby</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pixels_first</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">first_volume</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">source</span> <span class="o">=</span> <span class="n">sort_instance_array</span><span class="p">(</span><span class="n">instance_array</span><span class="p">,</span> <span class="n">sortby</span><span class="p">)</span>
    <span class="n">array</span><span class="p">,</span> <span class="n">headers</span> <span class="o">=</span> <span class="n">_get_pixel_array_from_sorted_instance_array</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">pixels_first</span><span class="o">=</span><span class="n">pixels_first</span><span class="p">)</span> 
    <span class="k">if</span> <span class="n">first_volume</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">headers</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">,</span> <span class="n">headers</span>  


<span class="k">def</span><span class="w"> </span><span class="nf">_get_pixel_array_from_sorted_instance_array</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">pixels_first</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

    <span class="n">array</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">instances</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">im</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">im</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">instances</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">im</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">array</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">im</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">instances</span><span class="p">),</span> <span class="s1">&#39;Reading pixel data..&#39;</span><span class="p">)</span>
            <span class="n">array</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">get_pixel_array</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">im</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">im</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">hide</span><span class="p">()</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">_stack</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">array</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Pixel array is empty. </span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;Either because one or more of the keywords used for sorting does not exist; </span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;or the series does not have any image data..&#39;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">if</span> <span class="n">pixels_first</span><span class="p">:</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">array</span><span class="p">,</span> <span class="n">source</span> 


<span class="k">def</span><span class="w"> </span><span class="nf">set_pixel_array</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pixels_first</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> 

    <span class="c1"># Move pixels to the end (default)</span>
    <span class="k">if</span> <span class="n">pixels_first</span><span class="p">:</span>    
        <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># if no header data are provided, use template headers.</span>
    <span class="n">nr_of_slices</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]))</span>
    <span class="k">if</span> <span class="n">source</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">source</span> <span class="o">=</span> <span class="p">[</span><span class="n">series</span><span class="o">.</span><span class="n">new_instance</span><span class="p">(</span><span class="n">MRImage</span><span class="p">())</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nr_of_slices</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">source</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">source</span> <span class="o">=</span> <span class="p">[</span><span class="n">series</span><span class="o">.</span><span class="n">new_instance</span><span class="p">(</span><span class="n">MRImage</span><span class="p">())</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nr_of_slices</span><span class="p">)]</span>

    <span class="c1"># If the header data are not the same size, use only the first one.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">source</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># assume scalar</span>
            <span class="n">source</span> <span class="o">=</span> <span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">*</span> <span class="n">nr_of_slices</span>
        <span class="k">if</span> <span class="n">nr_of_slices</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">source</span><span class="p">):</span>
            <span class="n">source</span> <span class="o">=</span> <span class="p">[</span><span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">nr_of_slices</span>

    <span class="c1"># Copy all sources to the series, if they are not part of it</span>
    <span class="n">copy_source</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">instances</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">instances</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">source</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">instances</span><span class="p">:</span>
            <span class="n">copy_source</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">series</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">source</span><span class="p">),</span> <span class="s1">&#39;Copying series..&#39;</span><span class="p">)</span>
            <span class="n">copy_source</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">copy_to</span><span class="p">(</span><span class="n">series</span><span class="p">))</span>

    <span class="c1"># Faster but does not work if all sources are the same</span>
    <span class="c1"># series.status.message(&#39;Saving array (1/2): Copying series..&#39;)</span>
    <span class="c1"># instances = series.instances()</span>
    <span class="c1"># to_copy = [i for i in range(len(source)) if source[i] not in instances]</span>
    <span class="c1"># copied = series.adopt([source[i] for i in to_copy])</span>
    <span class="c1"># for i, c in enumerate(copied):</span>
    <span class="c1">#     source[to_copy[i]] = c</span>

    <span class="c1"># Flatten array for iterating</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">nr_of_slices</span><span class="p">,</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="c1"># shape (i,x,y)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">image</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">copy_source</span><span class="p">):</span>
        <span class="n">series</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">copy_source</span><span class="p">),</span> <span class="s1">&#39;Saving array..&#39;</span><span class="p">)</span>
        <span class="n">image</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">vals</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span> 
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">vals</span><span class="p">)</span>
        <span class="n">image</span><span class="o">.</span><span class="n">set_pixel_array</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="o">...</span><span class="p">])</span>
        <span class="n">image</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

<span class="c1"># TODO: make this obsolete - only used ion affine_matrix</span>
<span class="k">def</span><span class="w"> </span><span class="nf">is_multislice</span><span class="p">(</span><span class="n">series</span><span class="p">):</span>
    <span class="n">orientation</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">ImageOrientationPatient</span>
    <span class="c1"># Series is multislice if there are multiple unique orientations</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orientation</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="c1">#</span>
    <span class="c1"># NOTE: 08/01/25: Added below conditions to correctly deal with situations</span>
    <span class="c1"># where individual slices have been shifted but not rotated.</span>
    <span class="c1"># From here: a series is multislice as soon as slices are not part of a </span>
    <span class="c1"># uniformly spaced 3D volume.</span>
    <span class="c1"># </span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">ImagePositionPatient</span>
    <span class="c1"># If there is only one slice location, the series is not multislice</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="c1">#</span>
    <span class="c1"># If there are multiple positions, check that they are all on the slice </span>
    <span class="c1"># vector. If at least one if them is not, the series is multislice.</span>
    <span class="c1">#</span>
    <span class="c1"># Get slice vector</span>
    <span class="n">row_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">orientation</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>    
    <span class="n">column_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">orientation</span><span class="p">[</span><span class="mi">3</span><span class="p">:])</span> 
    <span class="n">slice_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">row_vec</span><span class="p">,</span> <span class="n">column_vec</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="c1"># Position relative to first slice position</span>
        <span class="n">prel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># Parallel means cross product has length zero</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">slice_vec</span><span class="p">,</span> <span class="n">prel</span><span class="p">))</span>
        <span class="c1"># Round to micrometers to avoid numerical error</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
    <span class="c1">#</span>
    <span class="c1"># If they are all on the slice vector, check that they have the same </span>
    <span class="c1"># spacing. If more than one spacing is found, the series is multislice.</span>
    <span class="c1">#</span>
    <span class="c1"># Get slice locations</span>
    <span class="n">loc</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">slice_vec</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pos</span><span class="p">]</span>
    <span class="c1"># Sort slice locations</span>
    <span class="n">loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span>
    <span class="c1"># Get unique slice spacing (to micrometer precision)</span>
    <span class="n">spacing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">loc</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">-</span><span class="n">loc</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">))</span>
    <span class="c1"># If there is more than 1 slice spacing, the series is multislice</span>
    <span class="k">return</span> <span class="n">spacing</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">1</span>

<span class="c1"># TODO: make this obsolete   -replace by affines</span>
<span class="k">def</span><span class="w"> </span><span class="nf">affine_matrix</span><span class="p">(</span><span class="n">series</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the affine matrix of a series.</span>
<span class="sd">    </span>
<span class="sd">    If the series consists of multiple slice groups with different </span>
<span class="sd">    image orientations, then a list of affine matrices is returned,</span>
<span class="sd">    one for each slice orientation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">image_orientation</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">ImageOrientationPatient</span>
    <span class="k">if</span> <span class="n">image_orientation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;ImageOrientationPatient not defined in the DICOM header </span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;This is a required DICOM field </span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;The data may be corrupted - please check&#39;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    
    <span class="c1"># Multiple slice groups in series - return list of affine matrices</span>
    <span class="k">if</span> <span class="n">is_multislice</span><span class="p">(</span><span class="n">series</span><span class="p">):</span>
        <span class="c1">#</span>
        <span class="c1"># NOTE: 08/01/2025: Changed definition of slice groups from &quot;frames with </span>
        <span class="c1"># the same orientation&quot; to &quot;frames with the same orientation and position&quot;</span>
        <span class="c1">#</span>
        <span class="c1"># Get unique image positions</span>
        <span class="n">image_position</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">ImagePositionPatient</span>
        <span class="c1"># Make sure orientations and positions are losts</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image_orientation</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">image_orientation</span> <span class="o">=</span> <span class="p">[</span><span class="n">image_orientation</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image_position</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">image_position</span> <span class="o">=</span> <span class="p">[</span><span class="n">image_position</span><span class="p">]</span>
        <span class="c1"># Return one affine per slice group</span>
        <span class="n">affine_matrices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="nb">dir</span> <span class="ow">in</span> <span class="n">image_orientation</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">image_position</span><span class="p">:</span>
                <span class="n">slice_group</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">instances</span><span class="p">(</span><span class="n">ImageOrientationPatient</span><span class="o">=</span><span class="nb">dir</span><span class="p">,</span> <span class="n">ImagePositionPatient</span><span class="o">=</span><span class="n">pos</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">slice_group</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">affine</span> <span class="o">=</span> <span class="n">_slice_group_affine_matrix</span><span class="p">(</span><span class="n">slice_group</span><span class="p">,</span> <span class="nb">dir</span><span class="p">)</span>
                    <span class="n">affine_matrices</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">affine</span><span class="p">,</span> <span class="n">slice_group</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">affine_matrices</span>
    
    <span class="c1"># Single slice group in series - return a single affine matrix</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">slice_group</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">instances</span><span class="p">()</span>
        <span class="n">affine</span> <span class="o">=</span> <span class="n">_slice_group_affine_matrix</span><span class="p">(</span><span class="n">slice_group</span><span class="p">,</span> <span class="n">image_orientation</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">affine</span><span class="p">,</span> <span class="n">slice_group</span>
    

<span class="k">def</span><span class="w"> </span><span class="nf">_slice_group_affine_matrix</span><span class="p">(</span><span class="n">slice_group</span><span class="p">,</span> <span class="n">image_orientation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the affine matrix of a slice group&quot;&quot;&quot;</span>

    <span class="c1"># single slice</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">slice_group</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">slice_group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">affine_matrix</span>
    <span class="c1"># multi slice</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">ImagePositionPatient</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">slice_group</span><span class="p">]</span>
        <span class="c1"># Find unique elements</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="n">pos</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>

        <span class="c1"># One slice location</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> 
            <span class="k">return</span> <span class="n">slice_group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">affine_matrix</span>
        
        <span class="c1"># Slices with different locations</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">image_utils</span><span class="o">.</span><span class="n">affine_matrix_multislice</span><span class="p">(</span>
                <span class="n">image_orientation</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span>
                <span class="n">slice_group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">PixelSpacing</span><span class="p">)</span>    <span class="c1"># assume all the same pixel spacing</span>
        

<span class="k">def</span><span class="w"> </span><span class="nf">sort_instance_array</span><span class="p">(</span><span class="n">instance_array</span><span class="p">,</span> <span class="n">sortby</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">sortby</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">instance_array</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sortby</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">sortby</span> <span class="o">=</span> <span class="p">[</span><span class="n">sortby</span><span class="p">]</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">read_dataframe_from_instance_array</span><span class="p">(</span><span class="n">instance_array</span><span class="p">,</span> <span class="n">sortby</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;SOPInstanceUID&#39;</span><span class="p">])</span>
        <span class="n">df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">sortby</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> 
        <span class="k">return</span> <span class="n">df_to_sorted_instance_array</span><span class="p">(</span><span class="n">instance_array</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">df</span><span class="p">,</span> <span class="n">sortby</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_instances</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">dims</span><span class="p">:</span><span class="nb">tuple</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inds</span><span class="p">:</span><span class="nb">dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">select</span><span class="o">=</span><span class="p">{},</span> <span class="o">**</span><span class="n">filters</span><span class="p">):</span>

    <span class="c1"># Use default dimensions if needed.</span>
    <span class="k">if</span> <span class="n">dims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;InstanceNumber&#39;</span><span class="p">,)</span>

    <span class="c1"># If indices are provided, check that they are compatible with dims.</span>
    <span class="k">if</span> <span class="n">inds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">inds</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Indices must be in the dimensions provided.&#39;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    
    <span class="c1"># Get the frames and sort by dim</span>
    <span class="n">frames</span> <span class="o">=</span> <span class="n">instance_array</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">dims</span><span class="p">),</span> <span class="n">report_none</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">select</span><span class="o">=</span><span class="n">select</span><span class="p">,</span> <span class="o">**</span><span class="n">filters</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">frames</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">frames</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)))</span>
    <span class="k">if</span> <span class="n">frames</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;(&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;, &#39;</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;)&#39;</span><span class="p">])</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;series shape is ambiguous in dimensions &#39;</span> <span class="o">+</span> <span class="n">d</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">--&gt; Multiple frames exist at some or all locations.&#39;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">--&gt; Hint: use Series.unique() to list the values at all locations.&#39;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">frames</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;(&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;, &#39;</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;)&#39;</span><span class="p">])</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;series shape is not well defined in dimensions &#39;</span> <span class="o">+</span> <span class="n">d</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">--&gt; There are no frames at some locations.&#39;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">--&gt; Hint: use Series.value() to find the values at all locations.&#39;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="n">frames</span> <span class="o">=</span> <span class="n">frames</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Extract indices and coordinates if provided</span>
    <span class="k">if</span> <span class="n">inds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">inds</span><span class="p">:</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">inds</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">dims</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
            <span class="n">frames</span> <span class="o">=</span> <span class="n">frames</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">frames</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">frames</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">frames</span>


<span class="k">def</span><span class="w"> </span><span class="nf">instance_array</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">sortby</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">report_none</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">select</span><span class="o">=</span><span class="p">{},</span> <span class="o">**</span><span class="n">filters</span><span class="p">):</span> 
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sort instances by a list of attributes.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        sortby: </span>
<span class="sd">            List of DICOM keywords by which the series is sorted</span>
<span class="sd">    Returns:</span>
<span class="sd">        An ndarray holding the instances sorted by sortby.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">sortby</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">instances</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">instances</span><span class="p">(</span><span class="o">**</span><span class="n">filters</span><span class="p">)</span> <span class="c1"># Note filter values here cant be arrays</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">instances</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">instance</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">instances</span><span class="p">):</span> 
            <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">instance</span>
        <span class="k">return</span> <span class="n">array</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sortby</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">sortby</span> <span class="o">=</span> <span class="p">[</span><span class="n">sortby</span><span class="p">]</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">read_dataframe</span><span class="p">(</span><span class="n">sortby</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;SOPInstanceUID&#39;</span><span class="p">],</span> <span class="n">select</span><span class="o">=</span><span class="n">select</span><span class="p">,</span> <span class="o">**</span><span class="n">filters</span><span class="p">)</span> 
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">SOPInstanceUID</span><span class="o">.</span><span class="n">values</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="k">if</span> <span class="n">report_none</span><span class="p">:</span>
            <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">values</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;(&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;, &#39;</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">sortby</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;)&#39;</span><span class="p">])</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;series shape is not well defined in dimensions &#39;</span> <span class="o">+</span> <span class="n">d</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">--&gt; Some of the dimensions are not defined in the header.&#39;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">--&gt; Hint: use Series.value() to find the undefined values.&#39;</span>                
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">sortby</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> 
        <span class="k">return</span> <span class="n">df_to_sorted_instance_array</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">sortby</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">df_to_sorted_instance_array</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">sortby</span><span class="p">):</span> 

    <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">sortby</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vals</span><span class="p">):</span> 
        <span class="n">record</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">),</span> <span class="n">message</span><span class="o">=</span><span class="s1">&#39;Sorting pixel data..&#39;</span><span class="p">)</span>
        <span class="c1"># if a type is not supported by np.isnan()</span>
        <span class="c1"># assume it is not a nan</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># this happens when undefined keyword is used</span>
            <span class="n">dfc</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="n">sortby</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span> 
                <span class="n">nan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span> 
                <span class="n">nan</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">nan</span><span class="p">:</span>
                <span class="n">dfc</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="n">sortby</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dfc</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="n">sortby</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">==</span> <span class="n">c</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sortby</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">datac</span> <span class="o">=</span> <span class="n">df_to_instance_array</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">dfc</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">datac</span> <span class="o">=</span> <span class="n">df_to_sorted_instance_array</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">dfc</span><span class="p">,</span> <span class="n">sortby</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">datac</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_stack</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">align_left</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">df_to_instance_array</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">df</span><span class="p">):</span> 
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return datasets as numpy array of object type&quot;&quot;&quot;</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">SOPInstanceUID</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
        <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">instance</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">data</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_stack</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">align_left</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Stack a list of arrays of different shapes but same number of dimensions.</span>
<span class="sd">    </span>
<span class="sd">    This generalises numpy.stack to arrays of different sizes.</span>
<span class="sd">    The stack has the size of the largest array.</span>
<span class="sd">    If an array is smaller it is zero-padded and centred on the middle.</span>
<span class="sd">    None items are removed first before stacking</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Get the dimensions of the stack</span>
    <span class="c1"># For each dimension, look for the largest values across all arrays</span>
    <span class="c1">#arrays = [a for a in arrays if a is not None]</span>
    <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arrays</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">arrays</span> <span class="o">==</span> <span class="p">[]:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">ndim</span>
    <span class="k">for</span> <span class="n">array</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="n">dim</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="n">d</span><span class="p">,</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="c1"># changing the variable we are iterating over!!</span>
    <span class="c1">#    for i in range(ndim):</span>
    <span class="c1">#        dim[i] = max((dim[i], array.shape[i]))</span>

    <span class="c1"># Create the stack</span>
    <span class="c1"># Add one dimension corresponding to the size of the stack</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span>
    <span class="c1">#stack = np.full([n] + dim, 0, dtype=arrays[0].dtype)</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">([</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dim</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">array</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arrays</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">align_left</span><span class="p">:</span>
                <span class="n">i0</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># align center and zero-pad missing values</span>
                <span class="n">i0</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">d</span><span class="o">-</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">i1</span> <span class="o">=</span> <span class="n">i0</span> <span class="o">+</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span><span class="n">i1</span><span class="p">))</span>
        <span class="n">stack</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">index</span><span class="p">)]</span> <span class="o">=</span> <span class="n">array</span>

    <span class="k">return</span> <span class="n">stack</span>







</pre></div>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2022-2025, QIB-Sheffield.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>