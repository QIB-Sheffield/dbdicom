
<!DOCTYPE html>


<html lang="en" data-content_root="../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>dbdicom.extensions.vreg &#8212; dbdicom 0.2.4 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css?v=d2d258e8" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-binder.css?v=f4aeca0c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- So that users can add custom icons -->
  <script src="../../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../../_static/documentation_options.js?v=6ffd866b"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../../_static/design-tabs.js?v=f930bc37"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/dbdicom/extensions/vreg';</script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../../_static/dbd.png" class="logo__image only-light" alt="dbdicom 0.2.4 documentation - Home"/>
    <img src="../../../_static/dbd.png" class="logo__image only-dark pst-js-only" alt="dbdicom 0.2.4 documentation - Home"/>
  
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../user_guide/index.html">
    User guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../reference/index.html">
    Reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../generated/examples/index.html">
    Examples
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../developers_guide/index.html">
    Developer guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../about/index.html">
    About
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/QIB-Sheffield/dbdicom" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../user_guide/index.html">
    User guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../reference/index.html">
    Reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../generated/examples/index.html">
    Examples
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../developers_guide/index.html">
    Developer guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../about/index.html">
    About
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/QIB-Sheffield/dbdicom" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">dbdicom.extensions.vreg</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for dbdicom.extensions.vreg</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">dbdicom</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">vreg</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dbdicom</span><span class="w"> </span><span class="kn">import</span> <span class="n">Series</span>


<span class="k">def</span><span class="w"> </span><span class="nf">fill_slice_gaps</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">slice_thickness</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1"># slice_thickness - make thin slices for smoother interpolation</span>
    <span class="n">z</span><span class="p">,</span><span class="n">t</span> <span class="o">=</span> <span class="s1">&#39;SliceLocation&#39;</span><span class="p">,</span><span class="s1">&#39;AcquisitionTime&#39;</span>
    <span class="k">if</span> <span class="n">slice_thickness</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">thick</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="s1">&#39;SliceThickness&#39;</span><span class="p">)</span>
        <span class="n">series</span><span class="o">.</span><span class="n">set_values</span><span class="p">(</span><span class="n">slice_thickness</span><span class="p">,</span> <span class="s1">&#39;SliceThickness&#39;</span><span class="p">)</span> 
    <span class="n">input_array</span> <span class="o">=</span> <span class="n">pixel_values</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="n">t</span><span class="p">),</span> <span class="n">on</span><span class="o">=</span><span class="n">ref</span><span class="p">)</span>
    <span class="n">input_geom</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mask_array</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="n">ref</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">geom</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">slice_thickness</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">series</span><span class="o">.</span><span class="n">set_values</span><span class="p">(</span><span class="n">thick</span><span class="p">,</span> <span class="s1">&#39;SliceThickness&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mask</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">mask_array</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="n">ref</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">t</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">series</span><span class="o">.</span><span class="n">message</span><span class="p">(</span><span class="s1">&#39;Interpolating slice gaps..&#39;</span><span class="p">)</span>
    <span class="n">output_array</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">fill_gaps</span><span class="p">(</span><span class="n">input_array</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">input_geom</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
    <span class="n">output_series</span> <span class="o">=</span> <span class="n">ref</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">SeriesDescription</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span><span class="o">.</span><span class="n">SeriesDescription</span> <span class="o">+</span> <span class="s1">&#39;_fill&#39;</span><span class="p">)</span>
    <span class="n">output_series</span><span class="o">.</span><span class="n">set_pixel_values</span><span class="p">(</span><span class="n">output_array</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="n">z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">output_series</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_equal_geometry</span><span class="p">(</span><span class="n">affine1</span><span class="p">,</span> <span class="n">affine2</span><span class="p">):</span>
    <span class="c1"># Check if both are the same, </span>
    <span class="c1"># ignoring the order in the list</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">affine2</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">affine2</span> <span class="o">=</span> <span class="p">[</span><span class="n">affine2</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">affine1</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">affine1</span> <span class="o">=</span> <span class="p">[</span><span class="n">affine1</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">affine1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">affine2</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="n">unmatched</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">affine2</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">a1</span> <span class="ow">in</span> <span class="n">affine1</span><span class="p">:</span>
        <span class="n">imatch</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">unmatched</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">a1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">affine2</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]):</span>
                <span class="c1"># If a slice group with the same affine is found, </span>
                <span class="c1"># check if the image dimensions are the same too.</span>
                <span class="n">dim1</span> <span class="o">=</span> <span class="n">a1</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">array</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">dim2</span> <span class="o">=</span> <span class="n">affine2</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">array</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
                <span class="k">if</span> <span class="n">dim1</span> <span class="o">==</span> <span class="n">dim2</span><span class="p">:</span>
                    <span class="n">imatch</span> <span class="o">=</span> <span class="n">i</span>
                    <span class="k">break</span>
        <span class="k">if</span> <span class="n">imatch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">unmatched</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">imatch</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">unmatched</span> <span class="o">==</span> <span class="p">[]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">map_to</span><span class="p">(</span><span class="n">source</span><span class="p">:</span><span class="n">Series</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span><span class="n">Series</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Map non-zero pixels onto another series&quot;&quot;&quot;</span>

    <span class="c1"># Get transformation matrix</span>
    <span class="n">source</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">message</span><span class="p">(</span><span class="s1">&#39;Loading transformation matrices..&#39;</span><span class="p">)</span>
    <span class="n">affine_source</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">affine_matrix</span><span class="p">()</span>
    <span class="n">affine_target</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">affine_matrix</span><span class="p">()</span> 
    <span class="k">if</span> <span class="n">_equal_geometry</span><span class="p">(</span><span class="n">affine_source</span><span class="p">,</span> <span class="n">affine_target</span><span class="p">):</span> 
        <span class="n">source</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">hide</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">source</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">affine_target</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">mapped_series</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">affine_slice_group</span> <span class="ow">in</span> <span class="n">affine_target</span><span class="p">:</span>
            <span class="n">slice_group_target</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">new_sibling</span><span class="p">()</span>
            <span class="n">slice_group_target</span><span class="o">.</span><span class="n">adopt</span><span class="p">(</span><span class="n">affine_slice_group</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">mapped</span> <span class="o">=</span> <span class="n">_map_series_to_slice_group</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">slice_group_target</span><span class="p">,</span> <span class="n">affine_source</span><span class="p">,</span> <span class="n">affine_slice_group</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">mapped_series</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mapped</span><span class="p">)</span>
            <span class="n">slice_group_target</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span><span class="o">.</span><span class="n">SeriesDescription</span> <span class="o">+</span> <span class="s1">&#39; [overlay]&#39;</span>
        <span class="n">mapped_series</span> <span class="o">=</span> <span class="n">dbdicom</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">mapped_series</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">mapped_series</span><span class="o">.</span><span class="n">SeriesDescription</span> <span class="o">=</span> <span class="n">desc</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mapped_series</span> <span class="o">=</span> <span class="n">_map_series_to_slice_group</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">affine_source</span><span class="p">,</span> <span class="n">affine_target</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mapped_series</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_map_series_to_slice_group</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">affine_source</span><span class="p">,</span> <span class="n">affine_target</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">affine_source</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">array_target</span><span class="p">,</span> <span class="n">headers_target</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;SliceLocation&#39;</span><span class="p">,</span><span class="s1">&#39;AcquisitionTime&#39;</span><span class="p">],</span> <span class="n">pixels_first</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">array</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">affine_slice_group</span> <span class="ow">in</span> <span class="n">affine_source</span><span class="p">:</span>
            <span class="n">slice_group_source</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">new_sibling</span><span class="p">()</span>
            <span class="n">slice_group_source</span><span class="o">.</span><span class="n">adopt</span><span class="p">(</span><span class="n">affine_slice_group</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">array_sg</span><span class="p">,</span> <span class="n">weight_sg</span> <span class="o">=</span> <span class="n">_map_slice_group_to_slice_group_array</span><span class="p">(</span><span class="n">slice_group_source</span><span class="p">,</span> <span class="n">affine_slice_group</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">target</span><span class="p">,</span> <span class="n">affine_target</span><span class="p">,</span> <span class="n">array_target</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">slice_group_source</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">array</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">array</span> <span class="o">=</span> <span class="n">array_sg</span>
                <span class="n">weight</span> <span class="o">=</span> <span class="n">weight_sg</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">array</span> <span class="o">+=</span> <span class="n">weight_sg</span><span class="o">*</span><span class="n">array_sg</span>
                <span class="n">weight</span> <span class="o">+=</span> <span class="n">weight_sg</span>   
        <span class="n">nozero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">weight</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">array</span><span class="p">[</span><span class="n">nozero</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">nozero</span><span class="p">]</span><span class="o">/</span><span class="n">weight</span><span class="p">[</span><span class="n">nozero</span><span class="p">]</span>

        <span class="c1"># Create new series</span>
        <span class="n">mapped_series</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">new_sibling</span><span class="p">(</span><span class="n">suffix</span><span class="o">=</span><span class="s1">&#39;overlay&#39;</span><span class="p">)</span>
        <span class="n">ns</span><span class="p">,</span> <span class="n">nt</span><span class="p">,</span> <span class="n">nk</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">cnt</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nk</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ns</span><span class="p">):</span>
                    <span class="n">cnt</span><span class="o">+=</span><span class="mi">1</span>
                    <span class="n">source</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">ns</span><span class="o">*</span><span class="n">nt</span><span class="o">*</span><span class="n">nk</span><span class="p">,</span> <span class="s1">&#39;Saving results..&#39;</span><span class="p">)</span>
                    <span class="n">image</span> <span class="o">=</span> <span class="n">headers_target</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy_to</span><span class="p">(</span><span class="n">mapped_series</span><span class="p">)</span>
                    <span class="n">image</span><span class="o">.</span><span class="n">AcquisitionTime</span> <span class="o">=</span> <span class="n">t</span>
                    <span class="n">image</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">array</span><span class="p">[:,:,</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">k</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">mapped_series</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_map_slice_group_to_slice_group</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">affine_source</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">target</span><span class="p">,</span> <span class="n">affine_target</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    

<span class="k">def</span><span class="w"> </span><span class="nf">_map_slice_group_to_slice_group_array</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">affine_source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">output_affine</span><span class="p">,</span> <span class="n">target_shape</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

    <span class="c1"># Get source arrays</span>
    <span class="n">array_source</span><span class="p">,</span> <span class="n">headers_source</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;SliceLocation&#39;</span><span class="p">,</span><span class="s1">&#39;AcquisitionTime&#39;</span><span class="p">],</span> <span class="n">pixels_first</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="c1"># Get message status updates</span>
    <span class="n">source_desc</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span><span class="o">.</span><span class="n">SeriesDescription</span>
    <span class="n">target_desc</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span><span class="o">.</span><span class="n">SeriesDescription</span>
    <span class="n">message</span> <span class="o">=</span> <span class="s1">&#39;Mapping &#39;</span> <span class="o">+</span> <span class="n">source_desc</span> <span class="o">+</span> <span class="s1">&#39; onto &#39;</span> <span class="o">+</span> <span class="n">target_desc</span>
    <span class="n">source</span><span class="o">.</span><span class="n">message</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

    <span class="n">array_mapped</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">target_shape</span> <span class="o">+</span> <span class="n">array_source</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">:])</span>
    <span class="n">weights_mapped</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">target_shape</span> <span class="o">+</span> <span class="n">array_source</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">:])</span>
    <span class="n">slice_thickness</span> <span class="o">=</span> <span class="n">headers_source</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">SliceThickness</span>

    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">array_source</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">array_source</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">4</span><span class="p">]):</span>
            <span class="n">array_mapped</span><span class="p">[:,:,:,</span><span class="n">t</span><span class="p">,</span><span class="n">k</span><span class="p">],</span> <span class="n">_</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">affine_reslice_slice_by_slice</span><span class="p">(</span>
                <span class="n">array_source</span><span class="p">[:,:,:,</span><span class="n">t</span><span class="p">,</span><span class="n">k</span><span class="p">],</span> <span class="n">affine_source</span><span class="p">,</span> 
                <span class="n">output_affine</span><span class="p">,</span> <span class="n">output_shape</span><span class="o">=</span><span class="n">target_shape</span><span class="p">,</span>
                <span class="n">slice_thickness</span> <span class="o">=</span> <span class="n">slice_thickness</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">weights_mapped</span><span class="p">[:,:,:,</span><span class="n">t</span><span class="p">,</span><span class="n">k</span><span class="p">],</span> <span class="n">_</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">affine_reslice_slice_by_slice</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">array_source</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">3</span><span class="p">]),</span> <span class="n">affine_source</span><span class="p">,</span> 
                <span class="n">output_affine</span><span class="p">,</span> <span class="n">output_shape</span><span class="o">=</span><span class="n">target_shape</span><span class="p">,</span>
                <span class="n">slice_thickness</span> <span class="o">=</span> <span class="n">slice_thickness</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">return</span> <span class="n">array_mapped</span><span class="p">,</span> <span class="n">weights_mapped</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_map_slice_group_to_slice_group</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">affine_source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">output_affine</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

    <span class="c1"># Get source arrays</span>
    <span class="n">array_source</span><span class="p">,</span> <span class="n">headers_source</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;SliceLocation&#39;</span><span class="p">,</span><span class="s1">&#39;AcquisitionTime&#39;</span><span class="p">],</span> <span class="n">pixels_first</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">array_target</span><span class="p">,</span> <span class="n">headers_target</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;SliceLocation&#39;</span><span class="p">,</span><span class="s1">&#39;AcquisitionTime&#39;</span><span class="p">],</span> <span class="n">pixels_first</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Get message status updates</span>
    <span class="n">source_desc</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span><span class="o">.</span><span class="n">SeriesDescription</span>
    <span class="n">target_desc</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span><span class="o">.</span><span class="n">SeriesDescription</span>
    <span class="n">message</span> <span class="o">=</span> <span class="s1">&#39;Mapping &#39;</span> <span class="o">+</span> <span class="n">source_desc</span> <span class="o">+</span> <span class="s1">&#39; onto &#39;</span> <span class="o">+</span> <span class="n">target_desc</span>
    <span class="n">source</span><span class="o">.</span><span class="n">message</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

    <span class="c1"># Create new series</span>
    <span class="c1"># Retain source acquisition times</span>
    <span class="c1"># Assign acquisition time of slice=0 to all slices</span>
    <span class="n">mapped_series</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">new_sibling</span><span class="p">(</span><span class="n">suffix</span><span class="o">=</span><span class="s1">&#39;overlay&#39;</span><span class="p">)</span>
    <span class="n">nt</span><span class="p">,</span> <span class="n">nk</span> <span class="o">=</span> <span class="n">array_source</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">array_source</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
    <span class="n">ns</span> <span class="o">=</span> <span class="n">headers_target</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 
    <span class="n">acq_times</span> <span class="o">=</span> <span class="p">[</span><span class="n">headers_source</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">AcquisitionTime</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="p">)]</span>
    <span class="n">slice_thickness</span> <span class="o">=</span> <span class="n">headers_source</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">SliceThickness</span>
    <span class="n">cnt</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nk</span><span class="p">):</span>
            <span class="n">array_mapped</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">affine_reslice_slice_by_slice</span><span class="p">(</span>
                <span class="n">array_source</span><span class="p">[:,:,:,</span><span class="n">t</span><span class="p">,</span><span class="n">k</span><span class="p">],</span> 
                <span class="n">affine_source</span><span class="p">,</span> 
                <span class="n">output_affine</span><span class="p">,</span> 
                <span class="n">output_shape</span><span class="o">=</span><span class="n">array_target</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span>
                <span class="n">slice_thickness</span> <span class="o">=</span> <span class="n">slice_thickness</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ns</span><span class="p">):</span>
                <span class="n">cnt</span><span class="o">+=</span><span class="mi">1</span>
                <span class="n">source</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">ns</span><span class="o">*</span><span class="n">nt</span><span class="o">*</span><span class="n">nk</span><span class="p">,</span> <span class="s1">&#39;Saving results..&#39;</span><span class="p">)</span>
                <span class="n">image</span> <span class="o">=</span> <span class="n">headers_target</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy_to</span><span class="p">(</span><span class="n">mapped_series</span><span class="p">)</span>
                <span class="n">image</span><span class="o">.</span><span class="n">AcquisitionTime</span> <span class="o">=</span> <span class="n">acq_times</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
                <span class="n">image</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">array_mapped</span><span class="p">[:,:,</span><span class="n">s</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">mapped_series</span>


<span class="k">def</span><span class="w"> </span><span class="nf">mask_array</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;InstanceNumber&#39;</span><span class="p">,</span> <span class="n">geom</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">on</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># geom keyword not yet implemented</span>
        <span class="k">return</span> <span class="n">dbdicom</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">sortby</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;SliceLocation&#39;</span><span class="p">,</span> <span class="n">dim</span><span class="p">],</span> <span class="n">mask</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pixels_first</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">first_volume</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Get transformation matrix</span>
    <span class="n">mask</span><span class="o">.</span><span class="n">message</span><span class="p">(</span><span class="s1">&#39;Loading transformation matrices..&#39;</span><span class="p">)</span>
    <span class="n">affine_source</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">affine_matrix</span><span class="p">()</span>
    <span class="n">affine_target</span> <span class="o">=</span> <span class="n">on</span><span class="o">.</span><span class="n">affine_matrix</span><span class="p">()</span> 

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">affine_target</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">mapped_arrays</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mapped_headers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">affine_slice_group_target</span> <span class="ow">in</span> <span class="n">affine_target</span><span class="p">:</span>
            <span class="n">mapped</span><span class="p">,</span> <span class="n">headers</span> <span class="o">=</span> <span class="n">_map_mask_series_to_slice_group</span><span class="p">(</span>
                <span class="n">mask</span><span class="p">,</span> 
                <span class="n">affine_slice_group_target</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> 
                <span class="n">affine_source</span><span class="p">,</span> 
                <span class="n">affine_slice_group_target</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span> <span class="n">geom</span><span class="o">=</span><span class="n">geom</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">mapped_arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mapped</span><span class="p">)</span>
            <span class="n">mapped_headers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">headers</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mapped_arrays</span><span class="p">,</span> <span class="n">mapped_headers</span> <span class="o">=</span> <span class="n">_map_mask_series_to_slice_group</span><span class="p">(</span>
            <span class="n">mask</span><span class="p">,</span> <span class="n">on</span><span class="p">,</span> <span class="n">affine_source</span><span class="p">,</span> <span class="n">affine_target</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span> <span class="n">geom</span><span class="o">=</span><span class="n">geom</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mapped_arrays</span><span class="p">,</span> <span class="n">mapped_headers</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_map_mask_series_to_slice_group</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">affine_source</span><span class="p">,</span> <span class="n">affine_target</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">affine_source</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">mapped_arrays</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">affine_slice_group</span> <span class="ow">in</span> <span class="n">affine_source</span><span class="p">:</span>
            <span class="n">mapped</span><span class="p">,</span> <span class="n">headers</span> <span class="o">=</span> <span class="n">_map_mask_slice_group_to_slice_group</span><span class="p">(</span>
                <span class="n">affine_slice_group</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> 
                <span class="n">target</span><span class="p">,</span> 
                <span class="n">affine_slice_group</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                <span class="n">affine_target</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">mapped_arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mapped</span><span class="p">)</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">mapped_arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mapped_arrays</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">mapped_arrays</span><span class="p">[</span><span class="mi">2</span><span class="p">:]:</span>
            <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">array</span><span class="p">,</span> <span class="n">headers</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_map_mask_slice_group_to_slice_group</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">affine_source</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">affine_target</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_map_mask_slice_group_to_slice_group</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">affine_source</span><span class="p">,</span> <span class="n">affine_target</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;InstanceNumber&#39;</span><span class="p">,</span> <span class="n">geom</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">source</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">status</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">status</span>

    <span class="c1"># Get arrays</span>
    <span class="n">array_source</span><span class="p">,</span> <span class="n">headers_source</span> <span class="o">=</span> <span class="n">dbdicom</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">sortby</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;SliceLocation&#39;</span><span class="p">,</span><span class="n">dim</span><span class="p">],</span> <span class="n">pixels_first</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">first_volume</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">array_target</span><span class="p">,</span> <span class="n">headers_target</span> <span class="o">=</span> <span class="n">dbdicom</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">sortby</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;SliceLocation&#39;</span><span class="p">,</span><span class="n">dim</span><span class="p">],</span> <span class="n">pixels_first</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">first_volume</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">geom</span><span class="p">:</span>
        <span class="c1"># mask shows geometry of source</span>
        <span class="n">array_source</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">array_source</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        
    <span class="c1"># For mapping mask onto series, the time dimensions must be the same.</span>
    <span class="c1"># If they are not, the mask is extruded on to the series time dimensions.</span>
    <span class="n">nk</span> <span class="o">=</span> <span class="n">array_target</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">array_source</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">!=</span> <span class="n">nk</span><span class="p">:</span>
        <span class="n">status</span><span class="o">.</span><span class="n">message</span><span class="p">(</span><span class="s1">&#39;Extruding ROI on time series..&#39;</span><span class="p">)</span>
        <span class="n">array_source</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">array_source</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">array_source</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">array_source</span><span class="p">[:,:,:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">nk</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    
    <span class="c1"># If the dimensions and affines are equal there is nothing to do</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">affine_source</span><span class="p">,</span> <span class="n">affine_target</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">array_source</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">array_target</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="c1"># Make sure the result is a mask</span>
            <span class="n">array_source</span><span class="p">[</span><span class="n">array_source</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">array_source</span><span class="p">[</span><span class="n">array_source</span> <span class="o">&lt;=</span> <span class="mf">0.5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="n">array_source</span><span class="p">,</span> <span class="n">headers_target</span>

    <span class="n">slice_thickness</span> <span class="o">=</span> <span class="n">headers_source</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">SliceThickness</span>
    <span class="n">array_target</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">array_target</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">array_source</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">],))</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">array_source</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]):</span>
        <span class="n">array_target</span><span class="p">[:,:,:,</span><span class="n">t</span><span class="p">],</span> <span class="n">_</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">affine_reslice_slice_by_slice</span><span class="p">(</span>
            <span class="n">array_source</span><span class="p">[:,:,:,</span><span class="n">t</span><span class="p">],</span> 
            <span class="n">affine_source</span><span class="p">,</span> 
            <span class="n">affine_target</span><span class="p">,</span> 
            <span class="n">output_shape</span> <span class="o">=</span> <span class="n">array_target</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span>
            <span class="n">slice_thickness</span> <span class="o">=</span> <span class="n">slice_thickness</span><span class="p">,</span>
            <span class="n">mask</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">array_target</span><span class="p">,</span> <span class="n">headers_target</span>


<span class="k">def</span><span class="w"> </span><span class="nf">mask_statistics</span><span class="p">(</span><span class="n">masks</span><span class="p">,</span> <span class="n">images</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">masks</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">masks</span> <span class="o">=</span> <span class="p">[</span><span class="n">masks</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">images</span> <span class="o">=</span> <span class="p">[</span><span class="n">images</span><span class="p">]</span>
    <span class="n">df_all_masks</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">mask</span> <span class="ow">in</span> <span class="n">masks</span><span class="p">:</span>
        <span class="n">df_mask</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">img</span> <span class="ow">in</span> <span class="n">images</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">mask_values</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">img</span><span class="p">)</span>
            <span class="n">df_img</span> <span class="o">=</span> <span class="n">mask_data_statistics</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">img</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">df_mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">df_mask</span> <span class="o">=</span> <span class="n">df_img</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">df_mask</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df_mask</span><span class="p">,</span> <span class="n">df_img</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">df_all_masks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">df_all_masks</span> <span class="o">=</span> <span class="n">df_mask</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">df_all_masks</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df_all_masks</span><span class="p">,</span> <span class="n">df_mask</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">df_all_masks</span>


<span class="k">def</span><span class="w"> </span><span class="nf">mask_values</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">image</span><span class="p">):</span>
    <span class="n">msk_arr</span><span class="p">,</span> <span class="n">img_hdrs</span> <span class="o">=</span> <span class="n">mask_array</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="n">image</span><span class="p">)</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">_mask_data_slice_groups</span><span class="p">(</span><span class="n">msk_arr</span><span class="p">,</span> <span class="n">img_hdrs</span><span class="p">)</span> 
    <span class="k">return</span> <span class="n">values</span>


<span class="k">def</span><span class="w"> </span><span class="nf">mask_data_statistics</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">image</span><span class="p">):</span>
    <span class="c1"># Get mask array</span>
    <span class="c1">#msk_arr, img_hdrs = mask_array(mask, on=image)</span>
    <span class="c1">#data = _mask_data_slice_groups(msk_arr, img_hdrs)</span>
    <span class="n">props</span> <span class="o">=</span> <span class="n">_summary_stats</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">instance</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span>
    <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;PatientID&#39;</span><span class="p">,</span> <span class="s1">&#39;StudyDescription&#39;</span><span class="p">,</span> <span class="s1">&#39;SeriesDescription&#39;</span><span class="p">,</span> <span class="s1">&#39;Region of Interest&#39;</span><span class="p">,</span> <span class="s1">&#39;Parameter&#39;</span><span class="p">,</span> <span class="s1">&#39;Value&#39;</span><span class="p">,</span> <span class="s1">&#39;Unit&#39;</span><span class="p">]</span>
    <span class="n">ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">instance</span><span class="o">.</span><span class="n">PatientID</span><span class="p">,</span> <span class="n">instance</span><span class="o">.</span><span class="n">StudyDescription</span><span class="p">,</span> <span class="n">instance</span><span class="o">.</span><span class="n">SeriesDescription</span><span class="p">,</span> <span class="n">mask</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span><span class="o">.</span><span class="n">SeriesDescription</span><span class="p">]</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">par</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">props</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">ids</span> <span class="o">+</span> <span class="p">[</span><span class="n">par</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">]</span>
        <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_mask_data_slice_groups</span><span class="p">(</span><span class="n">msk_arr</span><span class="p">,</span> <span class="n">img_hdrs</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">msk_arr</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span> 
        <span class="c1"># Loop over slice groups</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">_mask_data</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">img_hdrs</span><span class="p">[</span><span class="n">m</span><span class="p">])</span> <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">arr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">msk_arr</span><span class="p">)]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">data</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">data</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="c1"># single slice group</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">_mask_data</span><span class="p">(</span><span class="n">msk_arr</span><span class="p">,</span> <span class="n">img_hdrs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_mask_data</span><span class="p">(</span><span class="n">msk_arr</span><span class="p">,</span> <span class="n">imgs</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="n">imgs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">image</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">msk_arr</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">msk_arr</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">array</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>
                <span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">mask</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">]</span>  
                <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">data</span> <span class="o">==</span> <span class="p">[]:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    

<span class="k">def</span><span class="w"> </span><span class="nf">_summary_stats</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{}</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;Mean&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">),</span>
        <span class="s1">&#39;Standard deviation&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">data</span><span class="p">),</span>
        <span class="s1">&#39;Maximum&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">data</span><span class="p">),</span>
        <span class="s1">&#39;Minimum&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">data</span><span class="p">),</span>
        <span class="s1">&#39;2.5% percentile&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">),</span>
        <span class="s1">&#39;5% percentile&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
        <span class="s1">&#39;10% percentile&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
        <span class="s1">&#39;25% percentile&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">25</span><span class="p">),</span>
        <span class="s1">&#39;Median&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span>
        <span class="s1">&#39;75% percentile&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">75</span><span class="p">),</span>
        <span class="s1">&#39;90% percentile&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">90</span><span class="p">),</span>
        <span class="s1">&#39;95% percentile&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">95</span><span class="p">),</span>
        <span class="s1">&#39;97.5% percentile&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mf">97.5</span><span class="p">),</span>
        <span class="s1">&#39;Range&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">data</span><span class="p">),</span>
        <span class="s1">&#39;Interquartile range&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">75</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">25</span><span class="p">),</span>
        <span class="s1">&#39;90 percent range&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">95</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
        <span class="s1">&#39;Coefficient of variation&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">),</span>
        <span class="s1">&#39;Heterogeneity&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">95</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span>
        <span class="s1">&#39;Kurtosis&#39;</span><span class="p">:</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">kurtosis</span><span class="p">(</span><span class="n">data</span><span class="p">),</span>
        <span class="s1">&#39;Skewness&#39;</span><span class="p">:</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">skew</span><span class="p">(</span><span class="n">data</span><span class="p">),</span>
    <span class="p">}</span>

<span class="c1"># no longer public - replace by vreg.pixel_values()</span>
<span class="c1"># Needs an approach that does no create a DICOM series first</span>
<span class="k">def</span><span class="w"> </span><span class="nf">array</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the array overlaid on another series&quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">on</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">array</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">series_map</span> <span class="o">=</span> <span class="n">map_to</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">on</span><span class="p">)</span>
        <span class="n">array</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">series_map</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">series_map</span> <span class="o">!=</span> <span class="n">series</span><span class="p">:</span>
            <span class="n">series_map</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">array</span>

<span class="k">def</span><span class="w"> </span><span class="nf">pixel_values</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;InstanceNumber&#39;</span><span class="p">,),</span> <span class="n">on</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1"># Wrapper for array following new API</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="p">(</span><span class="n">dims</span><span class="p">,)</span>

    <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="n">on</span><span class="p">,</span> <span class="n">sortby</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">dims</span><span class="p">),</span> <span class="n">pixels_first</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">first_volume</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>




<span class="k">def</span><span class="w"> </span><span class="nf">print_current</span><span class="p">(</span><span class="n">vk</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">vk</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_input_volume</span><span class="p">(</span><span class="n">series</span><span class="p">:</span><span class="n">Series</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">series</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="n">desc</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span><span class="o">.</span><span class="n">SeriesDescription</span>
    <span class="n">affine</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">unique_affines</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">affine</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;This function only works for series with a single slice group. </span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;Multiple slice groups detected in &#39;</span> <span class="o">+</span> <span class="n">desc</span> <span class="o">+</span> <span class="s1">&#39; - please split the series first.&#39;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">affine</span> <span class="o">=</span> <span class="n">affine</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:]</span>
    <span class="c1">#array, headers = series.array(&#39;SliceLocation&#39;, pixels_first=True, first_volume=True)</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">pixel_values</span><span class="p">(</span><span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;SliceLocation&#39;</span><span class="p">,))</span>
    <span class="k">if</span> <span class="n">array</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Series &#39;</span> <span class="o">+</span> <span class="n">desc</span> <span class="o">+</span> <span class="s1">&#39; is empty - cannot perform alignment.&#39;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>  
    <span class="k">return</span> <span class="n">array</span><span class="p">,</span> <span class="n">affine</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_input</span><span class="p">(</span><span class="n">moving</span><span class="p">,</span> <span class="n">static</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>

    <span class="n">array_moving</span><span class="p">,</span> <span class="n">affine_moving</span> <span class="o">=</span> <span class="n">_get_input_volume</span><span class="p">(</span><span class="n">moving</span><span class="p">)</span>
    <span class="n">array_static</span><span class="p">,</span> <span class="n">affine_static</span> <span class="o">=</span> <span class="n">_get_input_volume</span><span class="p">(</span><span class="n">static</span><span class="p">)</span>
    
    <span class="n">moving</span><span class="o">.</span><span class="n">message</span><span class="p">(</span><span class="s1">&#39;Performing coregistration. Please be patient. Its hard work and I need to concentrate..&#39;</span><span class="p">)</span>
    
    <span class="c1"># If a region is provided, use it extract a bounding box around the static array</span>
    <span class="k">if</span> <span class="n">region</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">array_region</span><span class="p">,</span> <span class="n">affine_region</span> <span class="o">=</span> <span class="n">_get_input_volume</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>
        <span class="n">array_static</span><span class="p">,</span> <span class="n">affine_static</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">mask_volume</span><span class="p">(</span><span class="n">array_static</span><span class="p">,</span> <span class="n">affine_static</span><span class="p">,</span> <span class="n">array_region</span><span class="p">,</span> <span class="n">affine_region</span><span class="p">,</span> <span class="n">margin</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">array_static</span><span class="p">,</span> <span class="n">affine_static</span><span class="p">,</span> <span class="n">array_moving</span><span class="p">,</span> <span class="n">affine_moving</span>



<div class="viewcode-block" id="find_translation">
<a class="viewcode-back" href="../../../generated/api/dbdicom.extensions.vreg.find_translation.html#dbdicom.extensions.vreg.find_translation">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">find_translation</span><span class="p">(</span><span class="n">moving</span><span class="p">:</span><span class="n">Series</span><span class="p">,</span> <span class="n">static</span><span class="p">:</span><span class="n">Series</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;mutual information&#39;</span><span class="p">,</span> <span class="n">region</span><span class="p">:</span><span class="n">Series</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">margin</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find the translation that maps a moving volume onto a static volume.</span>

<span class="sd">    Args:</span>
<span class="sd">        moving (dbdicom.Series): Series with the moving volume.</span>
<span class="sd">        static (dbdicom.Series): Series with the static volume</span>
<span class="sd">        tolerance (float, optional): Positive tolerance parameter to decide convergence of the gradient descent. A smaller value means a more accurate solution but also a lomger computation time. Defaults to 0.1.</span>
<span class="sd">        metric (str, option): Determines which metric to use in the optimization. Current options are &#39;mutual information&#39; (default) or &#39;sum of squares&#39;.</span>
<span class="sd">        region (dbdicom.Series, optional): Series with region of interest to restrict the alignment. The translation will be chosen based on the goodness of the alignment in the bounding box of this region. If none is provided, the entire volume is used. Defaults to None.</span>
<span class="sd">        margin (float, optional): in case a region is provided, this specifies a margin (in mm) to take around the region. Default is 0 (no margin)</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: 3-element numpy array with values of the translation that maps the moving volume on to the static volume.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">array_static</span><span class="p">,</span> <span class="n">affine_static</span><span class="p">,</span> <span class="n">array_moving</span><span class="p">,</span> <span class="n">affine_moving</span> <span class="o">=</span> <span class="n">_get_input</span><span class="p">(</span><span class="n">moving</span><span class="p">,</span> <span class="n">static</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="n">region</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="n">margin</span><span class="p">)</span>

    <span class="c1"># Define initial values and optimization</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">static_pixel_spacing</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">affine_components</span><span class="p">(</span><span class="n">affine_static</span><span class="p">)</span>
    <span class="n">optimization</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="s1">&#39;GD&#39;</span><span class="p">,</span> 
        <span class="s1">&#39;options&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;gradient step&#39;</span><span class="p">:</span> <span class="n">static_pixel_spacing</span><span class="p">,</span> <span class="s1">&#39;tolerance&#39;</span><span class="p">:</span> <span class="n">tolerance</span><span class="p">},</span>
        <span class="s1">&#39;callback&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">vk</span><span class="p">:</span> <span class="n">moving</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">message</span><span class="p">(</span><span class="s1">&#39;Current parameter: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">vk</span><span class="p">)),</span>
    <span class="p">}</span>
    <span class="n">func</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;sum of squares&#39;</span><span class="p">:</span> <span class="n">vreg</span><span class="o">.</span><span class="n">sum_of_squares</span><span class="p">,</span>
        <span class="s1">&#39;mutual information&#39;</span><span class="p">:</span> <span class="n">vreg</span><span class="o">.</span><span class="n">mutual_information</span><span class="p">,</span>
        <span class="s1">&#39;interaction&#39;</span><span class="p">:</span> <span class="n">vreg</span><span class="o">.</span><span class="n">interaction</span><span class="p">,</span>
    <span class="p">}</span>
    
    <span class="c1"># Align volumes</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">translation_estimate</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">align</span><span class="p">(</span>
            <span class="n">moving</span> <span class="o">=</span> <span class="n">array_moving</span><span class="p">,</span> 
            <span class="n">moving_affine</span> <span class="o">=</span> <span class="n">affine_moving</span><span class="p">,</span> 
            <span class="n">static</span> <span class="o">=</span> <span class="n">array_static</span><span class="p">,</span> 
            <span class="n">static_affine</span> <span class="o">=</span> <span class="n">affine_static</span><span class="p">,</span> 
            <span class="n">parameters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> 
            <span class="n">resolutions</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> 
            <span class="n">transformation</span> <span class="o">=</span>  <span class="n">vreg</span><span class="o">.</span><span class="n">translate</span><span class="p">,</span>
            <span class="n">metric</span> <span class="o">=</span> <span class="n">func</span><span class="p">[</span><span class="n">metric</span><span class="p">],</span>
            <span class="n">optimization</span> <span class="o">=</span> <span class="n">optimization</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Failed to align volumes..&#39;</span><span class="p">)</span>
        <span class="n">translation_estimate</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="n">translation_estimate</span></div>



<div class="viewcode-block" id="apply_translation">
<a class="viewcode-back" href="../../../generated/api/dbdicom.extensions.vreg.apply_translation.html#dbdicom.extensions.vreg.apply_translation">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">apply_translation</span><span class="p">(</span><span class="n">series_moving</span><span class="p">:</span><span class="n">Series</span><span class="p">,</span> <span class="n">parameters</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span><span class="n">Series</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Series</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply active translation of an image volume.</span>

<span class="sd">    Args:</span>
<span class="sd">        series_moving (dbdicom.Series): Series containing the volune to be moved.</span>
<span class="sd">        parameters (np.ndarray): three-element numpy array with coordinates of the translation in the absolute reference frame (mm).</span>
<span class="sd">        target (dbdicom.Series, optional): If provided, the result is mapped onto the geometry of this series. If none is provided, the result has the same geometry of the moving series. Defaults to None.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the moving series contains multiple slice groups with different orientations. </span>
<span class="sd">        ValueError: If the array to be moved is empty.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dbdicom.Series: Sibling dbdicom series in the same study, containing the translated volume.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">desc_moving</span> <span class="o">=</span> <span class="n">series_moving</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span><span class="o">.</span><span class="n">SeriesDescription</span>
    <span class="n">affine_moving</span> <span class="o">=</span> <span class="n">series_moving</span><span class="o">.</span><span class="n">unique_affines</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">affine_moving</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Multiple slice groups detected in &#39;</span> <span class="o">+</span> <span class="n">desc_moving</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;This function only works for series with a single slice group. </span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;Please split the series first.&#39;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">affine_moving</span> <span class="o">=</span> <span class="n">affine_moving</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:]</span>

    <span class="n">array_moving</span> <span class="o">=</span> <span class="n">series_moving</span><span class="o">.</span><span class="n">pixel_values</span><span class="p">(</span><span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;SliceLocation&#39;</span><span class="p">,))</span>
    <span class="k">if</span> <span class="n">array_moving</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">desc_moving</span> <span class="o">+</span> <span class="s1">&#39; is empty - cannot perform alignment.&#39;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">target</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">shape_moved</span> <span class="o">=</span> <span class="n">array_moving</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">affine_moved</span> <span class="o">=</span> <span class="n">affine_moving</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">array_moved</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">pixel_values</span><span class="p">(</span><span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;SliceLocation&#39;</span><span class="p">,))</span>
        <span class="n">shape_moved</span> <span class="o">=</span> <span class="n">array_moved</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">affine_moved</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">affine</span><span class="p">()</span>

    <span class="n">series_moving</span><span class="o">.</span><span class="n">message</span><span class="p">(</span><span class="s1">&#39;Applying translation..&#39;</span><span class="p">)</span>   
    <span class="k">if</span> <span class="n">description</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">description</span> <span class="o">=</span> <span class="n">desc_moving</span> <span class="o">+</span> <span class="s1">&#39; [translation]&#39;</span>
    <span class="n">array_moved</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">array_moving</span><span class="p">,</span> <span class="n">affine_moving</span><span class="p">,</span> <span class="n">shape_moved</span><span class="p">,</span> <span class="n">affine_moved</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>
    <span class="n">series_moved</span> <span class="o">=</span> <span class="n">series_moving</span><span class="o">.</span><span class="n">new_sibling</span><span class="p">(</span><span class="n">SeriesDescription</span><span class="o">=</span><span class="n">description</span><span class="p">)</span>
    <span class="n">series_moved</span><span class="o">.</span><span class="n">set_pixel_values</span><span class="p">(</span><span class="n">array_moved</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;SliceLocation&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">array_moved</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])})</span>
    <span class="n">series_moved</span><span class="o">.</span><span class="n">set_affine</span><span class="p">(</span><span class="n">affine_moved</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">series_moved</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">apply_passive_translation</span><span class="p">(</span><span class="n">series_moving</span><span class="p">:</span><span class="n">Series</span><span class="p">,</span> <span class="n">parameters</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Series</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply passive translation of an image volume.</span>

<span class="sd">    Args:</span>
<span class="sd">        series_moving (dbdicom.Series): Series containing the volune to be moved.</span>
<span class="sd">        parameters (np.ndarray): 6-element numpy array with values of the translation (first 3 elements) and rotation vector (last 3 elements) that map the moving volume on to the static volume. The vectors are defined in an absolute reference frame in units of mm.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the moving series contains multiple slice groups with different orentations. </span>
<span class="sd">        ValueError: If the array to be moved is empty.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dbdicom.Series: Sibling dbdicom series in the same study, containing the transformed volume.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">desc_moving</span> <span class="o">=</span> <span class="n">series_moving</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span><span class="o">.</span><span class="n">SeriesDescription</span>
    <span class="n">affine_moving</span> <span class="o">=</span> <span class="n">series_moving</span><span class="o">.</span><span class="n">unique_affines</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">affine_moving</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Multiple slice groups detected in &#39;</span> <span class="o">+</span> <span class="n">desc_moving</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;This function only works for series with a single slice group. </span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;Please split the series first.&#39;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">affine_moving</span> <span class="o">=</span> <span class="n">affine_moving</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:]</span>

    <span class="n">series_moving</span><span class="o">.</span><span class="n">message</span><span class="p">(</span><span class="s1">&#39;Applying passive rigid transformation..&#39;</span><span class="p">)</span>
    <span class="n">output_affine</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">passive_translation</span><span class="p">(</span><span class="n">affine_moving</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>
    <span class="n">series_moved</span> <span class="o">=</span> <span class="n">series_moving</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">SeriesDescription</span> <span class="o">=</span> <span class="n">desc_moving</span> <span class="o">+</span> <span class="s1">&#39; [passive translation]&#39;</span><span class="p">)</span>
    <span class="n">series_moved</span><span class="o">.</span><span class="n">set_affine</span><span class="p">(</span><span class="n">output_affine</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;SliceLocation&#39;</span><span class="p">,),</span> <span class="n">multislice</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">series_moved</span>


<div class="viewcode-block" id="find_rigid_transformation">
<a class="viewcode-back" href="../../../generated/api/dbdicom.extensions.vreg.find_rigid_transformation.html#dbdicom.extensions.vreg.find_rigid_transformation">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">find_rigid_transformation</span><span class="p">(</span><span class="n">moving</span><span class="p">:</span><span class="n">Series</span><span class="p">,</span> <span class="n">static</span><span class="p">:</span><span class="n">Series</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;mutual information&#39;</span><span class="p">,</span> <span class="n">region</span><span class="p">:</span><span class="n">Series</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">margin</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">prereg</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find the rigid transform that maps a moving volume onto a static volume.</span>

<span class="sd">    Args:</span>
<span class="sd">        moving (dbdicom.Series): Series with the moving volume.</span>
<span class="sd">        static (dbdicom.Series): Series with the static volume</span>
<span class="sd">        tolerance (float, optional): Positive tolerance parameter to decide convergence of the gradient descent. A smaller value means a more accurate solution but also a lomger computation time. Defaults to 0.1.</span>
<span class="sd">        metric (str, option): Determines which metric to use in the optimization. Current options are &#39;mutual information&#39; (default) or &#39;sum of squares&#39;.</span>
<span class="sd">        region (dbdicom.Series, optional): Series with region of interest to restrict the alignment. The rigid transform will be chosen based on the goodness of the alignment in the bounding box of this region. If none is provided, the entire volume is used. Defaults to None.</span>
<span class="sd">        margin (float, optional): in case a region is provided, this specifies a margin (in mm) to take around the region. Default is 0 (no margin).</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: 6-element numpy array with values of the translation (first 3 elements) and rotation vector (last 3 elements) that map the moving volume on to the static volume. The vectors are defined in an absolute reference frame in units of mm.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">prereg</span><span class="p">:</span>
        <span class="n">translation</span> <span class="o">=</span> <span class="n">find_translation</span><span class="p">(</span><span class="n">moving</span><span class="p">,</span> <span class="n">static</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="n">region</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="n">margin</span><span class="p">)</span>
        <span class="n">rigid_estimate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">translation</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rigid_estimate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="n">array_static</span><span class="p">,</span> <span class="n">affine_static</span><span class="p">,</span> <span class="n">array_moving</span><span class="p">,</span> <span class="n">affine_moving</span> <span class="o">=</span> <span class="n">_get_input</span><span class="p">(</span><span class="n">moving</span><span class="p">,</span> <span class="n">static</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="n">region</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="n">margin</span><span class="p">)</span>
    
    <span class="c1"># Define initial values and optimization</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">static_pixel_spacing</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">affine_components</span><span class="p">(</span><span class="n">affine_static</span><span class="p">)</span>
    <span class="n">rot_gradient_step</span><span class="p">,</span> <span class="n">translation_gradient_step</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">affine_resolution</span><span class="p">(</span><span class="n">array_static</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">static_pixel_spacing</span><span class="p">)</span>
    <span class="n">gradient_step</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="mf">1.0</span><span class="o">*</span><span class="n">rot_gradient_step</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">translation_gradient_step</span><span class="p">))</span>
    <span class="n">optimization</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="s1">&#39;GD&#39;</span><span class="p">,</span> 
        <span class="s1">&#39;options&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;gradient step&#39;</span><span class="p">:</span> <span class="n">gradient_step</span><span class="p">,</span> <span class="s1">&#39;tolerance&#39;</span><span class="p">:</span> <span class="n">tolerance</span><span class="p">},</span>
        <span class="s1">&#39;callback&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">vk</span><span class="p">:</span> <span class="n">moving</span><span class="o">.</span><span class="n">status</span><span class="o">.</span><span class="n">message</span><span class="p">(</span><span class="s1">&#39;Current parameter: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">vk</span><span class="p">)),</span>
    <span class="p">}</span>
    <span class="n">func</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;sum of squares&#39;</span><span class="p">:</span> <span class="n">vreg</span><span class="o">.</span><span class="n">sum_of_squares</span><span class="p">,</span>
        <span class="s1">&#39;mutual information&#39;</span><span class="p">:</span> <span class="n">vreg</span><span class="o">.</span><span class="n">mutual_information</span><span class="p">,</span>
        <span class="s1">&#39;interaction&#39;</span><span class="p">:</span> <span class="n">vreg</span><span class="o">.</span><span class="n">interaction</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1"># Align volumes</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">rigid_estimate</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">align</span><span class="p">(</span>
            <span class="n">moving</span> <span class="o">=</span> <span class="n">array_moving</span><span class="p">,</span> 
            <span class="n">moving_affine</span> <span class="o">=</span> <span class="n">affine_moving</span><span class="p">,</span> 
            <span class="n">static</span> <span class="o">=</span> <span class="n">array_static</span><span class="p">,</span> 
            <span class="n">static_affine</span> <span class="o">=</span> <span class="n">affine_static</span><span class="p">,</span> 
            <span class="n">parameters</span> <span class="o">=</span> <span class="n">rigid_estimate</span><span class="p">,</span>
            <span class="n">resolutions</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> 
            <span class="n">transformation</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">rigid</span><span class="p">,</span>
            <span class="n">metric</span> <span class="o">=</span> <span class="n">func</span><span class="p">[</span><span class="n">metric</span><span class="p">],</span>
            <span class="n">optimization</span> <span class="o">=</span> <span class="n">optimization</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Failed to align volumes..&#39;</span><span class="p">)</span>
        <span class="n">rigid_estimate</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="n">rigid_estimate</span></div>



<div class="viewcode-block" id="apply_rigid_transformation">
<a class="viewcode-back" href="../../../generated/api/dbdicom.extensions.vreg.apply_rigid_transformation.html#dbdicom.extensions.vreg.apply_rigid_transformation">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">apply_rigid_transformation</span><span class="p">(</span><span class="n">series_moving</span><span class="p">:</span><span class="n">Series</span><span class="p">,</span> <span class="n">parameters</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>  <span class="n">target</span><span class="p">:</span><span class="n">Series</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Series</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply rigid transformation of an image volume.</span>

<span class="sd">    Args:</span>
<span class="sd">        series_moving (dbdicom.Series): Series containing the volune to be moved.</span>
<span class="sd">        parameters (np.ndarray): 6-element numpy array with values of the translation (first 3 elements) and rotation vector (last 3 elements) that map the moving volume on to the static volume. The vectors are defined in an absolute reference frame in units of mm.</span>
<span class="sd">        target (dbdicom.Series, optional): If provided, the result is mapped onto the geometry of this series. If none is provided, the result has the same geometry of the moving series. Defaults to None.</span>
<span class="sd">        description (str, optional): Series description of the resulting series. Defaults to None.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the moving series contains multiple slice groups with different orentations. </span>
<span class="sd">        ValueError: If the array to be moved is empty.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dbdicom.Series: Sibling dbdicom series in the same study, containing the transformed volume.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: target is not the right word. geometry?</span>
    <span class="n">desc_moving</span> <span class="o">=</span> <span class="n">series_moving</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span><span class="o">.</span><span class="n">SeriesDescription</span>
    <span class="n">affine_moving</span> <span class="o">=</span> <span class="n">series_moving</span><span class="o">.</span><span class="n">unique_affines</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">affine_moving</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Multiple slice groups detected in &#39;</span> <span class="o">+</span> <span class="n">desc_moving</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;This function only works for series with a single slice group. </span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;Please split the series first.&#39;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">affine_moving</span> <span class="o">=</span> <span class="n">affine_moving</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:]</span>

    <span class="n">array_moving</span> <span class="o">=</span> <span class="n">series_moving</span><span class="o">.</span><span class="n">pixel_values</span><span class="p">(</span><span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;SliceLocation&#39;</span><span class="p">,))</span>
    <span class="k">if</span> <span class="n">array_moving</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">desc_moving</span> <span class="o">+</span> <span class="s1">&#39; is empty - cannot perform alignment.&#39;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">target</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">shape_moved</span> <span class="o">=</span> <span class="n">array_moving</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">affine_moved</span> <span class="o">=</span> <span class="n">affine_moving</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">array_moved</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">pixel_values</span><span class="p">(</span><span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;SliceLocation&#39;</span><span class="p">,))</span>
        <span class="n">shape_moved</span> <span class="o">=</span> <span class="n">array_moved</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">affine_moved</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">affine</span><span class="p">()</span>

    <span class="n">series_moving</span><span class="o">.</span><span class="n">message</span><span class="p">(</span><span class="s1">&#39;Applying rigid transformation..&#39;</span><span class="p">)</span>
    <span class="n">array_moved</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">rigid</span><span class="p">(</span><span class="n">array_moving</span><span class="p">,</span> <span class="n">affine_moving</span><span class="p">,</span> <span class="n">shape_moved</span><span class="p">,</span> <span class="n">affine_moved</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">description</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">description</span> <span class="o">=</span> <span class="n">desc_moving</span> <span class="o">+</span> <span class="s1">&#39; [rigid]&#39;</span>
    <span class="n">series_moved</span> <span class="o">=</span> <span class="n">series_moving</span><span class="o">.</span><span class="n">new_sibling</span><span class="p">(</span><span class="n">SeriesDescription</span> <span class="o">=</span> <span class="n">description</span><span class="p">)</span>
    <span class="n">series_moved</span><span class="o">.</span><span class="n">set_pixel_values</span><span class="p">(</span><span class="n">array_moved</span><span class="p">,</span> <span class="nb">slice</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;SliceLocation&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">array_moved</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])})</span>
    <span class="n">series_moved</span><span class="o">.</span><span class="n">set_affine</span><span class="p">(</span><span class="n">affine_moved</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">series_moved</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">apply_passive_rigid_transformation</span><span class="p">(</span><span class="n">series_moving</span><span class="p">:</span><span class="n">Series</span><span class="p">,</span> <span class="n">parameters</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span><span class="n">description</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Series</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply passive rigid transformation of an image volume.</span>

<span class="sd">    Args:</span>
<span class="sd">        series_moving (dbdicom.Series): Series containing the volune to be moved.</span>
<span class="sd">        parameters (np.ndarray): 6-element numpy array with values of the translation (first 3 elements) and rotation vector (last 3 elements) that map the moving volume on to the static volume. The vectors are defined in an absolute reference frame in units of mm.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the moving series contains multiple slice groups with different orentations. </span>
<span class="sd">        ValueError: If the array to be moved is empty.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dbdicom.Series: Sibling dbdicom series in the same study, containing the transformed volume.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">desc_moving</span> <span class="o">=</span> <span class="n">series_moving</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span><span class="o">.</span><span class="n">SeriesDescription</span>
    <span class="n">affine_moving</span> <span class="o">=</span> <span class="n">series_moving</span><span class="o">.</span><span class="n">unique_affines</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">affine_moving</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Multiple slice groups detected in &#39;</span> <span class="o">+</span> <span class="n">desc_moving</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;This function only works for series with a single slice group. </span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;Please split the series first.&#39;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">affine_moving</span> <span class="o">=</span> <span class="n">affine_moving</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:]</span>

    <span class="n">series_moving</span><span class="o">.</span><span class="n">message</span><span class="p">(</span><span class="s1">&#39;Applying passive rigid transformation..&#39;</span><span class="p">)</span>
    <span class="n">output_affine</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">passive_rigid_transform</span><span class="p">(</span><span class="n">affine_moving</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">description</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">description</span> <span class="o">=</span> <span class="n">desc_moving</span> <span class="o">+</span> <span class="s1">&#39; [passive rigid]&#39;</span>
    <span class="n">series_moved</span> <span class="o">=</span> <span class="n">series_moving</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">SeriesDescription</span> <span class="o">=</span> <span class="n">description</span><span class="p">)</span>
    <span class="n">series_moved</span><span class="o">.</span><span class="n">set_affine</span><span class="p">(</span><span class="n">output_affine</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;SliceLocation&#39;</span><span class="p">,),</span> <span class="n">multislice</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">series_moved</span>


<span class="k">def</span><span class="w"> </span><span class="nf">find_sbs_inslice_translation</span><span class="p">(</span><span class="n">moving</span><span class="p">:</span><span class="n">Series</span><span class="p">,</span> <span class="n">static</span><span class="p">:</span><span class="n">Series</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;mutual information&#39;</span><span class="p">,</span> <span class="n">region</span><span class="p">:</span><span class="n">Series</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">margin</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find the slice-by-slice inslice translation that maps a moving volume onto a static volume.</span>

<span class="sd">    Args:</span>
<span class="sd">        moving (dbdicom.Series): Series with the moving volume.</span>
<span class="sd">        static (dbdicom.Series): Series with the static volume</span>
<span class="sd">        tolerance (float, optional): Positive tolerance parameter to decide convergence of the gradient descent. A smaller value means a more accurate solution but also a lomger computation time. Defaults to 0.1.</span>
<span class="sd">        metric (str, option): Determines which metric to use in the optimization. Current options are &#39;mutual information&#39; (default) or &#39;sum of squares&#39;.</span>
<span class="sd">        region (dbdicom.Series, optional): Series with region of interest to restrict the alignment. The translation will be chosen based on the goodness of the alignment in the bounding box of this region. If none is provided, the entire volume is used. Defaults to None.</span>
<span class="sd">        margin (float, optional): in case a region is provided, this specifies a margin (in mm) to take around the region. Default is 0 (no margin).</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: list of 3-element numpy arrays with values of the translation that maps the moving volume onto the static volume. The list has one entry per slice of the volume.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">array_static</span><span class="p">,</span> <span class="n">affine_static</span><span class="p">,</span> <span class="n">array_moving</span><span class="p">,</span> <span class="n">affine_moving</span> <span class="o">=</span> <span class="n">_get_input</span><span class="p">(</span><span class="n">moving</span><span class="p">,</span> <span class="n">static</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="n">region</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="n">margin</span><span class="p">)</span>    
    <span class="n">func</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;sum of squares&#39;</span><span class="p">:</span> <span class="n">vreg</span><span class="o">.</span><span class="n">sum_of_squares</span><span class="p">,</span>
        <span class="s1">&#39;mutual information&#39;</span><span class="p">:</span> <span class="n">vreg</span><span class="o">.</span><span class="n">mutual_information</span><span class="p">,</span>
        <span class="s1">&#39;interaction&#39;</span><span class="p">:</span> <span class="n">vreg</span><span class="o">.</span><span class="n">interaction</span><span class="p">,</span>
    <span class="p">}</span>
    
     <span class="c1"># Perform coregistration</span>
    <span class="n">translation_estimate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">static_pixel_spacing</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">affine_components</span><span class="p">(</span><span class="n">affine_static</span><span class="p">)</span>
    <span class="n">optimization</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="s1">&#39;GD&#39;</span><span class="p">,</span> 
        <span class="s1">&#39;options&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;gradient step&#39;</span><span class="p">:</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">static_pixel_spacing</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;tolerance&#39;</span><span class="p">:</span> <span class="n">tolerance</span><span class="p">},</span> 
    <span class="c1">#    &#39;callback&#39;: lambda vk: moving.message(&#39;Current parameter: &#39; + str(vk)),</span>
    <span class="p">}</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">translation_estimate</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">align_slice_by_slice</span><span class="p">(</span>
            <span class="n">moving</span> <span class="o">=</span> <span class="n">array_moving</span><span class="p">,</span> 
            <span class="n">moving_affine</span> <span class="o">=</span> <span class="n">affine_moving</span><span class="p">,</span> 
            <span class="n">static</span> <span class="o">=</span> <span class="n">array_static</span><span class="p">,</span> 
            <span class="n">static_affine</span> <span class="o">=</span> <span class="n">affine_static</span><span class="p">,</span> 
            <span class="n">parameters</span> <span class="o">=</span> <span class="n">translation_estimate</span><span class="p">,</span> 
            <span class="n">resolutions</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">transformation</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">translate_inslice</span><span class="p">,</span>
            <span class="n">metric</span> <span class="o">=</span> <span class="n">func</span><span class="p">[</span><span class="n">metric</span><span class="p">],</span>
            <span class="n">optimization</span> <span class="o">=</span> <span class="n">optimization</span><span class="p">,</span>
            <span class="n">slice_thickness</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">moving</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="s1">&#39;SliceThickness&#39;</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;SliceLocation&#39;</span><span class="p">,))),</span>
            <span class="n">progress</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">z</span><span class="p">,</span> <span class="n">nz</span><span class="p">:</span> <span class="n">moving</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">z</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">nz</span><span class="p">,</span> <span class="s1">&#39;Coregistering slice-by-slice using translations&#39;</span><span class="p">),</span>
        <span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Failed to align volumes..&#39;</span><span class="p">)</span>
        <span class="n">translation_estimate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">translation_estimate</span>


<span class="k">def</span><span class="w"> </span><span class="nf">apply_sbs_inslice_translation</span><span class="p">(</span><span class="n">series_moving</span><span class="p">:</span><span class="n">Series</span><span class="p">,</span> <span class="n">parameters</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span><span class="n">Series</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Series</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply slice-by-slice inslice translation of an image volume.</span>

<span class="sd">    Args:</span>
<span class="sd">        series_moving (dbdicom.Series): Series containing the volune to be moved.</span>
<span class="sd">        parameters (np.ndarray): list of 3-element numpy arrays with values of the translation that maps the moving volume onto the static volume. The list has one entry per slice of the volume.</span>
<span class="sd">        target (dbdicom.Series, optional): If provided, the result is mapped onto the geometry of this series. If none is provided, the result has the same geometry of the moving series. Defaults to None.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the moving series contains multiple slice groups with different orientations. </span>
<span class="sd">        ValueError: If the array to be moved is empty.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dbdicom.Series: Sibling dbdicom series in the same study, containing the translated volume.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">affine_moving</span> <span class="o">=</span> <span class="n">series_moving</span><span class="o">.</span><span class="n">unique_affines</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">affine_moving</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">desc_moving</span> <span class="o">=</span> <span class="n">series_moving</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span><span class="o">.</span><span class="n">SeriesDescription</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Multiple slice groups detected in &#39;</span> <span class="o">+</span> <span class="n">desc_moving</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;This function only works for series with a single slice group. </span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;Please split the series first.&#39;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">affine_moving</span> <span class="o">=</span> <span class="n">affine_moving</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:]</span>
    
    <span class="n">translation</span> <span class="o">=</span> <span class="p">[</span><span class="n">vreg</span><span class="o">.</span><span class="n">inslice_translation</span><span class="p">(</span><span class="n">affine_moving</span><span class="p">,</span> <span class="n">par</span><span class="p">)</span> <span class="k">for</span> <span class="n">par</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">apply_sbs_translation</span><span class="p">(</span><span class="n">series_moving</span><span class="p">,</span> <span class="n">translation</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">apply_sbs_passive_inslice_translation</span><span class="p">(</span><span class="n">series_moving</span><span class="p">:</span><span class="n">Series</span><span class="p">,</span> <span class="n">parameters</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Series</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply slice-by-slice passive translation of an image volume.</span>

<span class="sd">    Passive in this context means that the coordinates are transformed rather than the image array itself.</span>

<span class="sd">    Args:</span>
<span class="sd">        series_moving (dbdicom.Series): Series containing the volune to be moved.</span>
<span class="sd">        parameters (np.ndarray): 6-element numpy array with values of the translation (first 3 elements) and rotation vector (last 3 elements) that map the moving volume on to the static volume. The list contains one entry per slice, ordered by slice location. The vectors are defined in an absolute reference frame in units of mm.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the moving series contains multiple slice groups with different orientations. </span>
<span class="sd">        ValueError: If the array to be moved is empty.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dbdicom.Series: Sibling dbdicom series in the same study, containing the translated volume.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">affine_moving</span> <span class="o">=</span> <span class="n">series_moving</span><span class="o">.</span><span class="n">unique_affines</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">affine_moving</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">desc_moving</span> <span class="o">=</span> <span class="n">series_moving</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span><span class="o">.</span><span class="n">SeriesDescription</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Multiple slice groups detected in &#39;</span> <span class="o">+</span> <span class="n">desc_moving</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;This function only works for series with a single slice group. </span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;Please split the series first.&#39;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">affine_moving</span> <span class="o">=</span> <span class="n">affine_moving</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:]</span>
    <span class="n">translation</span> <span class="o">=</span> <span class="p">[</span><span class="n">vreg</span><span class="o">.</span><span class="n">inslice_translation</span><span class="p">(</span><span class="n">affine_moving</span><span class="p">,</span> <span class="n">par</span><span class="p">)</span> <span class="k">for</span> <span class="n">par</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">apply_sbs_passive_translation</span><span class="p">(</span><span class="n">series_moving</span><span class="p">,</span> <span class="n">translation</span><span class="p">)</span>


<div class="viewcode-block" id="find_sbs_translation">
<a class="viewcode-back" href="../../../generated/api/dbdicom.extensions.vreg.find_sbs_translation.html#dbdicom.extensions.vreg.find_sbs_translation">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">find_sbs_translation</span><span class="p">(</span><span class="n">moving</span><span class="p">:</span><span class="n">Series</span><span class="p">,</span> <span class="n">static</span><span class="p">:</span><span class="n">Series</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;mutual information&#39;</span><span class="p">,</span> <span class="n">region</span><span class="p">:</span><span class="n">Series</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">margin</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">prereg</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find the slice-by-slice translation that maps a moving volume onto a static volume.</span>

<span class="sd">    Args:</span>
<span class="sd">        moving (dbdicom.Series): Series with the moving volume.</span>
<span class="sd">        static (dbdicom.Series): Series with the static volume</span>
<span class="sd">        tolerance (float, optional): Positive tolerance parameter to decide convergence of the gradient descent. A smaller value means a more accurate solution but also a lomger computation time. Defaults to 0.1.</span>
<span class="sd">        metric (str, option): Determines which metric to use in the optimization. Current options are &#39;mutual information&#39; (default) or &#39;sum of squares&#39;.</span>
<span class="sd">        region (dbdicom.Series, optional): Series with region of interest to restrict the alignment. The translation will be chosen based on the goodness of the alignment in the bounding box of this region. If none is provided, the entire volume is used. Defaults to None.</span>
<span class="sd">        margin (float, optional): in case a region is provided, this specifies a margin (in mm) to take around the region. Default is 0 (no margin).</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: list of 3-element numpy arrays with values of the translation that maps the moving volume onto the static volume. The list has one entry per slice of the volume.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">prereg</span><span class="p">:</span>
        <span class="n">translation</span> <span class="o">=</span> <span class="n">find_translation</span><span class="p">(</span><span class="n">moving</span><span class="p">,</span> <span class="n">static</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="n">region</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="n">margin</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">translation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="n">array_static</span><span class="p">,</span> <span class="n">affine_static</span><span class="p">,</span> <span class="n">array_moving</span><span class="p">,</span> <span class="n">affine_moving</span> <span class="o">=</span> <span class="n">_get_input</span><span class="p">(</span><span class="n">moving</span><span class="p">,</span> <span class="n">static</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="n">region</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="n">margin</span><span class="p">)</span>

    <span class="n">func</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;sum of squares&#39;</span><span class="p">:</span> <span class="n">vreg</span><span class="o">.</span><span class="n">sum_of_squares</span><span class="p">,</span>
        <span class="s1">&#39;mutual information&#39;</span><span class="p">:</span> <span class="n">vreg</span><span class="o">.</span><span class="n">mutual_information</span><span class="p">,</span>
        <span class="s1">&#39;interaction&#39;</span><span class="p">:</span> <span class="n">vreg</span><span class="o">.</span><span class="n">interaction</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1"># # Find an initial value with a brute force</span>
    <span class="c1"># optimization = {</span>
    <span class="c1">#     &#39;method&#39;: &#39;brute&#39;, </span>
    <span class="c1">#     &#39;options&#39;: {&#39;grid&#39;:[[-10,10,10], [-10,10,10], [-10,10,10]]}, </span>
    <span class="c1"># }</span>
    <span class="c1"># translation = vreg.align_slice_by_slice(</span>
    <span class="c1">#     moving = array_moving, </span>
    <span class="c1">#     moving_affine = affine_moving, </span>
    <span class="c1">#     static = array_static, </span>
    <span class="c1">#     static_affine = affine_static, </span>
    <span class="c1">#     transformation = vreg.translate,</span>
    <span class="c1">#     metric = func[metric],</span>
    <span class="c1">#     optimization = optimization,</span>
    <span class="c1">#     slice_thickness = list(moving.values(&#39;SliceThickness&#39;, dims=(&#39;SliceLocation&#39;,))),</span>
    <span class="c1">#     progress = lambda z, nz: moving.progress(z+1, nz, &#39;Performing brute force pre-search&#39;),</span>
    <span class="c1"># )</span>

    <span class="c1"># Define initial values and optimization</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">static_pixel_spacing</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">affine_components</span><span class="p">(</span><span class="n">affine_static</span><span class="p">)</span>
    <span class="n">optimization</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="s1">&#39;GD&#39;</span><span class="p">,</span> 
        <span class="s1">&#39;options&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;gradient step&#39;</span><span class="p">:</span> <span class="mf">0.1</span><span class="o">*</span><span class="n">static_pixel_spacing</span><span class="p">,</span> <span class="s1">&#39;tolerance&#39;</span><span class="p">:</span> <span class="n">tolerance</span><span class="p">},</span> 
    <span class="c1">#    &#39;callback&#39;: lambda vk: moving.message(&#39;Current parameter: &#39; + str(vk)),</span>
    <span class="p">}</span>

    
    <span class="c1"># Perform coregistration</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">translation_estimate</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">align_slice_by_slice</span><span class="p">(</span>
            <span class="n">moving</span> <span class="o">=</span> <span class="n">array_moving</span><span class="p">,</span> 
            <span class="n">moving_affine</span> <span class="o">=</span> <span class="n">affine_moving</span><span class="p">,</span> 
            <span class="n">static</span> <span class="o">=</span> <span class="n">array_static</span><span class="p">,</span> 
            <span class="n">static_affine</span> <span class="o">=</span> <span class="n">affine_static</span><span class="p">,</span> 
            <span class="n">parameters</span> <span class="o">=</span> <span class="n">translation</span><span class="p">,</span> 
            <span class="n">resolutions</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">transformation</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">translate</span><span class="p">,</span>
            <span class="n">metric</span> <span class="o">=</span> <span class="n">func</span><span class="p">[</span><span class="n">metric</span><span class="p">],</span>
            <span class="n">optimization</span> <span class="o">=</span> <span class="n">optimization</span><span class="p">,</span>
            <span class="n">slice_thickness</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">moving</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="s1">&#39;SliceThickness&#39;</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;SliceLocation&#39;</span><span class="p">,))),</span>
            <span class="n">progress</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">z</span><span class="p">,</span> <span class="n">nz</span><span class="p">:</span> <span class="n">moving</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">z</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">nz</span><span class="p">,</span> <span class="s1">&#39;Coregistering slice-by-slice using translations&#39;</span><span class="p">),</span>
        <span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Failed to align volumes..&#39;</span><span class="p">)</span>
        <span class="n">translation_estimate</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="n">translation_estimate</span></div>



<div class="viewcode-block" id="apply_sbs_translation">
<a class="viewcode-back" href="../../../generated/api/dbdicom.extensions.vreg.apply_sbs_translation.html#dbdicom.extensions.vreg.apply_sbs_translation">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">apply_sbs_translation</span><span class="p">(</span><span class="n">series_moving</span><span class="p">:</span><span class="n">Series</span><span class="p">,</span> <span class="n">parameters</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span><span class="n">Series</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Series</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply slice-by-slice translation of an image volume.</span>

<span class="sd">    Args:</span>
<span class="sd">        series_moving (dbdicom.Series): Series containing the volune to be moved.</span>
<span class="sd">        parameters (np.ndarray): list of 3-element numpy arrays with values of the translation that maps the moving volume onto the static volume. The list has one entry per slice of the volume.</span>
<span class="sd">        target (dbdicom.Series, optional): If provided, the result is mapped onto the geometry of this series. If none is provided, the result has the same geometry of the moving series. Defaults to None.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the moving series contains multiple slice groups with different orientations. </span>
<span class="sd">        ValueError: If the array to be moved is empty.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dbdicom.Series: Sibling dbdicom series in the same study, containing the translated volume.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">desc_moving</span> <span class="o">=</span> <span class="n">series_moving</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span><span class="o">.</span><span class="n">SeriesDescription</span>
    <span class="n">affine_moving</span> <span class="o">=</span> <span class="n">series_moving</span><span class="o">.</span><span class="n">unique_affines</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">affine_moving</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Multiple slice groups detected in &#39;</span> <span class="o">+</span> <span class="n">desc_moving</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;This function only works for series with a single slice group. </span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;Please split the series first.&#39;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">affine_moving</span> <span class="o">=</span> <span class="n">affine_moving</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:]</span>

    <span class="n">array_moving</span> <span class="o">=</span> <span class="n">series_moving</span><span class="o">.</span><span class="n">pixel_values</span><span class="p">(</span><span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;SliceLocation&#39;</span><span class="p">,))</span>
    <span class="k">if</span> <span class="n">array_moving</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">desc_moving</span> <span class="o">+</span> <span class="s1">&#39; is empty - cannot perform alignment.&#39;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="n">slice_thickness</span> <span class="o">=</span> <span class="n">series_moving</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="s1">&#39;SliceThickness&#39;</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;SliceLocation&#39;</span><span class="p">,))</span>

    <span class="k">if</span> <span class="n">target</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">shape_moved</span> <span class="o">=</span> <span class="n">array_moving</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">affine_moved</span> <span class="o">=</span> <span class="n">affine_moving</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">array_moved</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">pixel_values</span><span class="p">(</span><span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;SliceLocation&#39;</span><span class="p">,))</span>
        <span class="n">shape_moved</span> <span class="o">=</span> <span class="n">array_moved</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">affine_moved</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">affine</span><span class="p">()</span>

    <span class="n">series_moving</span><span class="o">.</span><span class="n">message</span><span class="p">(</span><span class="s1">&#39;Applying slice-by-slice translation..&#39;</span><span class="p">)</span>
    <span class="n">array_moved</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">transform_slice_by_slice</span><span class="p">(</span><span class="n">array_moving</span><span class="p">,</span> <span class="n">affine_moving</span><span class="p">,</span> <span class="n">shape_moved</span><span class="p">,</span> <span class="n">affine_moved</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">vreg</span><span class="o">.</span><span class="n">translate</span><span class="p">,</span> <span class="n">slice_thickness</span><span class="p">)</span>
    <span class="n">series_moved</span> <span class="o">=</span> <span class="n">series_moving</span><span class="o">.</span><span class="n">new_sibling</span><span class="p">(</span><span class="n">SeriesDescription</span> <span class="o">=</span> <span class="n">desc_moving</span> <span class="o">+</span> <span class="s1">&#39; [sbs translation]&#39;</span><span class="p">)</span>
    <span class="n">series_moved</span><span class="o">.</span><span class="n">set_pixel_values</span><span class="p">(</span><span class="n">array_moved</span><span class="p">,</span> <span class="nb">slice</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;SliceLocation&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">array_moved</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])})</span>
    <span class="n">series_moved</span><span class="o">.</span><span class="n">set_affine</span><span class="p">(</span><span class="n">affine_moved</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">series_moved</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">apply_sbs_passive_translation</span><span class="p">(</span><span class="n">series_moving</span><span class="p">:</span><span class="n">Series</span><span class="p">,</span> <span class="n">parameters</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Series</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply slice-by-slice passive translation of an image volume.</span>

<span class="sd">    Passive in this context means that the coordinates are transformed rather than the image array itself.</span>

<span class="sd">    Args:</span>
<span class="sd">        series_moving (dbdicom.Series): Series containing the volune to be moved.</span>
<span class="sd">        parameters (np.ndarray): 6-element numpy array with values of the translation (first 3 elements) and rotation vector (last 3 elements) that map the moving volume on to the static volume. The list contains one entry per slice, ordered by slice location. The vectors are defined in an absolute reference frame in units of mm.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the moving series contains multiple slice groups with different orientations. </span>
<span class="sd">        ValueError: If the array to be moved is empty.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dbdicom.Series: Sibling dbdicom series in the same study, containing the translated volume.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">desc_moving</span> <span class="o">=</span> <span class="n">series_moving</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span><span class="o">.</span><span class="n">SeriesDescription</span>
    <span class="n">affine_moving</span> <span class="o">=</span> <span class="n">series_moving</span><span class="o">.</span><span class="n">unique_affines</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">affine_moving</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Multiple slice groups detected in &#39;</span> <span class="o">+</span> <span class="n">desc_moving</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;This function only works for series with a single slice group. </span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;Please split the series first.&#39;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">affine_moving</span> <span class="o">=</span> <span class="n">affine_moving</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:]</span>

    <span class="n">series_moving</span><span class="o">.</span><span class="n">message</span><span class="p">(</span><span class="s1">&#39;Applying slice-by-slice passive translation..&#39;</span><span class="p">)</span>
    <span class="n">output_affine</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">passive_translation_slice_by_slice</span><span class="p">(</span><span class="n">affine_moving</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>
    <span class="n">series_moved</span> <span class="o">=</span> <span class="n">series_moving</span><span class="o">.</span><span class="n">new_sibling</span><span class="p">(</span><span class="n">SeriesDescription</span> <span class="o">=</span> <span class="n">desc_moving</span> <span class="o">+</span> <span class="s1">&#39; [sbs passive translation]&#39;</span><span class="p">)</span>
    <span class="n">frames</span> <span class="o">=</span> <span class="n">series_moving</span><span class="o">.</span><span class="n">frames</span><span class="p">(</span><span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;SliceLocation&#39;</span><span class="p">,))</span>
    <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">frames</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
        <span class="n">imz</span> <span class="o">=</span> <span class="n">frames</span><span class="p">[</span><span class="n">z</span><span class="p">]</span><span class="o">.</span><span class="n">copy_to</span><span class="p">(</span><span class="n">series_moved</span><span class="p">)</span>
        <span class="c1">#affine_z = output_affine[z]</span>
        <span class="c1">#affine_z[:3,2] *= imz.SliceThickness/np.linalg.norm(affine_z[:3,2])</span>
        <span class="n">affine_z</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">multislice_to_singleslice_affine</span><span class="p">(</span><span class="n">output_affine</span><span class="p">[</span><span class="n">z</span><span class="p">],</span> <span class="n">imz</span><span class="o">.</span><span class="n">SliceThickness</span><span class="p">)</span>
        <span class="n">imz</span><span class="o">.</span><span class="n">set_affine</span><span class="p">(</span><span class="n">affine_z</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">series_moved</span>


<span class="k">def</span><span class="w"> </span><span class="nf">find_sbs_rigid_transformation_with_prealign</span><span class="p">(</span><span class="n">moving</span><span class="p">:</span><span class="n">Series</span><span class="p">,</span> <span class="n">static</span><span class="p">:</span><span class="n">Series</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;mutual information&#39;</span><span class="p">,</span> <span class="n">region</span><span class="p">:</span><span class="n">Series</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">margin</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">moving_mask</span><span class="p">:</span><span class="n">Series</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">static_mask</span><span class="p">:</span><span class="n">Series</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">resolutions</span><span class="o">=</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">-&gt;</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find the rigid transform that maps a moving volume onto a static volume.</span>

<span class="sd">    Args:</span>
<span class="sd">        moving (dbdicom.Series): Series with the moving volume.</span>
<span class="sd">        static (dbdicom.Series): Series with the static volume</span>
<span class="sd">        tolerance (float, optional): Positive tolerance parameter to decide convergence of the gradient descent. A smaller value means a more accurate solution but also a lomger computation time. Defaults to 0.1.</span>
<span class="sd">        metric (str, option): Determines which metric to use in the optimization. Current options are &#39;mutual information&#39; (default) or &#39;sum of squares&#39;.</span>
<span class="sd">        region (dbdicom.Series, optional): Series with region of interest to restrict the alignment. The rigid transform will be chosen based on the goodness of the alignment in the bounding box of this region. If none is provided, the entire volume is used. Defaults to None.</span>
<span class="sd">        margin (float, optional): in case a region is provided, this specifies a margin (in mm) to take around the region. Default is 0 (no margin).</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: 6-element numpy array with values of the translation (first 3 elements) and rotation vector (last 3 elements) that map the moving volume on to the static volume. The vectors are defined in an absolute reference frame in units of mm.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">array_static</span><span class="p">,</span> <span class="n">affine_static</span><span class="p">,</span> <span class="n">array_moving</span><span class="p">,</span> <span class="n">affine_moving</span> <span class="o">=</span> <span class="n">_get_input</span><span class="p">(</span><span class="n">moving</span><span class="p">,</span> <span class="n">static</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="n">region</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="n">margin</span><span class="p">)</span>
    <span class="n">array_moving_mask</span><span class="p">,</span> <span class="n">affine_moving_mask</span> <span class="o">=</span> <span class="n">_get_input_volume</span><span class="p">(</span><span class="n">moving_mask</span><span class="p">)</span>
    <span class="n">array_static_mask</span><span class="p">,</span> <span class="n">affine_static_mask</span> <span class="o">=</span> <span class="n">_get_input_volume</span><span class="p">(</span><span class="n">static_mask</span><span class="p">)</span>

    <span class="c1"># Define initial values and optimization</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">static_pixel_spacing</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">affine_components</span><span class="p">(</span><span class="n">affine_static</span><span class="p">)</span>
    <span class="n">rot_gradient_step</span><span class="p">,</span> <span class="n">translation_gradient_step</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">affine_resolution</span><span class="p">(</span><span class="n">array_static</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">static_pixel_spacing</span><span class="p">)</span>
    <span class="n">gradient_step</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="mf">1.0</span><span class="o">*</span><span class="n">rot_gradient_step</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">translation_gradient_step</span><span class="p">))</span>
    <span class="n">optimization</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="s1">&#39;GD&#39;</span><span class="p">,</span> 
        <span class="s1">&#39;options&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;gradient step&#39;</span><span class="p">:</span> <span class="n">gradient_step</span><span class="p">,</span> <span class="s1">&#39;tolerance&#39;</span><span class="p">:</span> <span class="n">tolerance</span><span class="p">},</span> 
        <span class="s1">&#39;callback&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">vk</span><span class="p">:</span> <span class="n">moving</span><span class="o">.</span><span class="n">message</span><span class="p">(</span><span class="s1">&#39;Current parameter: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">vk</span><span class="p">)),</span>
    <span class="p">}</span>
    <span class="n">func</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;sum of squares&#39;</span><span class="p">:</span> <span class="n">vreg</span><span class="o">.</span><span class="n">sum_of_squares</span><span class="p">,</span>
        <span class="s1">&#39;mutual information&#39;</span><span class="p">:</span> <span class="n">vreg</span><span class="o">.</span><span class="n">mutual_information</span><span class="p">,</span>
        <span class="s1">&#39;interaction&#39;</span><span class="p">:</span> <span class="n">vreg</span><span class="o">.</span><span class="n">interaction</span><span class="p">,</span>
    <span class="p">}</span>
    
    <span class="c1"># Align volumes</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">rigid_estimate</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">align</span><span class="p">(</span>
            <span class="n">moving</span> <span class="o">=</span> <span class="n">array_moving</span><span class="p">,</span> 
            <span class="n">moving_affine</span> <span class="o">=</span> <span class="n">affine_moving</span><span class="p">,</span> 
            <span class="n">static</span> <span class="o">=</span> <span class="n">array_static</span><span class="p">,</span> 
            <span class="n">static_affine</span> <span class="o">=</span> <span class="n">affine_static</span><span class="p">,</span> 
            <span class="c1">#parameters = np.array([0, 0, 0, 0, 0, 0], dtype=np.float32), </span>
            <span class="n">parameters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
            <span class="n">resolutions</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> 
            <span class="n">transformation</span> <span class="o">=</span>  <span class="n">vreg</span><span class="o">.</span><span class="n">rigid</span><span class="p">,</span>
            <span class="n">metric</span> <span class="o">=</span> <span class="n">func</span><span class="p">[</span><span class="n">metric</span><span class="p">],</span>
            <span class="n">optimization</span> <span class="o">=</span> <span class="n">optimization</span><span class="p">,</span>
            <span class="n">static_mask</span> <span class="o">=</span> <span class="n">array_static_mask</span><span class="p">,</span>
            <span class="n">static_mask_affine</span> <span class="o">=</span> <span class="n">affine_static_mask</span><span class="p">,</span>
            <span class="n">moving_mask</span> <span class="o">=</span> <span class="n">array_moving_mask</span><span class="p">,</span>
            <span class="n">moving_mask_affine</span> <span class="o">=</span> <span class="n">affine_moving_mask</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Failed to align volumes..&#39;</span><span class="p">)</span>
        <span class="c1">#rigid_estimate = np.array([0, 0, 0, 0, 0, 0], dtype=np.float32)</span>
        <span class="n">rigid_estimate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    
    <span class="k">del</span> <span class="n">optimization</span><span class="p">[</span><span class="s1">&#39;callback&#39;</span><span class="p">]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">align_slice_by_slice</span><span class="p">(</span>
            <span class="n">moving</span> <span class="o">=</span> <span class="n">array_moving</span><span class="p">,</span> 
            <span class="n">moving_affine</span> <span class="o">=</span> <span class="n">affine_moving</span><span class="p">,</span> 
            <span class="n">static</span> <span class="o">=</span> <span class="n">array_static</span><span class="p">,</span> 
            <span class="n">static_affine</span> <span class="o">=</span> <span class="n">affine_static</span><span class="p">,</span> 
            <span class="n">parameters</span> <span class="o">=</span> <span class="n">rigid_estimate</span><span class="p">,</span> 
            <span class="n">resolutions</span> <span class="o">=</span> <span class="n">resolutions</span><span class="p">,</span>
            <span class="n">transformation</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">rigid</span><span class="p">,</span>
            <span class="n">metric</span> <span class="o">=</span> <span class="n">func</span><span class="p">[</span><span class="n">metric</span><span class="p">],</span>
            <span class="n">optimization</span> <span class="o">=</span> <span class="n">optimization</span><span class="p">,</span>
            <span class="n">slice_thickness</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">moving</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="s1">&#39;SliceThickness&#39;</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;SliceLocation&#39;</span><span class="p">,))),</span>
            <span class="n">progress</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">z</span><span class="p">,</span> <span class="n">nz</span><span class="p">:</span> <span class="n">moving</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">z</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">nz</span><span class="p">,</span> <span class="s1">&#39;Coregistering slice-by-slice using rigid transformations&#39;</span><span class="p">),</span>
            <span class="n">static_mask</span> <span class="o">=</span> <span class="n">array_static_mask</span><span class="p">,</span>
            <span class="n">static_mask_affine</span> <span class="o">=</span> <span class="n">affine_static_mask</span><span class="p">,</span>
            <span class="n">moving_mask</span> <span class="o">=</span> <span class="n">array_moving_mask</span><span class="p">,</span>
            <span class="n">moving_mask_affine</span> <span class="o">=</span> <span class="n">affine_moving_mask</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Failed to align slice-by-slice..&#39;</span><span class="p">)</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="n">parameters</span>


<div class="viewcode-block" id="find_sbs_rigid_transformation">
<a class="viewcode-back" href="../../../generated/api/dbdicom.extensions.vreg.find_sbs_rigid_transformation.html#dbdicom.extensions.vreg.find_sbs_rigid_transformation">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">find_sbs_rigid_transformation</span><span class="p">(</span><span class="n">moving</span><span class="p">:</span><span class="n">Series</span><span class="p">,</span> <span class="n">static</span><span class="p">:</span><span class="n">Series</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;mutual information&#39;</span><span class="p">,</span> <span class="n">region</span><span class="p">:</span><span class="n">Series</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">margin</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">moving_mask</span><span class="p">:</span><span class="n">Series</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">static_mask</span><span class="p">:</span><span class="n">Series</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">resolutions</span><span class="o">=</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">-&gt;</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find the slice-by-slice rigid transformation that maps a moving volume onto a static volume.</span>

<span class="sd">    Args:</span>
<span class="sd">        moving (dbdicom.Series): Series with the moving volume.</span>
<span class="sd">        static (dbdicom.Series): Series with the static volume</span>
<span class="sd">        tolerance (float, optional): Positive tolerance parameter to decide convergence of the gradient descent. A smaller value means a more accurate solution but also a lomger computation time. Defaults to 0.1.</span>
<span class="sd">        metric (str, option): Determines which metric to use in the optimization. Current options are &#39;mutual information&#39; (default) or &#39;sum of squares&#39;.</span>
<span class="sd">        region (dbdicom.Series, optional): Series with region of interest to restrict the alignment. The translation will be chosen based on the goodness of the alignment in the bounding box of this region. If none is provided, the entire volume is used. Defaults to None.</span>
<span class="sd">        margin (float, optional): in case a region is provided, this specifies a margin (in mm) to take around the region. Default is 0 (no margin).</span>
<span class="sd">        moving_mask (dbdicom.Series): Series for masking the moving volume.</span>
<span class="sd">        static_mask (dbdicom.Series): Series for masking the static volume.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: list of 6-element numpy arrays with values of the translation (first 3 elements) and rotation vector (last 3 elements) that map the moving volume on to the static volume. The list contains one entry per slice, ordered by slice location. The vectors are defined in an absolute reference frame in units of mm.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">array_static</span><span class="p">,</span> <span class="n">affine_static</span><span class="p">,</span> <span class="n">array_moving</span><span class="p">,</span> <span class="n">affine_moving</span> <span class="o">=</span> <span class="n">_get_input</span><span class="p">(</span><span class="n">moving</span><span class="p">,</span> <span class="n">static</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="n">region</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="n">margin</span><span class="p">)</span>
    <span class="n">array_moving_mask</span><span class="p">,</span> <span class="n">affine_moving_mask</span> <span class="o">=</span> <span class="n">_get_input_volume</span><span class="p">(</span><span class="n">moving_mask</span><span class="p">)</span>
    <span class="n">array_static_mask</span><span class="p">,</span> <span class="n">affine_static_mask</span> <span class="o">=</span> <span class="n">_get_input_volume</span><span class="p">(</span><span class="n">static_mask</span><span class="p">)</span>

    <span class="c1"># Define initial values and optimization</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">static_pixel_spacing</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">affine_components</span><span class="p">(</span><span class="n">affine_static</span><span class="p">)</span>
    <span class="n">rot_gradient_step</span><span class="p">,</span> <span class="n">translation_gradient_step</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">affine_resolution</span><span class="p">(</span><span class="n">array_static</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">static_pixel_spacing</span><span class="p">)</span>
    <span class="n">gradient_step</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="mf">1.0</span><span class="o">*</span><span class="n">rot_gradient_step</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">translation_gradient_step</span><span class="p">))</span>
    <span class="n">optimization</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="s1">&#39;GD&#39;</span><span class="p">,</span> 
        <span class="s1">&#39;options&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;gradient step&#39;</span><span class="p">:</span> <span class="n">gradient_step</span><span class="p">,</span> <span class="s1">&#39;tolerance&#39;</span><span class="p">:</span> <span class="n">tolerance</span><span class="p">},</span> 
    <span class="p">}</span>
    <span class="n">func</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;sum of squares&#39;</span><span class="p">:</span> <span class="n">vreg</span><span class="o">.</span><span class="n">sum_of_squares</span><span class="p">,</span>
        <span class="s1">&#39;mutual information&#39;</span><span class="p">:</span> <span class="n">vreg</span><span class="o">.</span><span class="n">mutual_information</span><span class="p">,</span>
        <span class="s1">&#39;interaction&#39;</span><span class="p">:</span> <span class="n">vreg</span><span class="o">.</span><span class="n">interaction</span><span class="p">,</span>
    <span class="p">}</span>
    
    <span class="c1"># Perform coregistration</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">align_slice_by_slice</span><span class="p">(</span>
            <span class="n">moving</span> <span class="o">=</span> <span class="n">array_moving</span><span class="p">,</span> 
            <span class="n">moving_affine</span> <span class="o">=</span> <span class="n">affine_moving</span><span class="p">,</span> 
            <span class="n">static</span> <span class="o">=</span> <span class="n">array_static</span><span class="p">,</span> 
            <span class="n">static_affine</span> <span class="o">=</span> <span class="n">affine_static</span><span class="p">,</span> 
            <span class="n">parameters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> 
            <span class="n">resolutions</span> <span class="o">=</span> <span class="n">resolutions</span><span class="p">,</span>
            <span class="n">transformation</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">rigid</span><span class="p">,</span>
            <span class="n">metric</span> <span class="o">=</span> <span class="n">func</span><span class="p">[</span><span class="n">metric</span><span class="p">],</span>
            <span class="n">optimization</span> <span class="o">=</span> <span class="n">optimization</span><span class="p">,</span>
            <span class="n">slice_thickness</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">moving</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="s1">&#39;SliceThickness&#39;</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;SliceLocation&#39;</span><span class="p">,))),</span>
            <span class="n">progress</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">z</span><span class="p">,</span> <span class="n">nz</span><span class="p">:</span> <span class="n">moving</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">z</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">nz</span><span class="p">,</span> <span class="s1">&#39;Coregistering slice-by-slice using rigid transformations&#39;</span><span class="p">),</span>
            <span class="n">static_mask</span> <span class="o">=</span> <span class="n">array_static_mask</span><span class="p">,</span>
            <span class="n">static_mask_affine</span> <span class="o">=</span> <span class="n">affine_static_mask</span><span class="p">,</span>
            <span class="n">moving_mask</span> <span class="o">=</span> <span class="n">array_moving_mask</span><span class="p">,</span>
            <span class="n">moving_mask_affine</span> <span class="o">=</span> <span class="n">affine_moving_mask</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Failed to align volumes..&#39;</span><span class="p">)</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="n">parameters</span></div>



<div class="viewcode-block" id="apply_sbs_passive_rigid_transformation">
<a class="viewcode-back" href="../../../generated/api/dbdicom.extensions.vreg.apply_sbs_passive_rigid_transformation.html#dbdicom.extensions.vreg.apply_sbs_passive_rigid_transformation">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">apply_sbs_passive_rigid_transformation</span><span class="p">(</span><span class="n">series_moving</span><span class="p">:</span><span class="n">Series</span><span class="p">,</span> <span class="n">parameters</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Series</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply slice-by-slice passive rigid transformation of an image volume.</span>

<span class="sd">    Passive in this context means that the coordinates are transformed rather than the image array itself.</span>

<span class="sd">    Args:</span>
<span class="sd">        series_moving (dbdicom.Series): Series containing the volune to be moved.</span>
<span class="sd">        parameters (np.ndarray): 6-element numpy array with values of the translation (first 3 elements) and rotation vector (last 3 elements) that map the moving volume on to the static volume. The list contains one entry per slice, ordered by slice location. The vectors are defined in an absolute reference frame in units of mm.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the moving series contains multiple slice groups with different orientations. </span>
<span class="sd">        ValueError: If the array to be moved is empty.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dbdicom.Series: Sibling dbdicom series in the same study, containing the translated volume.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">desc_moving</span> <span class="o">=</span> <span class="n">series_moving</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span><span class="o">.</span><span class="n">SeriesDescription</span>
    <span class="n">affine_moving</span> <span class="o">=</span> <span class="n">series_moving</span><span class="o">.</span><span class="n">unique_affines</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">affine_moving</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Multiple slice groups detected in &#39;</span> <span class="o">+</span> <span class="n">desc_moving</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;This function only works for series with a single slice group. </span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;Please split the series first.&#39;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">affine_moving</span> <span class="o">=</span> <span class="n">affine_moving</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:]</span>

    <span class="k">if</span> <span class="n">description</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">description</span> <span class="o">=</span> <span class="n">desc_moving</span> <span class="o">+</span> <span class="s1">&#39; [sbs passive rigid]&#39;</span>
    <span class="n">output_affine</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">passive_rigid_transform_slice_by_slice</span><span class="p">(</span><span class="n">affine_moving</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>

    <span class="n">series_moved</span> <span class="o">=</span> <span class="n">series_moving</span><span class="o">.</span><span class="n">new_sibling</span><span class="p">(</span><span class="n">SeriesDescription</span> <span class="o">=</span> <span class="n">description</span><span class="p">)</span>
    <span class="n">frames</span> <span class="o">=</span> <span class="n">series_moving</span><span class="o">.</span><span class="n">frames</span><span class="p">((</span><span class="s1">&#39;SliceLocation&#39;</span><span class="p">,</span><span class="s1">&#39;InstanceNumber&#39;</span><span class="p">))</span>
    <span class="n">cnt</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">frames</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">frames</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">cnt</span><span class="o">+=</span><span class="mi">1</span>
            <span class="n">series_moving</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">frames</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="s1">&#39;Applying transformation to &#39;</span> <span class="o">+</span> <span class="n">desc_moving</span><span class="p">)</span>
            <span class="n">affine_zt</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">multislice_to_singleslice_affine</span><span class="p">(</span><span class="n">output_affine</span><span class="p">[</span><span class="n">z</span><span class="p">],</span> <span class="n">frames</span><span class="p">[</span><span class="n">z</span><span class="p">,</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">SliceThickness</span><span class="p">)</span>
            <span class="n">frames</span><span class="p">[</span><span class="n">z</span><span class="p">,</span><span class="n">t</span><span class="p">]</span><span class="o">.</span><span class="n">copy_to</span><span class="p">(</span><span class="n">series_moved</span><span class="p">)</span><span class="o">.</span><span class="n">set_affine</span><span class="p">(</span><span class="n">affine_zt</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">series_moved</span></div>




<div class="viewcode-block" id="apply_sbs_rigid_transformation">
<a class="viewcode-back" href="../../../generated/api/dbdicom.extensions.vreg.apply_sbs_rigid_transformation.html#dbdicom.extensions.vreg.apply_sbs_rigid_transformation">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">apply_sbs_rigid_transformation</span><span class="p">(</span><span class="n">series_moving</span><span class="p">:</span><span class="n">Series</span><span class="p">,</span> <span class="n">parameters</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span><span class="n">Series</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Series</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply slice-by-slice rigid transformation of an image volume.</span>

<span class="sd">    Args:</span>
<span class="sd">        series_moving (dbdicom.Series): Series containing the volune to be moved.</span>
<span class="sd">        parameters (np.ndarray): 6-element numpy array with values of the translation (first 3 elements) and rotation vector (last 3 elements) that map the moving volume on to the static volume. The list contains one entry per slice, ordered by slice location. The vectors are defined in an absolute reference frame in units of mm.</span>
<span class="sd">        target (dbdicom.Series, optional): If provided, the result is mapped onto the geometry of this series. If none is provided, the result has the same geometry as the moving series. Defaults to None.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the moving series contains multiple slice groups with different orientations. </span>
<span class="sd">        ValueError: If the array to be moved is empty.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dbdicom.Series: Sibling dbdicom series in the same study, containing the translated volume.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">desc_moving</span> <span class="o">=</span> <span class="n">series_moving</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span><span class="o">.</span><span class="n">SeriesDescription</span>
    <span class="n">affine_moving</span> <span class="o">=</span> <span class="n">series_moving</span><span class="o">.</span><span class="n">affine</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">affine_moving</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Multiple slice groups detected in &#39;</span> <span class="o">+</span> <span class="n">desc_moving</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;This function only works for series with a single slice group. </span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;Please split the series first.&#39;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">affine_moving</span> <span class="o">=</span> <span class="n">affine_moving</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">array_moving</span> <span class="o">=</span> <span class="n">series_moving</span><span class="o">.</span><span class="n">pixel_values</span><span class="p">(</span><span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;SliceLocation&#39;</span><span class="p">,))</span>
    <span class="k">if</span> <span class="n">array_moving</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">desc_moving</span> <span class="o">+</span> <span class="s1">&#39; is empty - cannot perform alignment.&#39;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="n">slice_thickness</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">series_moving</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="s1">&#39;SliceThickness&#39;</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;SliceLocation&#39;</span><span class="p">,)))</span>

    <span class="k">if</span> <span class="n">target</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">shape_moved</span> <span class="o">=</span> <span class="n">array_moving</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">affine_moved</span> <span class="o">=</span> <span class="n">affine_moving</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">array_moved</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">pixel_values</span><span class="p">(</span><span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;SliceLocation&#39;</span><span class="p">,))</span>
        <span class="n">shape_moved</span> <span class="o">=</span> <span class="n">array_moved</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">affine_moved</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">affine</span><span class="p">()</span>

    <span class="n">series_moving</span><span class="o">.</span><span class="n">message</span><span class="p">(</span><span class="s1">&#39;Applying slice-by-slice rigid transformation..&#39;</span><span class="p">)</span>
    <span class="n">array_moved</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">transform_slice_by_slice</span><span class="p">(</span><span class="n">array_moving</span><span class="p">,</span> <span class="n">affine_moving</span><span class="p">,</span> <span class="n">shape_moved</span><span class="p">,</span> <span class="n">affine_moved</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">vreg</span><span class="o">.</span><span class="n">rigid</span><span class="p">,</span> <span class="n">slice_thickness</span><span class="p">)</span>
    <span class="n">series_moved</span> <span class="o">=</span> <span class="n">series_moving</span><span class="o">.</span><span class="n">new_sibling</span><span class="p">(</span><span class="n">SeriesDescription</span> <span class="o">=</span> <span class="n">desc_moving</span> <span class="o">+</span> <span class="s1">&#39; [sbs rigid]&#39;</span><span class="p">)</span>
    <span class="n">series_moved</span><span class="o">.</span><span class="n">set_pixel_values</span><span class="p">(</span><span class="n">array_moved</span><span class="p">,</span> <span class="nb">slice</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;SliceLocation&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">array_moved</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])})</span>
    <span class="n">series_moved</span><span class="o">.</span><span class="n">set_affine</span><span class="p">(</span><span class="n">affine_moved</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">series_moved</span></div>



<div class="viewcode-block" id="rigid_around_com_sos">
<a class="viewcode-back" href="../../../generated/api/dbdicom.extensions.vreg.rigid_around_com_sos.html#dbdicom.extensions.vreg.rigid_around_com_sos">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">rigid_around_com_sos</span><span class="p">(</span><span class="n">moving</span><span class="p">,</span> <span class="n">static</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>

    <span class="n">array_static</span><span class="p">,</span> <span class="n">affine_static</span><span class="p">,</span> <span class="n">array_moving</span><span class="p">,</span> <span class="n">affine_moving</span> <span class="o">=</span> <span class="n">_get_input</span><span class="p">(</span><span class="n">moving</span><span class="p">,</span> <span class="n">static</span><span class="p">)</span>

    <span class="c1"># Define initial values and optimization</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">static_pixel_spacing</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">affine_components</span><span class="p">(</span><span class="n">affine_static</span><span class="p">)</span>
    <span class="n">rot_gradient_step</span><span class="p">,</span> <span class="n">translation_gradient_step</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">affine_resolution</span><span class="p">(</span><span class="n">array_static</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">static_pixel_spacing</span><span class="p">)</span>
    <span class="n">gradient_step</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="mf">1.0</span><span class="o">*</span><span class="n">rot_gradient_step</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">translation_gradient_step</span><span class="p">))</span>
    <span class="n">optimization</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="s1">&#39;GD&#39;</span><span class="p">,</span> 
        <span class="s1">&#39;options&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;gradient step&#39;</span><span class="p">:</span> <span class="n">gradient_step</span><span class="p">,</span> <span class="s1">&#39;tolerance&#39;</span><span class="p">:</span> <span class="n">tolerance</span><span class="p">},</span> 
        <span class="s1">&#39;callback&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">vk</span><span class="p">:</span> <span class="n">moving</span><span class="o">.</span><span class="n">message</span><span class="p">(</span><span class="s1">&#39;Current parameter: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">vk</span><span class="p">)),</span>
    <span class="p">}</span>
    
    <span class="c1"># Align volumes</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">rigid_estimate</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">align</span><span class="p">(</span>
            <span class="n">moving</span> <span class="o">=</span> <span class="n">array_moving</span><span class="p">,</span> 
            <span class="n">moving_affine</span> <span class="o">=</span> <span class="n">affine_moving</span><span class="p">,</span> 
            <span class="n">static</span> <span class="o">=</span> <span class="n">array_static</span><span class="p">,</span> 
            <span class="n">static_affine</span> <span class="o">=</span> <span class="n">affine_static</span><span class="p">,</span> 
            <span class="n">parameters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> 
            <span class="n">resolutions</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> 
            <span class="n">transformation</span> <span class="o">=</span>  <span class="n">vreg</span><span class="o">.</span><span class="n">rigid_around_com</span><span class="p">,</span>
            <span class="n">metric</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">sum_of_squares</span><span class="p">,</span>
            <span class="n">optimization</span> <span class="o">=</span> <span class="n">optimization</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Failed to align volumes..&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">coregistered</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">rigid_around_com</span><span class="p">(</span><span class="n">array_moving</span><span class="p">,</span> <span class="n">affine_moving</span><span class="p">,</span> <span class="n">array_static</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">affine_static</span><span class="p">,</span> <span class="n">rigid_estimate</span><span class="p">)</span>
    
    <span class="n">moving</span><span class="o">.</span><span class="n">message</span><span class="p">(</span><span class="s1">&#39;Writing coregistered series to database..&#39;</span><span class="p">)</span>
    
    <span class="c1"># Save results as new dicom series</span>
    <span class="n">desc</span> <span class="o">=</span> <span class="n">moving</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span><span class="o">.</span><span class="n">SeriesDescription</span>
    <span class="n">coreg</span> <span class="o">=</span> <span class="n">moving</span><span class="o">.</span><span class="n">new_sibling</span><span class="p">(</span><span class="n">SeriesDescription</span> <span class="o">=</span> <span class="n">desc</span> <span class="o">+</span> <span class="s1">&#39; [rigid com]&#39;</span><span class="p">)</span>
    <span class="n">coreg</span><span class="o">.</span><span class="n">set_pixel_values</span><span class="p">(</span><span class="n">coregistered</span><span class="p">,</span> <span class="nb">slice</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;SliceLocation&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">coregistered</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])})</span>
    <span class="k">return</span> <span class="n">coreg</span></div>



<div class="viewcode-block" id="sbs_rigid_around_com_sos">
<a class="viewcode-back" href="../../../generated/api/dbdicom.extensions.vreg.sbs_rigid_around_com_sos.html#dbdicom.extensions.vreg.sbs_rigid_around_com_sos">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">sbs_rigid_around_com_sos</span><span class="p">(</span><span class="n">moving</span><span class="p">,</span> <span class="n">static</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>

    <span class="n">array_static</span><span class="p">,</span> <span class="n">affine_static</span><span class="p">,</span> <span class="n">array_moving</span><span class="p">,</span> <span class="n">affine_moving</span> <span class="o">=</span> <span class="n">_get_input</span><span class="p">(</span><span class="n">moving</span><span class="p">,</span> <span class="n">static</span><span class="p">)</span>
    <span class="n">slice_thickness</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">moving</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="s1">&#39;SliceThickness&#39;</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;SliceLocation&#39;</span><span class="p">,)))</span>

    <span class="c1"># Define initial values and optimization</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">static_pixel_spacing</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">affine_components</span><span class="p">(</span><span class="n">affine_static</span><span class="p">)</span>
    <span class="n">rot_gradient_step</span><span class="p">,</span> <span class="n">translation_gradient_step</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">affine_resolution</span><span class="p">(</span><span class="n">array_static</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">static_pixel_spacing</span><span class="p">)</span>
    <span class="n">gradient_step</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="mf">1.0</span><span class="o">*</span><span class="n">rot_gradient_step</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">translation_gradient_step</span><span class="p">))</span>
    <span class="n">optimization</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="s1">&#39;GD&#39;</span><span class="p">,</span> 
        <span class="s1">&#39;options&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;gradient step&#39;</span><span class="p">:</span> <span class="n">gradient_step</span><span class="p">,</span> <span class="s1">&#39;tolerance&#39;</span><span class="p">:</span> <span class="n">tolerance</span><span class="p">},</span> 
        <span class="c1">#&#39;callback&#39;: lambda vk: moving.message(&#39;Current parameter: &#39; + str(vk)),</span>
    <span class="p">}</span>

    <span class="c1"># Perform coregistration</span>
    <span class="n">estimate</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">align_slice_by_slice</span><span class="p">(</span>
        <span class="n">moving</span> <span class="o">=</span> <span class="n">array_moving</span><span class="p">,</span> 
        <span class="n">static</span> <span class="o">=</span> <span class="n">array_static</span><span class="p">,</span> 
        <span class="n">parameters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> 
        <span class="n">moving_affine</span> <span class="o">=</span> <span class="n">affine_moving</span><span class="p">,</span> 
        <span class="n">static_affine</span> <span class="o">=</span> <span class="n">affine_static</span><span class="p">,</span> 
        <span class="n">transformation</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">rigid_around_com</span><span class="p">,</span>
        <span class="n">metric</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">sum_of_squares</span><span class="p">,</span>
        <span class="n">optimization</span> <span class="o">=</span> <span class="n">optimization</span><span class="p">,</span>
        <span class="n">resolutions</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">slice_thickness</span> <span class="o">=</span> <span class="n">slice_thickness</span><span class="p">,</span>
        <span class="n">progress</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">z</span><span class="p">,</span> <span class="n">nz</span><span class="p">:</span> <span class="n">moving</span><span class="o">.</span><span class="n">progress</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">nz</span><span class="p">,</span> <span class="s1">&#39;Coregistering slice-by-slice using rigid transformations&#39;</span><span class="p">),</span>
    <span class="p">)</span>

    <span class="c1"># The generic slice-by-slice transform does not work for center of mass rotations. </span>
    <span class="c1"># Calculate rotation center and use rigid rotation around given center instead.</span>
    <span class="n">estimate_center</span> <span class="o">=</span> <span class="p">[]</span> 
    <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">estimate</span><span class="p">)):</span>
        <span class="n">array_moving_z</span><span class="p">,</span> <span class="n">affine_moving_z</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">extract_slice</span><span class="p">(</span><span class="n">array_moving</span><span class="p">,</span> <span class="n">affine_moving</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">slice_thickness</span><span class="p">)</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">estimate</span><span class="p">[</span><span class="n">z</span><span class="p">][</span><span class="mi">3</span><span class="p">:]</span> <span class="o">+</span> <span class="n">vreg</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">(</span><span class="n">vreg</span><span class="o">.</span><span class="n">to_3d</span><span class="p">(</span><span class="n">array_moving_z</span><span class="p">),</span> <span class="n">affine_moving_z</span><span class="p">)</span>
        <span class="n">pars</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">estimate</span><span class="p">[</span><span class="n">z</span><span class="p">][:</span><span class="mi">3</span><span class="p">],</span> <span class="n">center</span><span class="p">,</span> <span class="n">estimate</span><span class="p">[</span><span class="n">z</span><span class="p">][</span><span class="mi">3</span><span class="p">:]))</span>
        <span class="n">estimate_center</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pars</span><span class="p">)</span>
    
    <span class="c1"># Calculate coregistered (using rigid around known center)</span>
    <span class="n">coregistered</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">transform_slice_by_slice</span><span class="p">(</span><span class="n">array_moving</span><span class="p">,</span> <span class="n">affine_moving</span><span class="p">,</span> <span class="n">array_static</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">affine_static</span><span class="p">,</span> <span class="n">estimate_center</span><span class="p">,</span> <span class="n">vreg</span><span class="o">.</span><span class="n">rigid_around</span><span class="p">,</span> <span class="n">slice_thickness</span><span class="p">)</span>

    <span class="c1"># Save results as new dicom series</span>
    <span class="n">moving</span><span class="o">.</span><span class="n">message</span><span class="p">(</span><span class="s1">&#39;Writing coregistered series to database..&#39;</span><span class="p">)</span>
    <span class="n">desc</span> <span class="o">=</span> <span class="n">moving</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span><span class="o">.</span><span class="n">SeriesDescription</span>
    <span class="n">coreg</span> <span class="o">=</span> <span class="n">moving</span><span class="o">.</span><span class="n">new_sibling</span><span class="p">(</span><span class="n">SeriesDescription</span> <span class="o">=</span> <span class="n">desc</span> <span class="o">+</span> <span class="s1">&#39; [sbs rigid com]&#39;</span><span class="p">)</span>
    <span class="n">coreg</span><span class="o">.</span><span class="n">set_pixel_values</span><span class="p">(</span><span class="n">coregistered</span><span class="p">,</span> <span class="nb">slice</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;SliceLocation&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">coregistered</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])})</span>

    <span class="k">return</span> <span class="n">coreg</span></div>



<div class="viewcode-block" id="rotate">
<a class="viewcode-back" href="../../../generated/api/dbdicom.extensions.vreg.rotate.html#dbdicom.extensions.vreg.rotate">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">rotate</span><span class="p">(</span><span class="n">series</span><span class="p">:</span><span class="n">Series</span><span class="p">,</span> <span class="n">parameters</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">reshape</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">output_shape</span><span class="p">:</span><span class="nb">tuple</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">output_affine</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Series</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Rotate a series in 3D</span>

<span class="sd">    Args:</span>
<span class="sd">        series (dbdicom.Series): Series containing the volume to be rotated.</span>
<span class="sd">        parameters (np.ndarray): 3-element numpy array with values of the rotation vector. The vectors are defined in the absolute (scanner) reference frame in units of mm.</span>
<span class="sd">        reshape (bool, optional): if True, the array size and affine will be adjusted to contain the complete rotate data. If False, the original array size and affine is retained. Defaults to True.</span>
<span class="sd">        output_shape (tuple, optional): determines the shape of the result. If not provided, the shape of the original (reshape=False) or reshaped array (reshape=True) is used. Defaults to False.</span>
<span class="sd">        output_affine (ndarray, optional): determines the affine of the result. If not provided, the affine of the original (reshape=False) or reshaped array (reshape=True) is used. Defaults to None.</span>
<span class="sd">        mode (str, optional): Determines how the input array is extended beyond its boundaries. See `scipy.ndimage.map_coordinates &lt;https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.map_coordinates.html&gt;`_ for more detail. Defaults to constant = 0.</span>
<span class="sd">        kwargs: List of optionional arguments specifying valid DICOM (keyword = value) pairs.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the moving series contains multiple slice groups with different orentations. </span>
<span class="sd">        ValueError: If the array to be moved is empty.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dbdicom.Series: Sibling dbdicom series in the same study, containing the rotated volume.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Check that the series has a single slice group</span>
    <span class="n">affine</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">unique_affines</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">affine</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span><span class="o">.</span><span class="n">SeriesDescription</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Multiple slice groups detected in &#39;</span> <span class="o">+</span> <span class="n">desc</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;This function only works for series with a single slice group. </span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;Please split the series first.&#39;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">affine</span> <span class="o">=</span> <span class="n">affine</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:]</span>

    <span class="c1"># Check that the array is not empty</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">pixel_values</span><span class="p">(</span><span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;SliceLocation&#39;</span><span class="p">,))</span>
    <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">instance</span><span class="p">()</span><span class="o">.</span><span class="n">SeriesDescription</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">desc</span> <span class="o">+</span> <span class="s1">&#39; is empty - cannot perform alignment.&#39;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    
    <span class="c1"># Perform rotation</span>
    <span class="n">series</span><span class="o">.</span><span class="n">message</span><span class="p">(</span><span class="s1">&#39;Applying rotation..&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">reshape</span><span class="p">:</span>

        <span class="c1"># Perform rotation and reshape</span>
        <span class="n">output_arr</span><span class="p">,</span> <span class="n">output_aff</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">rotate_reshape</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">affine</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>

        <span class="c1"># If no output geometry is specified, return the results as they are.</span>
        <span class="k">if</span> <span class="n">output_shape</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">output_affine</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_array</span><span class="p">,</span> <span class="n">output_affine</span> <span class="o">=</span> <span class="n">output_arr</span><span class="p">,</span> <span class="n">output_aff</span>

        <span class="c1"># If an output geometry is specified, reslice the result to this geometry.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">output_shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">output_shape</span> <span class="o">=</span> <span class="n">output_arr</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">if</span> <span class="n">output_affine</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">output_affine</span> <span class="o">=</span> <span class="n">output_aff</span> 
            <span class="n">output_array</span><span class="p">,</span> <span class="n">output_affine</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">affine_reslice</span><span class="p">(</span><span class="n">output_arr</span><span class="p">,</span> <span class="n">output_aff</span><span class="p">,</span> <span class="n">output_affine</span><span class="p">,</span> <span class="n">output_shape</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># If not provided, use default values for array shape and affine</span>
        <span class="k">if</span> <span class="n">output_shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_shape</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="n">output_affine</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_affine</span> <span class="o">=</span> <span class="n">affine</span>
        <span class="n">output_array</span> <span class="o">=</span> <span class="n">vreg</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">affine</span><span class="p">,</span> <span class="n">output_shape</span><span class="p">,</span> <span class="n">output_affine</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>

    <span class="c1"># Save results in a new series</span>
    <span class="n">output_series</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">new_sibling</span><span class="p">(</span><span class="n">WindowCenter</span><span class="o">=</span><span class="n">series</span><span class="o">.</span><span class="n">WindowCenter</span><span class="p">,</span> <span class="n">WindowWidth</span><span class="o">=</span><span class="n">series</span><span class="o">.</span><span class="n">WindowWidth</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">output_series</span><span class="o">.</span><span class="n">set_pixel_values</span><span class="p">(</span><span class="n">output_array</span><span class="p">,</span> <span class="nb">slice</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;SliceLocation&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">output_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])})</span>
    <span class="n">output_series</span><span class="o">.</span><span class="n">set_affine</span><span class="p">(</span><span class="n">output_affine</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">output_series</span></div>

</pre></div>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2022-2025, QIB-Sheffield.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>