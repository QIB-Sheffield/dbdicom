<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>dbdicom.classes.instance API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dbdicom.classes.instance</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
import shutil
from copy import deepcopy
from datetime import datetime

import pydicom
from pydicom.dataset import Dataset
from pydicom.sequence import Sequence

from .record import Record
from .. import utilities

class Instance(Record):

    def __init__(self, folder, UID=[], **attributes):
        super().__init__(folder, UID, generation=4, **attributes)

    def label(self, row=None):

        if row is None:
            data = self.data()
            if data.empty: return &#34;New Instance&#34;
            file = data.index[0]
            nr = data.at[file, &#39;InstanceNumber&#39;]
        else:
            nr = row.InstanceNumber

        return str(nr).zfill(6)

    @property
    def file(self):
        &#34;&#34;&#34;Returns the filepath to the instance.&#34;&#34;&#34;
 
        files = self.files
        if len(files) != 0:  
            return files[0]

    def __getitem__(self, tags):
        &#34;&#34;&#34;Gets the value of the data elements with specified tags.
        
        Arguments
        ---------
        tags : a string, hexadecimal tuple, or a list of strings and hexadecimal tuples

        Returns
        -------
        A value or a list of values
        &#34;&#34;&#34;
        in_memory = self.in_memory()
        if not in_memory: 
            self.read()
        values = utilities._read_tags(self.ds, tags)   
        if not in_memory: 
            self.clear()
        return values

    def __setitem__(self, tags, values):
        &#34;&#34;&#34;
        Sets the value of the data element with given tag.
        &#34;&#34;&#34;
        on_disk = self.on_disk()
        if on_disk: 
            self.read()
        utilities._set_tags(self.ds, tags, values)
        if on_disk:
            self.write()
            self.clear()

    def write(self):
        &#34;&#34;&#34;Writes the dataset to disk&#34;&#34;&#34;

        if self.on_disk(): return
        ds = self.ds

        # Ensure DICOM hierarchy is respected
        if not &#39;PatientID&#39; in ds:
            ds.PatientID = pydicom.uid.generate_uid()
        if not &#39;StudyInstanceUID&#39; in ds:
            ds.StudyInstanceUID = pydicom.uid.generate_uid()
        if not &#39;SeriesInstanceUID&#39; in ds:
            ds.SeriesInstanceUID = pydicom.uid.generate_uid()    
        if not &#39;SOPInstanceUID&#39; in ds:
            ds.SOPInstanceUID = pydicom.uid.generate_uid()    

        df = self.data()
        if df.empty: # Data exist in memory only.
            self.folder._append(ds)
        else: 
            file = df.index[0] 
            if not df.loc[file,&#39;created&#39;]:  # This is the first change 
                self.folder.dataframe.loc[file,&#39;removed&#39;] = True
                self.folder._append(ds)
            else:   # Update values in dataframe row
                self.folder._update(file, ds)

        self._save_ds()

    def _save_ds(self, file=None):

        if file is None: 
            file = self.file
        try:
            self.ds.save_as(file) 
        except:
            message = &#34;Failed to write to &#34; + file
            message += &#34;\n The file is open in another application, or is being synchronised by a cloud service.&#34;
            message += &#34;\n Please close the file or pause the synchronisation and try again.&#34;
            self.dialog.information(message)

    def clear(self):
        &#34;&#34;&#34;Clears the dataset in memory&#34;&#34;&#34;

        self.__dict__[&#39;ds&#39;] = None 

    def read(self):
        &#34;&#34;&#34;Reads the dataset into memory.&#34;&#34;&#34;

        file = self.file
        if file is None: 
            return
        try:
            self.ds = pydicom.dcmread(file)
        except:
            message = &#34;Failed to read &#34; + file
            message += &#34;\n Please read the DICOM folder again via File-&gt;Read.&#34;
            self.dialog.information(message)            
        return self.ds # return self instead so read can be piped: series.read().copy_to(parent)

    def _copy_to_OBSOLETE(self, ancestor): # Replaced by copy_to in record
        &#34;&#34;&#34;copy instance to a new ancestor.
        
        dicom_object: Root, Patient, Study, or Series
            If the object is not a series, the missing 
            intermediate generations are automatically created.
        &#34;&#34;&#34;
        # Generate new instance
        copy = self.__class__(self.folder, UID=ancestor.UID)

        if self.in_memory(): # Create the copy in memory
            copy.__dict__[&#39;ds&#39;] = deepcopy(self.ds)
            copy._initialize(self.ds)
            if ancestor.in_memory():
                ancestor.ds.append(copy)
        else: # Create copy on disk
            self.read()
            copy.__dict__[&#39;ds&#39;] = self.ds
            copy._initialize(self.ds)
            copy.folder._append(copy.ds)
            copy._save_ds()
            self.clear()
            if ancestor.in_memory():
                ancestor.ds.append(copy) 
            else:       
                copy.clear()
            
        return copy

    def save_OBSOLETE(self):
        &#34;&#34;&#34;
        Saves all changes made in the instance
        &#34;&#34;&#34;
        self.write() 
        rows = self.folder.dataframe.SOPInstanceUID == self.UID[-1]
        data = self.folder.dataframe[rows] 
        created = data.created[data.created]
        removed = data.removed[data.removed]

        if data.shape[0] == 2: # instance has been modified
            created = created.index
            removed = removed.index
            if created.empty or removed.empty: 
                message = &#39;DICOM dataset &#39; + self.file
                message += &#34;\n Source data have been corrupted.&#34;
                message += &#34;\n In your DICOM folder, remove the folder Weasel&#34;
                message += &#34;\n and delete the .csv file.&#34;
                message += &#34;\n Then read the DICOM folder again.&#34;
                self.dialog.error(message)
                return
            try: # save changes in original file
                shutil.copyfile(created[0], removed[0])
            except:
                message = &#34;DICOM files have been removed or are open in another application.&#34;
                message += &#39;\n Close the files and try again.&#39;
                self.dialog.error(message)
                return
            os.remove(created[0])
            self.folder.dataframe.drop(created, inplace=True)
            self.folder.dataframe.loc[removed, &#39;removed&#39;] = False

        elif not removed.empty: # instance has been deleted
            index = removed.index
            os.remove(index[0])
            self.folder.dataframe.drop(index, inplace=True)
            
        elif not created.empty: # instance has been newly created
            self.folder.dataframe.loc[created.index, &#39;created&#39;] = False

    def restore_OBSOLETE(self):
        &#34;&#34;&#34;
        Reverses all changes made since the last save.
        &#34;&#34;&#34;
        in_memory = self.in_memory()
        self.clear() 
        rows = self.folder.dataframe[self.key[-1]] == self.UID[-1]
        data = self.folder.dataframe[rows] 
        created = data.created[data.created]
        removed = data.removed[data.removed]
        if not removed.empty: # restore deleted files
            index = removed.index
            self.folder.dataframe.loc[index, &#39;removed&#39;] = False
        if not created.empty: # delete new files
            index = created.index
            file = index[0]
            self.folder.dataframe.drop(index, inplace = True)
            if os.path.exists(file): os.remove(file)
        if in_memory: self.read()

    def export(self, path):
        &#34;&#34;&#34;Export instances to an external folder.

        This will create another copy of the same instance.
        The instance itself will not be removed from the DICOM folder.
        Instead a copy of the file will be copied to the external folder.
        
        Arguments
        ---------
        path : str
            path to an external folder.
        &#34;&#34;&#34;
        in_memory = self.in_memory()
        if not in_memory: self.read()
        filename = os.path.basename(self.file)
        destination = os.path.join(path, filename)
        self._save_ds(destination)
        if not in_memory: self.clear()

    def _initialize(self, ref_ds=None):
        &#34;&#34;&#34;Initialize the attributes relevant for the Images&#34;&#34;&#34;

        self.ds = utilities._initialize(self.ds, UID=self.UID, ref=ref_ds)
        return

        # overwrite UIDs
        self.ds.PatientID = self.UID[0]
        self.ds.StudyInstanceUID = self.UID[1]
        self.ds.SeriesInstanceUID = self.UID[2]
        self.ds.SOPInstanceUID = self.UID[3]

        # Date and Time of Creation
        dt = datetime.now()
        timeStr = dt.strftime(&#39;%H%M%S&#39;)  # long format with micro seconds

        self.ds.ContentDate = dt.strftime(&#39;%Y%m%d&#39;)
        self.ds.ContentTime = timeStr
        self.ds.AcquisitionDate = dt.strftime(&#39;%Y%m%d&#39;)
        self.ds.AcquisitionTime = timeStr
        self.ds.SeriesDate = dt.strftime(&#39;%Y%m%d&#39;)
        self.ds.SeriesTime = timeStr
        self.ds.InstanceCreationDate = dt.strftime(&#39;%Y%m%d&#39;)
        self.ds.InstanceCreationTime = timeStr

        if ref_ds is None: return

        # Series, Instance and Class for Reference
        refd_instance = Dataset()
        refd_instance.ReferencedSOPClassUID = ref_ds.SOPClassUID
        refd_instance.ReferencedSOPInstanceUID = ref_ds.SOPInstanceUID
        refd_instance_sequence = Sequence()
        refd_instance_sequence.append(refd_instance)

        refd_series = Dataset()
        refd_series.ReferencedInstanceSequence = refd_instance_sequence
        refd_series.SeriesInstanceUID = self.ds.SeriesInstanceUID
        refd_series_sequence = Sequence()
        refd_series_sequence.append(refd_series)

        self.ds.ReferencedSeriesSequence = refd_series_sequence</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dbdicom.classes.instance.Instance"><code class="flex name class">
<span>class <span class="ident">Instance</span></span>
<span>(</span><span>folder, UID=[], **attributes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Instance(Record):

    def __init__(self, folder, UID=[], **attributes):
        super().__init__(folder, UID, generation=4, **attributes)

    def label(self, row=None):

        if row is None:
            data = self.data()
            if data.empty: return &#34;New Instance&#34;
            file = data.index[0]
            nr = data.at[file, &#39;InstanceNumber&#39;]
        else:
            nr = row.InstanceNumber

        return str(nr).zfill(6)

    @property
    def file(self):
        &#34;&#34;&#34;Returns the filepath to the instance.&#34;&#34;&#34;
 
        files = self.files
        if len(files) != 0:  
            return files[0]

    def __getitem__(self, tags):
        &#34;&#34;&#34;Gets the value of the data elements with specified tags.
        
        Arguments
        ---------
        tags : a string, hexadecimal tuple, or a list of strings and hexadecimal tuples

        Returns
        -------
        A value or a list of values
        &#34;&#34;&#34;
        in_memory = self.in_memory()
        if not in_memory: 
            self.read()
        values = utilities._read_tags(self.ds, tags)   
        if not in_memory: 
            self.clear()
        return values

    def __setitem__(self, tags, values):
        &#34;&#34;&#34;
        Sets the value of the data element with given tag.
        &#34;&#34;&#34;
        on_disk = self.on_disk()
        if on_disk: 
            self.read()
        utilities._set_tags(self.ds, tags, values)
        if on_disk:
            self.write()
            self.clear()

    def write(self):
        &#34;&#34;&#34;Writes the dataset to disk&#34;&#34;&#34;

        if self.on_disk(): return
        ds = self.ds

        # Ensure DICOM hierarchy is respected
        if not &#39;PatientID&#39; in ds:
            ds.PatientID = pydicom.uid.generate_uid()
        if not &#39;StudyInstanceUID&#39; in ds:
            ds.StudyInstanceUID = pydicom.uid.generate_uid()
        if not &#39;SeriesInstanceUID&#39; in ds:
            ds.SeriesInstanceUID = pydicom.uid.generate_uid()    
        if not &#39;SOPInstanceUID&#39; in ds:
            ds.SOPInstanceUID = pydicom.uid.generate_uid()    

        df = self.data()
        if df.empty: # Data exist in memory only.
            self.folder._append(ds)
        else: 
            file = df.index[0] 
            if not df.loc[file,&#39;created&#39;]:  # This is the first change 
                self.folder.dataframe.loc[file,&#39;removed&#39;] = True
                self.folder._append(ds)
            else:   # Update values in dataframe row
                self.folder._update(file, ds)

        self._save_ds()

    def _save_ds(self, file=None):

        if file is None: 
            file = self.file
        try:
            self.ds.save_as(file) 
        except:
            message = &#34;Failed to write to &#34; + file
            message += &#34;\n The file is open in another application, or is being synchronised by a cloud service.&#34;
            message += &#34;\n Please close the file or pause the synchronisation and try again.&#34;
            self.dialog.information(message)

    def clear(self):
        &#34;&#34;&#34;Clears the dataset in memory&#34;&#34;&#34;

        self.__dict__[&#39;ds&#39;] = None 

    def read(self):
        &#34;&#34;&#34;Reads the dataset into memory.&#34;&#34;&#34;

        file = self.file
        if file is None: 
            return
        try:
            self.ds = pydicom.dcmread(file)
        except:
            message = &#34;Failed to read &#34; + file
            message += &#34;\n Please read the DICOM folder again via File-&gt;Read.&#34;
            self.dialog.information(message)            
        return self.ds # return self instead so read can be piped: series.read().copy_to(parent)

    def _copy_to_OBSOLETE(self, ancestor): # Replaced by copy_to in record
        &#34;&#34;&#34;copy instance to a new ancestor.
        
        dicom_object: Root, Patient, Study, or Series
            If the object is not a series, the missing 
            intermediate generations are automatically created.
        &#34;&#34;&#34;
        # Generate new instance
        copy = self.__class__(self.folder, UID=ancestor.UID)

        if self.in_memory(): # Create the copy in memory
            copy.__dict__[&#39;ds&#39;] = deepcopy(self.ds)
            copy._initialize(self.ds)
            if ancestor.in_memory():
                ancestor.ds.append(copy)
        else: # Create copy on disk
            self.read()
            copy.__dict__[&#39;ds&#39;] = self.ds
            copy._initialize(self.ds)
            copy.folder._append(copy.ds)
            copy._save_ds()
            self.clear()
            if ancestor.in_memory():
                ancestor.ds.append(copy) 
            else:       
                copy.clear()
            
        return copy

    def save_OBSOLETE(self):
        &#34;&#34;&#34;
        Saves all changes made in the instance
        &#34;&#34;&#34;
        self.write() 
        rows = self.folder.dataframe.SOPInstanceUID == self.UID[-1]
        data = self.folder.dataframe[rows] 
        created = data.created[data.created]
        removed = data.removed[data.removed]

        if data.shape[0] == 2: # instance has been modified
            created = created.index
            removed = removed.index
            if created.empty or removed.empty: 
                message = &#39;DICOM dataset &#39; + self.file
                message += &#34;\n Source data have been corrupted.&#34;
                message += &#34;\n In your DICOM folder, remove the folder Weasel&#34;
                message += &#34;\n and delete the .csv file.&#34;
                message += &#34;\n Then read the DICOM folder again.&#34;
                self.dialog.error(message)
                return
            try: # save changes in original file
                shutil.copyfile(created[0], removed[0])
            except:
                message = &#34;DICOM files have been removed or are open in another application.&#34;
                message += &#39;\n Close the files and try again.&#39;
                self.dialog.error(message)
                return
            os.remove(created[0])
            self.folder.dataframe.drop(created, inplace=True)
            self.folder.dataframe.loc[removed, &#39;removed&#39;] = False

        elif not removed.empty: # instance has been deleted
            index = removed.index
            os.remove(index[0])
            self.folder.dataframe.drop(index, inplace=True)
            
        elif not created.empty: # instance has been newly created
            self.folder.dataframe.loc[created.index, &#39;created&#39;] = False

    def restore_OBSOLETE(self):
        &#34;&#34;&#34;
        Reverses all changes made since the last save.
        &#34;&#34;&#34;
        in_memory = self.in_memory()
        self.clear() 
        rows = self.folder.dataframe[self.key[-1]] == self.UID[-1]
        data = self.folder.dataframe[rows] 
        created = data.created[data.created]
        removed = data.removed[data.removed]
        if not removed.empty: # restore deleted files
            index = removed.index
            self.folder.dataframe.loc[index, &#39;removed&#39;] = False
        if not created.empty: # delete new files
            index = created.index
            file = index[0]
            self.folder.dataframe.drop(index, inplace = True)
            if os.path.exists(file): os.remove(file)
        if in_memory: self.read()

    def export(self, path):
        &#34;&#34;&#34;Export instances to an external folder.

        This will create another copy of the same instance.
        The instance itself will not be removed from the DICOM folder.
        Instead a copy of the file will be copied to the external folder.
        
        Arguments
        ---------
        path : str
            path to an external folder.
        &#34;&#34;&#34;
        in_memory = self.in_memory()
        if not in_memory: self.read()
        filename = os.path.basename(self.file)
        destination = os.path.join(path, filename)
        self._save_ds(destination)
        if not in_memory: self.clear()

    def _initialize(self, ref_ds=None):
        &#34;&#34;&#34;Initialize the attributes relevant for the Images&#34;&#34;&#34;

        self.ds = utilities._initialize(self.ds, UID=self.UID, ref=ref_ds)
        return

        # overwrite UIDs
        self.ds.PatientID = self.UID[0]
        self.ds.StudyInstanceUID = self.UID[1]
        self.ds.SeriesInstanceUID = self.UID[2]
        self.ds.SOPInstanceUID = self.UID[3]

        # Date and Time of Creation
        dt = datetime.now()
        timeStr = dt.strftime(&#39;%H%M%S&#39;)  # long format with micro seconds

        self.ds.ContentDate = dt.strftime(&#39;%Y%m%d&#39;)
        self.ds.ContentTime = timeStr
        self.ds.AcquisitionDate = dt.strftime(&#39;%Y%m%d&#39;)
        self.ds.AcquisitionTime = timeStr
        self.ds.SeriesDate = dt.strftime(&#39;%Y%m%d&#39;)
        self.ds.SeriesTime = timeStr
        self.ds.InstanceCreationDate = dt.strftime(&#39;%Y%m%d&#39;)
        self.ds.InstanceCreationTime = timeStr

        if ref_ds is None: return

        # Series, Instance and Class for Reference
        refd_instance = Dataset()
        refd_instance.ReferencedSOPClassUID = ref_ds.SOPClassUID
        refd_instance.ReferencedSOPInstanceUID = ref_ds.SOPInstanceUID
        refd_instance_sequence = Sequence()
        refd_instance_sequence.append(refd_instance)

        refd_series = Dataset()
        refd_series.ReferencedInstanceSequence = refd_instance_sequence
        refd_series.SeriesInstanceUID = self.ds.SeriesInstanceUID
        refd_series_sequence = Sequence()
        refd_series_sequence.append(refd_series)

        self.ds.ReferencedSeriesSequence = refd_series_sequence</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dbdicom.classes.record.Record" href="record.html#dbdicom.classes.record.Record">Record</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>dbdicom.classes.image.Image</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="dbdicom.classes.instance.Instance.file"><code class="name">var <span class="ident">file</span></code></dt>
<dd>
<div class="desc"><p>Returns the filepath to the instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def file(self):
    &#34;&#34;&#34;Returns the filepath to the instance.&#34;&#34;&#34;

    files = self.files
    if len(files) != 0:  
        return files[0]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dbdicom.classes.instance.Instance.label"><code class="name flex">
<span>def <span class="ident">label</span></span>(<span>self, row=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def label(self, row=None):

    if row is None:
        data = self.data()
        if data.empty: return &#34;New Instance&#34;
        file = data.index[0]
        nr = data.at[file, &#39;InstanceNumber&#39;]
    else:
        nr = row.InstanceNumber

    return str(nr).zfill(6)</code></pre>
</details>
</dd>
<dt id="dbdicom.classes.instance.Instance.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes the dataset to disk</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self):
    &#34;&#34;&#34;Writes the dataset to disk&#34;&#34;&#34;

    if self.on_disk(): return
    ds = self.ds

    # Ensure DICOM hierarchy is respected
    if not &#39;PatientID&#39; in ds:
        ds.PatientID = pydicom.uid.generate_uid()
    if not &#39;StudyInstanceUID&#39; in ds:
        ds.StudyInstanceUID = pydicom.uid.generate_uid()
    if not &#39;SeriesInstanceUID&#39; in ds:
        ds.SeriesInstanceUID = pydicom.uid.generate_uid()    
    if not &#39;SOPInstanceUID&#39; in ds:
        ds.SOPInstanceUID = pydicom.uid.generate_uid()    

    df = self.data()
    if df.empty: # Data exist in memory only.
        self.folder._append(ds)
    else: 
        file = df.index[0] 
        if not df.loc[file,&#39;created&#39;]:  # This is the first change 
            self.folder.dataframe.loc[file,&#39;removed&#39;] = True
            self.folder._append(ds)
        else:   # Update values in dataframe row
            self.folder._update(file, ds)

    self._save_ds()</code></pre>
</details>
</dd>
<dt id="dbdicom.classes.instance.Instance.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clears the dataset in memory</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    &#34;&#34;&#34;Clears the dataset in memory&#34;&#34;&#34;

    self.__dict__[&#39;ds&#39;] = None </code></pre>
</details>
</dd>
<dt id="dbdicom.classes.instance.Instance.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads the dataset into memory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self):
    &#34;&#34;&#34;Reads the dataset into memory.&#34;&#34;&#34;

    file = self.file
    if file is None: 
        return
    try:
        self.ds = pydicom.dcmread(file)
    except:
        message = &#34;Failed to read &#34; + file
        message += &#34;\n Please read the DICOM folder again via File-&gt;Read.&#34;
        self.dialog.information(message)            
    return self.ds # return self instead so read can be piped: series.read().copy_to(parent)</code></pre>
</details>
</dd>
<dt id="dbdicom.classes.instance.Instance.save_OBSOLETE"><code class="name flex">
<span>def <span class="ident">save_OBSOLETE</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves all changes made in the instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_OBSOLETE(self):
    &#34;&#34;&#34;
    Saves all changes made in the instance
    &#34;&#34;&#34;
    self.write() 
    rows = self.folder.dataframe.SOPInstanceUID == self.UID[-1]
    data = self.folder.dataframe[rows] 
    created = data.created[data.created]
    removed = data.removed[data.removed]

    if data.shape[0] == 2: # instance has been modified
        created = created.index
        removed = removed.index
        if created.empty or removed.empty: 
            message = &#39;DICOM dataset &#39; + self.file
            message += &#34;\n Source data have been corrupted.&#34;
            message += &#34;\n In your DICOM folder, remove the folder Weasel&#34;
            message += &#34;\n and delete the .csv file.&#34;
            message += &#34;\n Then read the DICOM folder again.&#34;
            self.dialog.error(message)
            return
        try: # save changes in original file
            shutil.copyfile(created[0], removed[0])
        except:
            message = &#34;DICOM files have been removed or are open in another application.&#34;
            message += &#39;\n Close the files and try again.&#39;
            self.dialog.error(message)
            return
        os.remove(created[0])
        self.folder.dataframe.drop(created, inplace=True)
        self.folder.dataframe.loc[removed, &#39;removed&#39;] = False

    elif not removed.empty: # instance has been deleted
        index = removed.index
        os.remove(index[0])
        self.folder.dataframe.drop(index, inplace=True)
        
    elif not created.empty: # instance has been newly created
        self.folder.dataframe.loc[created.index, &#39;created&#39;] = False</code></pre>
</details>
</dd>
<dt id="dbdicom.classes.instance.Instance.restore_OBSOLETE"><code class="name flex">
<span>def <span class="ident">restore_OBSOLETE</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reverses all changes made since the last save.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def restore_OBSOLETE(self):
    &#34;&#34;&#34;
    Reverses all changes made since the last save.
    &#34;&#34;&#34;
    in_memory = self.in_memory()
    self.clear() 
    rows = self.folder.dataframe[self.key[-1]] == self.UID[-1]
    data = self.folder.dataframe[rows] 
    created = data.created[data.created]
    removed = data.removed[data.removed]
    if not removed.empty: # restore deleted files
        index = removed.index
        self.folder.dataframe.loc[index, &#39;removed&#39;] = False
    if not created.empty: # delete new files
        index = created.index
        file = index[0]
        self.folder.dataframe.drop(index, inplace = True)
        if os.path.exists(file): os.remove(file)
    if in_memory: self.read()</code></pre>
</details>
</dd>
<dt id="dbdicom.classes.instance.Instance.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"><p>Export instances to an external folder.</p>
<p>This will create another copy of the same instance.
The instance itself will not be removed from the DICOM folder.
Instead a copy of the file will be copied to the external folder.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>path to an external folder.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, path):
    &#34;&#34;&#34;Export instances to an external folder.

    This will create another copy of the same instance.
    The instance itself will not be removed from the DICOM folder.
    Instead a copy of the file will be copied to the external folder.
    
    Arguments
    ---------
    path : str
        path to an external folder.
    &#34;&#34;&#34;
    in_memory = self.in_memory()
    if not in_memory: self.read()
    filename = os.path.basename(self.file)
    destination = os.path.join(path, filename)
    self._save_ds(destination)
    if not in_memory: self.clear()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="dbdicom.classes.record.Record" href="record.html#dbdicom.classes.record.Record">Record</a></b></code>:
<ul class="hlist">
<li><code><a title="dbdicom.classes.record.Record.array" href="record.html#dbdicom.classes.record.Record.array">array</a></code></li>
<li><code><a title="dbdicom.classes.record.Record.children" href="record.html#dbdicom.classes.record.Record.children">children</a></code></li>
<li><code><a title="dbdicom.classes.record.Record.copy" href="record.html#dbdicom.classes.record.Record.copy">copy</a></code></li>
<li><code><a title="dbdicom.classes.record.Record.data" href="record.html#dbdicom.classes.record.Record.data">data</a></code></li>
<li><code><a title="dbdicom.classes.record.Record.dataset" href="record.html#dbdicom.classes.record.Record.dataset">dataset</a></code></li>
<li><code><a title="dbdicom.classes.record.Record.files" href="record.html#dbdicom.classes.record.Record.files">files</a></code></li>
<li><code><a title="dbdicom.classes.record.Record.in_memory" href="record.html#dbdicom.classes.record.Record.in_memory">in_memory</a></code></li>
<li><code><a title="dbdicom.classes.record.Record.instances" href="record.html#dbdicom.classes.record.Record.instances">instances</a></code></li>
<li><code><a title="dbdicom.classes.record.Record.key" href="record.html#dbdicom.classes.record.Record.key">key</a></code></li>
<li><code><a title="dbdicom.classes.record.Record.move_to" href="record.html#dbdicom.classes.record.Record.move_to">move_to</a></code></li>
<li><code><a title="dbdicom.classes.record.Record.new_child" href="record.html#dbdicom.classes.record.Record.new_child">new_child</a></code></li>
<li><code><a title="dbdicom.classes.record.Record.new_cousin" href="record.html#dbdicom.classes.record.Record.new_cousin">new_cousin</a></code></li>
<li><code><a title="dbdicom.classes.record.Record.new_pibling" href="record.html#dbdicom.classes.record.Record.new_pibling">new_pibling</a></code></li>
<li><code><a title="dbdicom.classes.record.Record.new_series" href="record.html#dbdicom.classes.record.Record.new_series">new_series</a></code></li>
<li><code><a title="dbdicom.classes.record.Record.new_sibling" href="record.html#dbdicom.classes.record.Record.new_sibling">new_sibling</a></code></li>
<li><code><a title="dbdicom.classes.record.Record.parent" href="record.html#dbdicom.classes.record.Record.parent">parent</a></code></li>
<li><code><a title="dbdicom.classes.record.Record.patients" href="record.html#dbdicom.classes.record.Record.patients">patients</a></code></li>
<li><code><a title="dbdicom.classes.record.Record.records" href="record.html#dbdicom.classes.record.Record.records">records</a></code></li>
<li><code><a title="dbdicom.classes.record.Record.remove" href="record.html#dbdicom.classes.record.Record.remove">remove</a></code></li>
<li><code><a title="dbdicom.classes.record.Record.restore" href="record.html#dbdicom.classes.record.Record.restore">restore</a></code></li>
<li><code><a title="dbdicom.classes.record.Record.save" href="record.html#dbdicom.classes.record.Record.save">save</a></code></li>
<li><code><a title="dbdicom.classes.record.Record.series" href="record.html#dbdicom.classes.record.Record.series">series</a></code></li>
<li><code><a title="dbdicom.classes.record.Record.set_array" href="record.html#dbdicom.classes.record.Record.set_array">set_array</a></code></li>
<li><code><a title="dbdicom.classes.record.Record.studies" href="record.html#dbdicom.classes.record.Record.studies">studies</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dbdicom.classes" href="index.html">dbdicom.classes</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dbdicom.classes.instance.Instance" href="#dbdicom.classes.instance.Instance">Instance</a></code></h4>
<ul class="two-column">
<li><code><a title="dbdicom.classes.instance.Instance.label" href="#dbdicom.classes.instance.Instance.label">label</a></code></li>
<li><code><a title="dbdicom.classes.instance.Instance.write" href="#dbdicom.classes.instance.Instance.write">write</a></code></li>
<li><code><a title="dbdicom.classes.instance.Instance.clear" href="#dbdicom.classes.instance.Instance.clear">clear</a></code></li>
<li><code><a title="dbdicom.classes.instance.Instance.read" href="#dbdicom.classes.instance.Instance.read">read</a></code></li>
<li><code><a title="dbdicom.classes.instance.Instance.save_OBSOLETE" href="#dbdicom.classes.instance.Instance.save_OBSOLETE">save_OBSOLETE</a></code></li>
<li><code><a title="dbdicom.classes.instance.Instance.restore_OBSOLETE" href="#dbdicom.classes.instance.Instance.restore_OBSOLETE">restore_OBSOLETE</a></code></li>
<li><code><a title="dbdicom.classes.instance.Instance.export" href="#dbdicom.classes.instance.Instance.export">export</a></code></li>
<li><code><a title="dbdicom.classes.instance.Instance.file" href="#dbdicom.classes.instance.Instance.file">file</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>